---
title: 列挙型 - enum
---

>オブジェクト指向プログラミングおよび演習1 第6回  
>  
>Javaの列挙型はとっても強力


## 1\. はじめに

Javaの列挙型（enum）について、その基本的な概念から、開発現場で役立つ実践的な設計方法、さらにはenumが持つ強力な拡張機能に至るまでを詳細に解説します。

Javaのenumは、単なる定数の集まりを超え、独自の振る舞いを持つオブジェクトとして機能する非常にパワフルな機能です。
enumを効果的に活用し、より安全で可読性の高い、保守性に優れたコードを書くための知識とテクニックを習得しましょう。

## 2\. Javaにおけるenumの基本

### 2.1. 列挙型とは

一連の関連する定数値の集まりを、型として定義できる特殊なクラスです。これにより、プログラム内で使用する定数を意味のある名前でグループ化し、型安全性を高めることができます。

### 2.2. C言語の列挙型と似て非なるもの

C言語の列挙型は、実質的には整数定数に名前を付けたものであり、列挙子が取りうる値は整数に限られていました。

一方、Javaの列挙型は、以下のような特徴を持つ「クラス」として扱われます。

* **オブジェクト**: 各列挙子は、そのenum型のユニークなインスタンスです。
* **フィールド**: 各列挙子に固有のデータを持たせることができます。
* **メソッド**: enum全体、または各列挙子に固有の振る舞いを定義できます。
* **不変性**: enumのインスタンスはコンパイル時に生成され、実行時に変更することはできません（イミュータブル）。

コード中で `enum` キーワードによって定義された列挙型クラスは、暗黙的に `java.lang.Enum` クラスのサブクラスとなります。このスーパークラスは、すべてのenum型に共通の便利なメソッド（例: `name()`, `ordinal()`, `valueOf()` など）を提供します。

詳細は公式ドキュメントも参照してください。  
[Enum (Java SE 21 & JDK 21)](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/lang/Enum.html)

Javaのenumは、その強力さにもかかわらず、基本的な定数としての使い方以外は見落とされがちですが、適切に活用することでコードの品質を大きく向上させることができます。

### 2.3. もっとも簡単な列挙型の定義方法

シンプルに列挙型を定義するには以下のように行います。

```java
アクセス修飾子 enum 列挙型名 {
    列挙子１,
    列挙子２,
    列挙子３ // 最後の列挙子の後ろのカンマはあってもなくても良いが、追加の容易性を考えると付けることが推奨される
}
```

列挙型名は、通常のクラスやインターフェイスと同様、先頭文字を大文字とするのが慣例です（アッパーキャメルケース）。各列挙子は、慣例としてすべて大文字のスネークケース（例: `SAMPLE_VALUE`）で記述されます。

#### 列挙子の書き方の補足:

`{ }` の中に列挙子をカンマ `,` で区切って記述します。

最後の列挙子の後ろのカンマは、記述のスタイルとして許容されており、一般的には後から列挙子を追加する際のカンマの付け忘れを防ぐために記述することが推奨されます。
```java
enum Signal {
    RED,
    YELLOW,
    GREEN, // 推奨される書き方
}
```

**重要**: enumにフィールドやメソッドを定義する場合、最後の列挙子の後ろにはセミコロン `;` が**必須**となります。
```java
enum Status {
    ACTIVE,
    INACTIVE; // フィールドやメソッドが続く場合はセミコロンが必須

    // (フィールドやメソッドの定義)
}
```

### 2.4. 列挙型の基本的な使い方（switch文など）

定義した列挙型は、変数の方として利用したり、`switch`文の条件分岐に使用したりできます。

```java
// 信号機の色を表す列挙型
public enum Signal {
    RED,
    YELLOW,
    GREEN
}

public class TrafficLightSimulator {

    public static void main(String[] args) {
        // 列挙型の変数を宣言し、列挙子を代入
        Signal currentSignal = Signal.RED;
        displayAction(currentSignal);

        currentSignal = Signal.GREEN;
        displayAction(currentSignal);

        // 文字列から列挙子を取得 (valueOfメソッド)
        // Signal blueSignal = Signal.valueOf("BLUE");

        // ただし、"BLUE" は Signal に存在しないため IllegalArgumentException が発生
        // try-catch で適切に処理する必要がある

        // displayAction(blueSignal); // 例外が発生するためコメントアウト
    }

    // 列挙型を引数に取るメソッド
    public static void displayAction(Signal signal) {
        // switch文で列挙子に応じた処理を分岐
        // Java 14以降ではSwitch Expressionsも利用可能で、より簡潔に記述できる
        switch (signal) {
            case RED: // 修飾なしで列挙子名を直接記述可能
                System.out.println("止まれ");
                break;
            case YELLOW:
                System.out.println("注意");
                break;
            case GREEN:
                System.out.println("進め");
                break;
            default: // enumのswitchでは、全ての列挙子をcaseで網羅していればdefaultは不要な場合もある
                     // しかし、将来的なenumの追加を考慮すると、予期せぬ状況に対応するためにdefaultを記述することが推奨される
                System.out.println("不明な信号");
                break;
        }
    }
    // Java 14以降のSwitch Expressionsを使用したメソッド
    public static void displayActionWithSwitchExpression(Signal signal) {

        // Switch Expressions (switch式) を使用すると、より簡潔に記述できる。
        // 各caseラベルの後に `->` を使用し、その右側に値を記述するか、
        // または波括弧 {} を使って複数のステートメントを持つブロックを記述し、`yield` キーワードで値を返すことも可能。
        // この例では、switch式全体がString型の値を生成する。

        String actionMessage = switch (signal) {
            case RED -> "止まれ";     // signalがREDの場合、このswitch式は "止まれ" という文字列を返す
            case YELLOW -> "注意";   // signalがYELLOWの場合、このswitch式は "注意" という文字列を返す
            case GREEN -> "進め";    // signalがGREENの場合、このswitch式は "進め" という文字列を返す

            // Signal enumの全ての列挙子 (RED, YELLOW, GREEN) がcaseで網羅されているため、
            // この場合はdefault節がなくてもコンパイルエラーにならない。
            // もし網羅されていない場合や、将来のenum追加時に明示的に対応したい場合は、
            // default -> "不明な信号"; のようにdefault節を追加することも可能。
            // default節がない状態で未知のenum値が渡された場合 (通常はありえないが、
            // ライブラリのバージョン不整合などで発生しうる)、実行時に IncompatibleClassChangeError がスローされる可能性がある。
        };
        System.out.println(actionMessage); // switch式が返したメッセージを出力
    }
}
```

#### 実行結果 (コメントアウト部分を実行しない場合):

```
止まれ
進め
```

#### `java.lang.Enum`クラスの主要メソッド:

* `String name()`: 列挙定数の名前（定義した通りの文字列）を返します。
* `int ordinal()`: 列挙定数の定義順序（0から始まる）を返します。
* `static <T extends Enum<T>> T valueOf(Class<T> enumType, String name)`: 指定された名前を持つ指定されたenum型の列挙定数を返します。
* `static <T extends Enum<T>> T[] values()`:（コンパイラによって暗黙的に追加されるメソッド）enumのすべての列挙子を定義順に格納した配列を返します。

これらは、列挙型を定義すると親クラスとして`java.lang.Enum`が暗黙的に継承されていることを覚えておきましょう。
（※`<T extends Enum<T>>`などの`<>`で表現される型はジェネリクスと呼ばれる概念です。まだ講義で取り扱っていない概念ですので、詳細はジェネリクスを学んだ後に復習してください。）

## 3\. なぜenumを使うのか？メリットと考慮点

定数を表現する方法として、`public static final`フィールドを使うこともできますが、enumにはそれを超える多くの利点があります。

### 3.1. メリット

#### 1. 型安全性の保証 (Type Safety)

* enumは独自の型を定義するため、メソッドの引数や戻り値にenum型を指定することで、許可された値のみを受け渡すように強制できます。
* たとえば、`int`型の定数を使っている場合、意図しない数値が渡される可能性もありますが、enumではコンパイル時にエラーとして検出できます。
* 文字列定数の場合、タイプミスによるバグが発生しやすいですが、enumならコンパイラがチェックしてくれます。

```java
// NG: int型定数ではどんな数値でも渡せてしまう
public void processStatusInt(int status) {
    if (status == 0) { /* ... */ }
    else if (status == 1) { /* ... */ }
}

// OK: enum型なら定義された値のみが保証される
public enum OrderStatus { PENDING, PROCESSING, SHIPPED }
public void processStatusEnum(OrderStatus status) {
    if (status == OrderStatus.PENDING) { /* ... */ }
}
```

#### 2. 可読性の向上 (Readability)

* 数値や文字列リテラルよりも、意味のある名前（列挙子名）でコードを記述できるため、コードの意図が明確になり、理解しやすくなります。
* `processType(1)` よりも `processType(TaskType.HIGH_PRIORITY)` の方が、何をしているのかが直感的に分かります。

#### 3. 定数の一元管理 (Centralized Management)

* 関連する定数を1つのenum定義にまとめることで、管理が容易になります。
* 変更や追加が必要な場合も、enumの定義箇所を修正するだけで済みます。

#### 4. `switch`文との高い親和性

* enumは`switch`文と非常に相性が良く、`case`ラベルにenumの定数を直接使用できます。
* IDEによっては、`switch`文ですべてのenum定数を網羅しているかチェックしてくれる機能もあり、バグの混入を防ぎます。

#### 5. `public static final`定数との比較（enumの優位性）

* **よりオブジェクト指向的**: enumはクラスなので、フィールドやメソッドを持つことができます。これにより、定数に関連するデータや振る舞いをカプセル化できます。
    * `public static final String MONDAY = "Monday";` のような文字列定数では、"Monday"という文字列以上の情報や振る舞いを持たせることは困難です。
* **名前空間の分離**: enumは独自の型を持つため、他の定数セットと名前が衝突する心配はありません。
* **`equals()`と`==`**: enumの比較は `==` 演算子で行うことができ、これは `equals()` メソッドよりも高速かつnull安全です（enum定数はシングルトンであるため）。
* **`EnumSet`, `EnumMap`**: enum専用の非常に効率的なSet/Map実装が用意されています。

### 3.2. デメリットと注意点

#### 1. 継承の制限
* すべてのenumは暗黙的に `java.lang.Enum` クラスを継承しているため、他のクラスを継承することはできません。ただし、インターフェイスを実装することは可能です（後述）。

#### 2. わずかなパフォーマンスオーバーヘッドの可能性

* 単純な `int` 定数と比較した場合、enumオブジェクトの生成やメソッド呼び出しにはごくわずかなオーバーヘッドが存在する可能性もあります。しかし、現代のJVMでは最適化が進んでおり、これが問題となるケースは稀です。可読性や安全性のメリットが上回ることの方が多いでしょう。

#### 3. シリアライズ時の注意

* enum定数はその名前（`name()`メソッドが返す文字列）でシリアライズされます。そのため、enum定数の名前を変更すると、古いバージョンでシリアライズされたデータとの互換性が失われる可能性もあります。
* 名前が頻繁に変わる可能性があるものや、永続化するデータで後方互換性が重要な場合は注意が必要です。

## 4\. enumのフィールドとメソッド

Javaのenumは単なる定数のリストではなく、フィールドやメソッドを持つことができる強力なクラスです。

### 4.1. 列挙子ごとのデータ保持

各列挙子に固有のデータを持たせるには、enum内にインスタンスフィールドとコンストラクタを定義します。

```java
package jp.ac.ait.enums;

// 月を表す列挙型（日本語名と英語略称を持つ）
public enum Month {
    // 各列挙子を定義する際に、コンストラクタの引数を指定する
    JANUARY("睦月", "Jan"),
    FEBRUARY("如月", "Feb"),
    MARCH("弥生", "Mar"),
    APRIL("卯月", "Apr"),
    MAY("皐月", "May"),
    JUNE("水無月", "Jun"),
    JULY("文月", "Jul"),
    AUGUST("葉月", "Aug"),
    SEPTEMBER("長月", "Sep"),
    OCTOBER("神無月", "Oct"),
    NOVEMBER("霜月", "Nov"),
    DECEMBER("師走", "Dec"); // 最後の列挙子の後にセミコロンが必要

    // --- フィールド定義 ---
    private final String japaneseName; // 日本語名 (不変)
    private final String shortName;    // 英語略称 (不変)

    // --- コンストラクタ ---
    // enumのコンストラクタは暗黙的にprivate。明示的にprivateを付けても良い。
    // publicやprotectedにはできない（外部からインスタンス化できないため）。
    private Month(String japaneseName, String shortName) {
        this.japaneseName = japaneseName;
        this.shortName = shortName;
    }

    // --- メソッド定義 ---
    // 日本語名を取得するアクセサメソッド
    public String getJapaneseName() {
        return this.japaneseName;
    }

    // 英語略称を取得するアクセサメソッド
    public String getShortName() {
        return this.shortName;
    }

    // 季節を返すメソッド (例)
    public String getSeason() {
        switch (this) {
            case DECEMBER:
            case JANUARY:
            case FEBRUARY:
                return "冬";
            case MARCH:
            case APRIL:
            case MAY:
                return "春";
            case JUNE:
            case JULY:
            case AUGUST:
                return "夏";
            case SEPTEMBER:
            case OCTOBER:
            case NOVEMBER:
                return "秋";
            default:
                throw new IllegalStateException("Unknown month: " + this);
        }
    }
}
```

#### `Month.java`のポイント:

* 列挙子の定義 `JANUARY("睦月", "Jan")` の部分で、コンストラクタ `Month(String japaneseName, String shortName)` が呼び出されています。
* フィールド `japaneseName` と `shortName` は `final` とすることで、一度設定された値が変更されないことを保証しています（イミュータブルなenumの性質と合致します）。
* コンストラクタは `private` です。enumのインスタンスはJVMによって列挙子の定義時にのみ生成され、外部から `new` することはできません。
* `getJapaneseName()`, `getShortName()`, `getSeason()` といったメソッドを通じて、各月に対応する情報や振る舞いを取得できます。

### 4.2. メインクラス (使用例)

```java
package jp.ac.ait.enums;

public class MonthDemo {
    public static void main(String[] args) {
        // 全ての月情報を表示
        System.out.println("--- 月の一覧 ---");
        for (Month month : Month.values()) { // values()メソッドで全列挙子を取得
            System.out.printf("%s (%s): 日本語名=%s, 季節=%s%n",
                    month.name(),              // 列挙子の名前 (JANUARYなど)
                    month.getShortName(),      // 略称 (Janなど)
                    month.getJapaneseName(),   // 日本語名 (睦月など)
                    month.getSeason()          // 季節
            );
        }

        System.out.println("\n--- 特定の月の情報 ---");
        Month may = Month.MAY;
        System.out.println("5月は英語で " + may + ", 日本語では " + may.getJapaneseName() + " です。");

        // 文字列からenum定数を取得 (大文字・小文字を区別する) ※取得できない場合も考慮したほうがよい（例外処理が必要）
        Month july = Month.valueOf("JULY");
        System.out.println("valueOf(\"JULY\") で取得: " + july.getJapaneseName());

        // ordinal() は定義順 (0から) を返す。通常はビジネスロジックに直接使用すべきではない。
        System.out.println(Month.JANUARY.name() + " の ordinal: " + Month.JANUARY.ordinal()); // 0
        System.out.println(Month.DECEMBER.name() + " の ordinal: " + Month.DECEMBER.ordinal()); // 11
    }
}
```

#### 実行結果:

```
--- 月の一覧 ---
JANUARY (Jan): 日本語名=睦月, 季節=冬
FEBRUARY (Feb): 日本語名=如月, 季節=冬
MARCH (Mar): 日本語名=弥生, 季節=春
APRIL (Apr): 日本語名=卯月, 季節=春
MAY (May): 日本語名=皐月, 季節=春
JUNE (Jun): 日本語名=水無月, 季節=夏
JULY (Jul): 日本語名=文月, 季節=夏
AUGUST (Aug): 日本語名=葉月, 季節=夏
SEPTEMBER (Sep): 日本語名=長月, 季節=秋
OCTOBER (Oct): 日本語名=神無月, 季節=秋
NOVEMBER (Nov): 日本語名=霜月, 季節=秋
DECEMBER (Dec): 日本語名=師走, 季節=冬

--- 特定の月の情報 ---
5月は英語で MAY, 日本語では 皐月 です。
valueOf("JULY") で取得: 文月
JANUARY の ordinal: 0
DECEMBER の ordinal: 11
```

### 4.3. 実践的な設計例1：状態管理（例：注文ステータス）

enumは、オブジェクトの状態を管理するのに非常に適しています。たとえば、オンラインショップの注文ステータスを考えてみましょう。

```java
package jp.ac.ait.ecommerce;

// 注文ステータスを表す列挙型
public enum OrderStatus {
    // --- 列挙子の定義 ---
    PENDING("保留中"),                // 注文受付、未支払い
    PAID("支払い済み"),              // 支払い完了、発送準備中
    PROCESSING("処理中"),            // 発送準備中、または製造中
    SHIPPED("発送済み"),             // 商品発送完了
    DELIVERED("配達済み"),           // 商品到着
    CANCELLED("キャンセル済み"),       // 注文キャンセル
    RETURNED("返品済み");            // 商品返品完了

    // --- フィールド ---
    private final String description; // ステータスの説明

    // --- コンストラクタ ---
    private OrderStatus(String description) {
        this.description = description;
    }

    // --- メソッド ---
    public String getDescription() {
        return description;
    }

    // 次に取りうるステータスかを判定するメソッド (簡易的な例)
    public boolean canTransitionTo(OrderStatus nextStatus) {
        switch (this) {
            case PENDING:
                return nextStatus == PAID || nextStatus == CANCELLED;
            case PAID:
                return nextStatus == PROCESSING || nextStatus == SHIPPED || nextStatus == CANCELLED;
            case PROCESSING:
                return nextStatus == SHIPPED || nextStatus == CANCELLED; // 例: 処理中もキャンセル可能
            case SHIPPED:
                return nextStatus == DELIVERED || nextStatus == RETURNED; // 発送後は返品の可能性も
            case DELIVERED:
                return nextStatus == RETURNED; // 配達後も返品は可能
            case CANCELLED:
            case RETURNED:
                return false; // 終端状態からは遷移不可
            default:
                return false;
        }
    }

    // ユーザーに表示可能か (例: キャンセル済みや返品済みは表示しないなど)
    public boolean isUserVisible() {
        return this != CANCELLED && this != RETURNED;
    }
}

// 注文クラス (OrderStatusを利用)
class Order {
    private String orderId;
    private OrderStatus status;

    public Order(String orderId) {
        this.orderId = orderId;
        this.status = OrderStatus.PENDING; // 初期ステータスは保留中
    }

    public OrderStatus getStatus() {
        return status;
    }

    public void updateStatus(OrderStatus newStatus) {
        if (this.status.canTransitionTo(newStatus)) {
            System.out.printf("注文ID %s: ステータスが %s から %s に変更されました。%n",
                    orderId, this.status.getDescription(), newStatus.getDescription());
            this.status = newStatus;
        } else {
            System.err.printf("注文ID %s: ステータス %s から %s への遷移は許可されていません。%n",
                    orderId, this.status.getDescription(), newStatus.getDescription());
        }
    }

    public String getOrderId() {
        return orderId;
    }
}

public class OrderDemo {
    public static void main(String[] args) {
        Order order1 = new Order("ORD001");
        System.out.println("初期状態: " + order1.getOrderId() + " - " + order1.getStatus().getDescription());

        order1.updateStatus(OrderStatus.PAID);        // PENDING -> PAID (許可)
        order1.updateStatus(OrderStatus.PROCESSING);  // PAID -> PROCESSING (許可)
        order1.updateStatus(OrderStatus.CANCELLED);   // PROCESSING -> CANCELLED (許可)
        order1.updateStatus(OrderStatus.SHIPPED);     // CANCELLED -> SHIPPED (不許可)

        System.out.println("\n---別の注文---");
        Order order2 = new Order("ORD002");
        order2.updateStatus(OrderStatus.PAID);
        order2.updateStatus(OrderStatus.SHIPPED);
        order2.updateStatus(OrderStatus.DELIVERED);
        System.out.println("最終状態: " + order2.getOrderId() + " - " + order2.getStatus().getDescription());

        // 表示可能なステータスのみフィルタリングする例
        System.out.println("\n---ユーザーに表示される可能性のあるステータス---");
        for (OrderStatus s : OrderStatus.values()) {
            if (s.isUserVisible()) {
                System.out.println(s.getDescription());
            }
        }
    }
}
```

この`OrderStatus` enumは、各状態がどのような説明を持つか（`description`フィールド）だけでなく、ある状態から次の状態へ遷移可能かどうか（`canTransitionTo`メソッド）という振る舞いも定義しています。これにより、状態遷移のロジックをenum内にカプセル化でき、`Order`クラスのコードをよりシンプルに保つことができます。

## 5\. Java enumの高度な活用法と拡張

enumは、各列挙子が独自のメソッド実装を持つことや、インターフェイスを実装することも可能です。

### 5.1. 列挙子ごとのメソッド実装 (定数固有メソッド)

enumで定義したメソッドを、各列挙子でオーバーライドすることで、列挙子ごとに異なる振る舞いをさせることができます。これは、ストラテジーパターンを簡潔に実現する方法の1つとも言えます。

もともとの講義資料にあった`Operation` enumは、この優れた例です。

```java
package jp.ac.ait.calculator;

// 四則演算を表す列挙型
public enum Operation {
    // 各列挙子で抽象メソッド apply を実装する
    PLUS("+") {
        @Override
        public double apply(double x, double y) {
            // 足し算を実行
            return x + y;
        }
    },
    MINUS("-") {
        @Override
        public double apply(double x, double y) {
            // 引き算を実行
            return x - y;
        }
    },
    TIMES("*") {
        @Override
        public double apply(double x, double y) {
            // 掛け算を実行
            return x * y;
        }
    },
    DIVIDE("/") {
        @Override
        public double apply(double x, double y) {
            // 割り算を実行
            if (y == 0) {
                throw new ArithmeticException("0による除算はできません。");
            }
            return x / y;
        }
    }; // 列挙子の定義の終わりにはセミコロンが必須

    // --- フィールド ---
    private final String symbol; // 演算記号

    // --- コンストラクタ ---
    private Operation(String symbol) {
        this.symbol = symbol;
    }

    // --- メソッド ---
    // 演算記号を取得するメソッド
    public String getSymbol() {
        return this.symbol;
    }

    // --- 抽象メソッド ---
    // 各列挙子で具体的な計算処理を実装するための抽象メソッド
    // このメソッドを定義することで、各列挙子に対応する apply の実装が強制される
    public abstract double apply(double x, double y);
}

public class CalculatorDemo {
    public static void main(String[] args) {
        double x = 10.0;
        double y = 5.0;

        // values()メソッドで全ての演算を取得し、それぞれ実行
        for (Operation op : Operation.values()) {
            try {
                System.out.printf("%.1f %s %.1f = %.1f%n", x, op.getSymbol(), y, op.apply(x, y));
            } catch (ArithmeticException e) {
                System.err.printf("%.1f %s %.1f でエラー: %s%n", x, op.getSymbol(), y, e.getMessage());
            }
        }

        System.out.println("\n--- 個別の計算 ---");
        Operation multiply = Operation.TIMES;
        System.out.printf("%.1f %s %.1f = %.1f%n", x, multiply.getSymbol(), y, multiply.apply(x, y));

        double z = 0.0;
        Operation divide = Operation.DIVIDE;
         try {
                System.out.printf("%.1f %s %.1f = %.1f%n", x, divide.getSymbol(), z, divide.apply(x, z));
            } catch (ArithmeticException e) {
                System.err.printf("%.1f %s %.1f でエラー: %s%n", x, divide.getSymbol(), z, e.getMessage());
            }
    }
}
```

#### `Operation.java`のポイント:

* `public abstract double apply(double x, double y);` という抽象メソッドをenum内に定義しています。
* 各列挙子 (`PLUS`, `MINUS`, `TIMES`, `DIVIDE`) は、この `apply` メソッドを自身に適した形でオーバーライド（実装）しています。
* これにより、`op.apply(x, y)` という同じ呼び出し方で、選択された演算に応じた具体的な処理が実行されます。
* これは、条件分岐 (if-elseやswitch) を使って処理を振り分けるよりも、各演算のロジックがそれぞれの列挙子に局所化されるため、コードの見通しが良くなり、新しい演算を追加する際も既存のコードへの影響を最小限に抑えられます。

### 5.2. インターフェイスの実装

enumはクラスを継承できませんが、1つ以上のインターフェイスを実装できます。これにより、enumをより柔軟に扱うことが可能になります。

```java
package jp.ac.ait.rules;

// 割引ルールを定義するインターフェイス
interface DiscountRule {
    double calculateDiscount(double originalPrice); // 元の価格から割引額を計算する
    String description(); // ルールの説明を返す
}

// 会員ランクとそれに応じた割引ルールを表すenum
// DiscountRuleインターフェイスを実装する
public enum MembershipRank implements DiscountRule {
    // --- 列挙子の定義とインターフェイスメソッドの実装 ---
    REGULAR("通常会員", 0.0) { // 通常会員は割引なし
        @Override
        public double calculateDiscount(double originalPrice) {
            // 割引額は0
            return 0.0;
        }
    },
    SILVER("シルバー会員", 0.05) { // シルバー会員は5%割引
        @Override
        public double calculateDiscount(double originalPrice) {
            // 価格の5%を割引額とする
            return originalPrice * this.discountRate;
        }
    },
    GOLD("ゴールド会員", 0.1) { // ゴールド会員は10%割引
        @Override
        public double calculateDiscount(double originalPrice) {
            // 価格の10%を割引額とする
            return originalPrice * this.discountRate;
        }
    },
    PLATINUM("プラチナ会員", 0.15) { // プラチナ会員は15%割引
        @Override
        public double calculateDiscount(double originalPrice) {
            // 価格の15%を割引額とする
            return originalPrice * this.discountRate;
        }
    }; // セミコロン必須

    // --- フィールド ---
    private final String rankName;      // 会員ランク名
    protected final double discountRate; // 基本割引率（各列挙子で利用可能にするためprotected）

    // --- コンストラクタ ---
    private MembershipRank(String rankName, double discountRate) {
        this.rankName = rankName;
        this.discountRate = discountRate;
    }

    // --- DiscountRuleインターフェイスのメソッド実装 (共通部分) ---
    @Override
    public String description() {
        // ランク名と割引率(%)を説明として返す
        return String.format("%s (割引率: %.0f%%)", this.rankName, this.discountRate * 100);
    }

    // --- enum独自のメソッド ---
    public String getRankName() {
        return rankName;
    }

    // 最終的な価格を計算するメソッド
    public double applyPrice(double originalPrice) {
        double discountAmount = calculateDiscount(originalPrice); // 実装されたdiscountメソッドを呼び出す
        return originalPrice - discountAmount;
    }
}


public class DiscountDemo {
    public static void main(String[] args) {
        double price = 10000; // 商品価格

        System.out.println("商品価格: " + price + "円");
        System.out.println("--- 各会員ランクの割引適用後価格 ---");

        for (MembershipRank rank : MembershipRank.values()) {
            // rankはDiscountRule型としても扱える
            DiscountRule rule = rank;

            double finalPrice = rank.applyPrice(price); // enum独自のメソッドも使える
            // double discount = rule.calculateDiscount(price); // インターフェイス経由でも呼べる
            // double finalPriceUsingRule = price - discount;

            System.out.printf("%s: 割引後価格 = %.0f円 (説明: %s)%n",
                    rank.getRankName(),
                    finalPrice,
                    rule.description() // インターフェイスのメソッド呼び出し
            );
        }

        // 特定のランクで処理
        MembershipRank myRank = MembershipRank.GOLD;
        System.out.printf("\nあなたのランク (%s) で %.0f円の商品を購入する場合、支払額は %.0f円です。%n",
                myRank.getRankName(), price, myRank.applyPrice(price));
    }
}
```

#### `MembershipRank.java`のポイント:

  * `MembershipRank` enumが `DiscountRule` インターフェイスを `implements` しています。
  * `DiscountRule` が要求する `calculateDiscount()` メソッドと `description()` メソッドを実装しています。
  * `calculateDiscount()` は各列挙子で異なるロジック（割引率）を適用するようにオーバーライドされています。
  * `description()` はenum全体で共通のロジックで実装することも、列挙子ごとにオーバーライドすることも可能です（この例では共通実装）。
  * これにより、`MembershipRank` のインスタンスを `DiscountRule` 型の変数で扱うことができ、ポリモーフィズム（多態性）の恩恵を受けることができます。たとえば、さまざまな種類のルール（ポイント加算ルール、送料無料ルールなど）を同じインターフェイスで統一的に扱えるようになります。

### 5.3. 実践的な設計例2：設定値の管理と処理（例：ログレベル）

enumは、アプリケーションの設定値を型安全に管理し、それに関連する処理を紐付けるのにも便利です。

```java
package jp.ac.ait.logging;

// ログレベルを定義するenum
// 各レベルには整数値の重要度と、ログ出力が可能かどうかを判定するロジックを持つ
public enum LogLevel {
    // --- 列挙子の定義 ---
    // 各ログレベルに重要度(severity)を割り当てる
    // severityの値が小さいほど重要度が高いとする (0が最も重要)
    OFF(Integer.MAX_VALUE, "出力しない") { // ログを一切出力しない特別なレベル
        @Override
        public boolean isLoggable(LogLevel currentLevelSetting) {
            return false; // OFFは何に対しても出力しない
        }
    },
    FATAL(0, "致命的エラー") {
        @Override
        public boolean isLoggable(LogLevel currentLevelSetting) {
            // 現在の設定レベルの重要度が、このメッセージの重要度以下(数値が小さい)であれば出力
            return currentLevelSetting.getSeverity() <= this.getSeverity() && currentLevelSetting != OFF;
        }
    },
    ERROR(1, "エラー") {
        @Override
        public boolean isLoggable(LogLevel currentLevelSetting) {
            return currentLevelSetting.getSeverity() <= this.getSeverity() && currentLevelSetting != OFF;
        }
    },
    WARN(2, "警告") {
        @Override
        public boolean isLoggable(LogLevel currentLevelSetting) {
            return currentLevelSetting.getSeverity() <= this.getSeverity() && currentLevelSetting != OFF;
        }
    },
    INFO(3, "情報") {
        @Override
        public boolean isLoggable(LogLevel currentLevelSetting) {
            return currentLevelSetting.getSeverity() <= this.getSeverity() && currentLevelSetting != OFF;
        }
    },
    DEBUG(4, "デバッグ") {
        @Override
        public boolean isLoggable(LogLevel currentLevelSetting) {
            return currentLevelSetting.getSeverity() <= this.getSeverity() && currentLevelSetting != OFF;
        }
    },
    TRACE(5, "トレース") { // 最も詳細なログレベル
        @Override
        public boolean isLoggable(LogLevel currentLevelSetting) {
            return currentLevelSetting.getSeverity() <= this.getSeverity() && currentLevelSetting != OFF;
        }
    }; // セミコロン必須

    // --- フィールド ---
    private final int severity;         // 重要度 (数値が小さいほど重要)
    private final String description;   // レベルの説明

    // --- コンストラクタ ---
    private LogLevel(int severity, String description) {
        this.severity = severity;
        this.description = description;
    }

    // --- メソッド ---
    public int getSeverity() {
        return severity;
    }

    public String getDescription() {
        return description;
    }

    // このログメッセージが、現在のロガー設定レベルで出力されるべきかどうかを判断する
    // 各列挙子でオーバーライドすることで、より柔軟な判定ロジックも可能
    public abstract boolean isLoggable(LogLevel currentLevelSetting);

    // 文字列からLogLevelを取得するファクトリメソッド (より安全)
    public static LogLevel fromString(String levelStr, LogLevel defaultLevel) {
        if (levelStr == null) return defaultLevel;
        try {
            return LogLevel.valueOf(levelStr.toUpperCase());
        } catch (IllegalArgumentException e) {
            // 無効な文字列が指定された場合はデフォルト値を返す
            System.err.println("警告: 無効なログレベル文字列 '" + levelStr + "' が指定されました。デフォルト値 " + defaultLevel + " を使用します。");
            return defaultLevel;
        }
    }
}

// 簡単なロガーのシミュレーション
class SimpleLogger {
    private LogLevel currentSetting; // 現在のロガーの出力レベル設定

    public SimpleLogger(LogLevel initialLevel) {
        this.currentSetting = initialLevel;
        System.out.println("ロガーの出力レベルが " + initialLevel.getDescription() + " に設定されました。");
    }

    public void setLevel(LogLevel newLevel) {
        this.currentSetting = newLevel;
        System.out.println("ロガーの出力レベルが " + newLevel.getDescription() + " に変更されました。");
    }

    public void log(LogLevel messageLevel, String message) {
        // メッセージのレベルが現在の設定レベルで出力すべきかを確認
        if (messageLevel.isLoggable(this.currentSetting)) {
            System.out.printf("[%s] %s%n", messageLevel.name(), message);
        }
    }
}

public class LoggingDemo {
    public static void main(String[] args) {
        // アプリケーション起動時のログレベル設定 (例: 環境変数や設定ファイルから読み込む想定)
        String configuredLevelStr = "DEBUG"; // "INFO", "WARN", "ERROR", null なども試しうる
        LogLevel initialLogLevel = LogLevel.fromString(configuredLevelStr, LogLevel.INFO); // 無効な場合はINFO

        SimpleLogger logger = new SimpleLogger(initialLogLevel);

        logger.log(LogLevel.FATAL, "これは致命的なエラーメッセージです。");
        logger.log(LogLevel.ERROR, "これはエラーメッセージです。");
        logger.log(LogLevel.WARN,  "これは警告メッセージです。");
        logger.log(LogLevel.INFO,  "これは情報メッセージです。");
        logger.log(LogLevel.DEBUG, "これはデバッグメッセージです。"); // DEBUGレベル以上なら出力
        logger.log(LogLevel.TRACE, "これはトレースメッセージです。"); // TRACEレベル以上なら出力

        System.out.println("\n--- ログレベルをWARNに変更 ---");
        logger.setLevel(LogLevel.WARN);
        logger.log(LogLevel.FATAL, "致命的エラー (WARN設定時)");
        logger.log(LogLevel.ERROR, "エラー (WARN設定時)");
        logger.log(LogLevel.WARN,  "警告 (WARN設定時)");
        logger.log(LogLevel.INFO,  "情報 (WARN設定時)");   // 出力されない
        logger.log(LogLevel.DEBUG, "デバッグ (WARN設定時)"); // 出力されない

        System.out.println("\n--- ログレベルをOFFに変更 ---");
        logger.setLevel(LogLevel.OFF);
        logger.log(LogLevel.FATAL, "致命的エラー (OFF設定時)"); // 出力されない
        logger.log(LogLevel.ERROR, "エラー (OFF設定時)");     // 出力されない
    }
}
```

#### `LogLevel.java`のポイント:

* 各ログレベル（`FATAL`, `ERROR`, `INFO`など）が、それ自身の重要度（`severity`）と、現在のロガー設定（`currentLevelSetting`）に基づいてログ出力すべきかどうかを判断するロジック（`isLoggable`メソッド）を持っています。
* `isLoggable`メソッドは抽象メソッドとして定義され、各列挙子がその具体的な判定ロジックを実装しています。これにより、ログレベルごとの出力可否のルールを一元管理できます。
* `fromString`ファクトリメソッドは、文字列から安全に`LogLevel`インスタンスを生成する方法を提供し、無効な入力に対するフォールバックも考慮しています。
* このようにenumを使うことで、ログレベルのような設定値を型安全に扱い、関連する振る舞いをカプセル化して、コードの保守性を高めることができます。

### 5.4. 便利な関連クラス：`EnumSet` と `EnumMap`

Javaには、enum専用の効率的な `Set` および `Map` 実装が用意されています。

#### `java.util.EnumSet`

* enum定数のみを格納できる `Set` 実装です。
* 内部的にはビットベクトル（ビットフィールド）を使用して効率的に要素を管理します。
* 通常の `HashSet` などよりも高速かつ省メモリです。
* `EnumSet.of(...)`, `EnumSet.allOf(...)`, `EnumSet.range(...)` などの静的ファクトリメソッドでインスタンスを生成します。

```java
import java.util.EnumSet;
// ... (Month enumの定義は上記参照)

public class EnumSetDemo {
    public static void main(String[] args) {
        // 特定の月だけを含むEnumSet
        EnumSet<Month> springMonths = EnumSet.of(Month.MARCH, Month.APRIL, Month.MAY);
        System.out.println("春の月: " + springMonths); // [MARCH, APRIL, MAY]

        // 全ての月を含むEnumSet
        EnumSet<Month> allMonths = EnumSet.allOf(Month.class);
        System.out.println("全ての月 (最初の数件): " + allMonths.stream().limit(3).toList()); // 例: [JANUARY, FEBRUARY, MARCH]

        // 特定の範囲の月を含むEnumSet
        EnumSet<Month> summerMonths = EnumSet.range(Month.JUNE, Month.AUGUST);
        System.out.println("夏の月: " + summerMonths); // [JUNE, JULY, AUGUST]

        // 補集合
        EnumSet<Month> nonSpringMonths = EnumSet.complementOf(springMonths);
        System.out.println("春以外の月 (最初の数件): " + nonSpringMonths.stream().limit(3).toList());

        if (springMonths.contains(Month.APRIL)) {
            System.out.println("4月は春です。");
        }
    }
}
```

#### `java.util.EnumMap`

* キーとしてenum定数を使用する `Map` 実装です。
* 内部的には配列を使用して効率的にキーと値をマッピングします。
* 通常の `HashMap` などよりも高速かつ省メモリです（キーがenumの場合）。
* コンストラクタでキーとなるenumの `Class` オブジェクトを渡してインスタンスを生成します。

```java
import java.util.EnumMap;
// ... (Month enumの定義は上記参照)

public class EnumMapDemo {
    public static void main(String[] args) {
        // 月ごとのイベントを管理するEnumMap
        EnumMap<Month, String> monthlyEvents = new EnumMap<>(Month.class);

        monthlyEvents.put(Month.JANUARY, "お正月");
        monthlyEvents.put(Month.MAY, "ゴールデンウィーク");
        monthlyEvents.put(Month.DECEMBER, "クリスマス");

        System.out.println("5月のイベント: " + monthlyEvents.get(Month.MAY)); // ゴールデンウィーク

        // 全てのキーと値を表示
        for (Month month : monthlyEvents.keySet()) {
            System.out.println(month.getJapaneseName() + "のイベント: " + monthlyEvents.get(month));
        }

        if (monthlyEvents.containsKey(Month.FEBRUARY)) {
            System.out.println("2月のイベント: " + monthlyEvents.get(Month.FEBRUARY));
        } else {
            System.out.println("2月のイベントは登録されていません。");
        }
    }
}
```

`EnumSet`と`EnumMap`は、enumをキーや要素として扱う場合にパフォーマンスとメモリ効率の面で大きなメリットがあるため、積極的に利用を検討しましょう。

## 6\. まとめ

Javaのenumは、単なる定数の集合体以上のものです。それは、独自のフィールド、メソッド、さらにはインターフェイス実装や列挙子ごとの振る舞いを持つことができる、強力な型表現です。

enum活用のポイント:

* **型安全性の向上**: `int`や`String`による定数よりも安全。
* **可読性の向上**: コードの意図が明確になる。
* **ロジックのカプセル化**: 定数に関連するデータや振る舞いをまとめられる。
* **拡張性**: インターフェイス実装や列挙子固有メソッドにより柔軟な設計が可能。
* **効率的なコレクション**: `EnumSet`, `EnumMap` の活用。

開発現場では、状態管理、カテゴリ分類、設定オプション、戦略の表現など、多岐にわたる場面でenumが活躍します。


----

# 練習課題
## テキスト処理戦略の選択と実行

### 目的:

* **インターフェイス**を実用的な処理の抽象化に活用する設計を理解する。
* 異なる具体的な処理を**インターフェイス**の実装として定義し、それを選択・実行する**ストラテジーパターン**の考え方を、より具体的なテキスト処理の例で実践する。
* Java SwingでGUIコンポーネント（ラジオボタン、テキストエリア等）を用いて処理戦略と対象データ（テキスト）を管理し、その結果を表示するアプリケーションを作成する。
* **enum**を関連する処理戦略の管理に活用する。

### 課題内容:

1.  `TextProcessor` という名前の**インターフェイス**を定義します。このインターフェイスは以下の2つのメソッドを持ちます。
    * `String process(String inputText)`: 引数で受け取った文字列 (`inputText`) を処理し、処理後の文字列を返却します。
    * `String getDescription()`: このテキスト処理戦略の説明（例：「大文字に変換」）を返却します。
2.  以下の3つの具体的なテキスト処理クラスを作成し、それぞれ `TextProcessor` **インターフェイス**を実装します。
    * `UpperCaseProcessor`: `process` メソッドで、入力文字列をすべて大文字に変換して返します。`getDescription` で「大文字変換」のような説明を返します。
    * `ReverseProcessor`: `process` メソッドで、入力文字列を逆順にして返します。`getDescription` で「文字列反転」のような説明を返します。
    * `WordCountProcessor`: `process` メソッドで、入力文字列に含まれる単語数をカウントし、「単語数: X」のような形式の文字列を返します（単語の区切りはスペースとします）。`getDescription` で「単語カウント」のような説明を返します。
3.  `ProcessingStrategy` という名前の**enum**を作成します。これは利用可能なテキスト処理戦略の種類を定義します。各列挙子（例: `TO_UPPERCASE`, `REVERSE_TEXT`, `COUNT_WORDS`）は、対応する `TextProcessor` インターフェイスの実装クラスのインスタンスをフィールドとして保持するように設計します。`toString()` メソッドをオーバーライドして、`getDescription()` の結果を表示するようにすると便利です。
4.  `TextProcessingApp` という名前のクラスを作成し、Java SwingでGUIアプリケーションを構築してください。
    * `JFrame` を作成し、タイトルを「テキスト処理デモ」とします。
    * `JPanel` を作成し、フレームに追加します。
    * パネル内に以下のコンポーネントを配置します。
        * 入力テキスト用の `JTextArea`。
        * 利用可能なテキスト処理戦略を選択するための `JRadioButton` を `ProcessingStrategy` enumの各列挙子に対応して作成します。これらは `ButtonGroup` でグループ化します。各ラジオボタンのテキストは、対応する戦略の `getDescription()` から取得すると良いでしょう。
        * 処理実行用の `JButton`（`"処理実行"`）。
        * 処理結果を表示するための `JTextArea`（編集不可に設定すると良いでしょう）。
        * 現在選択されている戦略の説明を表示するための `JLabel`。
    * `処理実行` ボタンに `ActionListener` を追加します。
    * ボタンが押されたら、
        * 選択されているラジオボタンから、対応する `ProcessingStrategy` enumの列挙子を取得します。
        * 取得した列挙子から、対応する `TextProcessor` インターフェイスの実装クラスのインスタンスを取得します。
        * 入力用 `JTextArea` からテキストを取得します。
        * その `TextProcessor` インスタンスの `process()` メソッドに入力テキストを渡して処理を実行します。
        * 処理結果を結果表示用 `JTextArea` に表示します。
        * 選択された戦略の説明 (`getDescription()`) を `JLabel` に表示します。
    * 各ラジオボタンが選択された際に、対応する戦略の説明を即座に `JLabel` で表示するよう `ActionListener` を追加しても良いでしょう。
5.  `TextProcessingApp` の `main` メソッドからGUIを起動し、テキストを入力し、異なる処理戦略を選択して実行ボタンをクリックすると、入力テキストに応じた処理結果が表示されることを確認してください。

### ポイント:

* `ProcessingStrategy` **enum**が `TextProcessor` のインスタンスを保持することで、enum自身が戦略の選択と提供の役割を担えます。
* GUIは、具体的なテキスト処理ロジックを知らずに `TextProcessor` **インターフェイス**を介して処理を実行できます。これは**疎結合**の良い例です。


### 解答例

<details><summary>クリックで表示する</summary>
<p>

### `TextProcessor.java`

```java
/**
 * テキスト処理の戦略を定義するインターフェイス。
 * このインターフェイスを実装するクラスは、特定のテキスト処理ロジックと
 * その処理内容の説明を提供します。
 */
public interface TextProcessor {
    /**
     * 指定された入力文字列を処理し、処理後の文字列を返却します。
     *
     * @param inputText 処理対象の文字列
     * @return 処理後の文字列
     */
    String process(String inputText);

    /**
     * このテキスト処理戦略の内容を説明する文字列を返却します。
     * GUIでの表示などに利用されます。
     *
     * @return 戦略の説明文字列
     */
    String getDescription();
}
```

### `UpperCaseProcessor.java`

```java
/**
 * {@link TextProcessor} インターフェイスを実装するクラス。
 * 入力文字列をすべて大文字に変換する処理を提供します。
 */
public class UpperCaseProcessor implements TextProcessor {

    /**
     * 入力文字列をすべて大文字に変換します。
     *
     * @param inputText 処理対象の文字列
     * @return 大文字に変換された文字列。入力がnullの場合はnullを返します。
     */
    @Override
    public String process(String inputText) {
        if (inputText == null) {
            return null;
        }
        System.out.println("コンソール: UpperCaseProcessor を適用中...");
        return inputText.toUpperCase();
    }

    /**
     * この処理戦略の説明「大文字変換」を返します。
     *
     * @return "大文字変換"という文字列
     */
    @Override
    public String getDescription() {
        return "大文字変換";
    }
}
```

### `ReverseProcessor.java`

```java
/**
 * {@link TextProcessor} インターフェイスを実装するクラス。
 * 入力文字列を逆順にする処理を提供します。
 */
public class ReverseProcessor implements TextProcessor {

    /**
     * 入力文字列を逆順にします。
     *
     * @param inputText 処理対象の文字列
     * @return 逆順にされた文字列。入力がnullの場合はnullを返します。
     */
    @Override
    public String process(String inputText) {
        if (inputText == null) {
            return null;
        }
        System.out.println("コンソール: ReverseProcessor を適用中...");
        return new StringBuilder(inputText).reverse().toString();
    }

    /**
     * この処理戦略の説明「文字列反転」を返します。
     *
     * @return "文字列反転"という文字列
     */
    @Override
    public String getDescription() {
        return "文字列反転";
    }
}
```

### `WordCountProcessor.java`

```java
/**
 * {@link TextProcessor} インターフェイスを実装するクラス。
 * 入力文字列に含まれる単語数をカウントする処理を提供します。
 * 単語はスペースで区切られているものとみなします。
 */
public class WordCountProcessor implements TextProcessor {

    /**
     * 入力文字列の単語数をカウントし、「単語数: X」という形式の文字列を返します。
     * 文字列が空またはnullの場合、単語数は0として扱います。
     * 連続するスペースは1つの区切りとして扱われます（trim後、split("\\s+")を使用）。
     *
     * @param inputText 処理対象の文字列
     * @return 単語数を示す文字列 (例: "単語数: 5")
     */
    @Override
    public String process(String inputText) {
        System.out.println("コンソール: WordCountProcessor を適用中...");
        if (inputText == null || inputText.trim().isEmpty()) {
            return "単語数: 0";
        }
        // 前後の空白を除去し、1つ以上の空白文字で分割
        String[] words = inputText.trim().split("\\s+");
        return "単語数: " + words.length;
    }

    /**
     * この処理戦略の説明「単語カウント」を返します。
     *
     * @return "単語カウント"という文字列
     */
    @Override
    public String getDescription() {
        return "単語カウント";
    }
}
```

### `ProcessingStrategy.java`

```java
/**
 * 利用可能なテキスト処理戦略の種類を定義するenum。
 * 各列挙子は、対応する {@link TextProcessor} インターフェイスの実装クラスのインスタンスを保持します。
 * これにより、処理戦略の選択とインスタンスの取得を一元管理できます。
 */
public enum ProcessingStrategy {
    /** 大文字に変換する戦略 */
    TO_UPPERCASE(new UpperCaseProcessor()),
    /** 文字列を反転する戦略 */
    REVERSE_TEXT(new ReverseProcessor()),
    /** 単語数をカウントする戦略 */
    COUNT_WORDS(new WordCountProcessor());

    // 各列挙子が保持するTextProcessorインスタンス
    private final TextProcessor processor;

    /**
     * enumのコンストラクタ。
     * private であり、enum定数の宣言時にのみ呼び出されます。
     *
     * @param processor この戦略に対応する {@link TextProcessor} インスタンス
     */
    private ProcessingStrategy(TextProcessor processor) {
        this.processor = processor;
    }

    /**
     * この列挙子に対応するテキスト処理戦略のインスタンスを取得します。
     *
     * @return {@link TextProcessor} インスタンス
     */
    public TextProcessor getProcessor() {
        return processor;
    }

    /**
     * この処理戦略の説明を返します。
     * JRadioButtonのテキストなど、GUIでの表示に利用されることを想定しています。
     *
     * @return 対応する {@link TextProcessor} の {@code getDescription()} の結果
     */
    @Override
    public String toString() {
        return processor.getDescription(); // デフォルトで戦略の説明を返すようにする
    }
}
```

### `TextProcessingApp.java`

```java
import javax.swing.*;
import java.awt.*;

/**
 * テキスト処理戦略を選択し、入力テキストに対して処理を実行するGUIアプリケーション。
 * ユーザーはテキストを入力し、処理方法（大文字化、反転、単語数カウント）を
 * ラジオボタンで選択して実行できます。
 */
public class TextProcessingApp extends JFrame {

    private JTextArea inputTextArea;      // 入力テキスト用エリア
    private JTextArea outputTextArea;     // 出力結果用エリア
    private JLabel strategyDescriptionLabel; // 選択中の戦略の説明を表示するラベル
    private ButtonGroup strategyButtonGroup;  // 戦略選択用ラジオボタンのグループ

    /**
     * {@code TextProcessingApp} のコンストラクタ。
     * GUIの初期化、コンポーネントの配置、イベントリスナーの設定を行います。
     */
    public TextProcessingApp() {
        // 1. フレームの基本設定
        setTitle("テキスト処理デモ");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        // GridLayoutを使用してコンポーネントを縦に配置
        setLayout(new BorderLayout(10, 10)); // 全体をBorderLayoutにし、部品間の余白を設定

        // 2. 入力エリアの設定
        JPanel inputPanel = new JPanel(new BorderLayout(5,5));
        inputPanel.setBorder(BorderFactory.createTitledBorder("入力テキスト"));
        inputTextArea = new JTextArea(5, 30);
        inputTextArea.setLineWrap(true); // 右端で折り返す
        inputTextArea.setWrapStyleWord(true); // 単語単位で折り返す
        JScrollPane inputScrollPane = new JScrollPane(inputTextArea);
        inputPanel.add(inputScrollPane, BorderLayout.CENTER);
        add(inputPanel, BorderLayout.NORTH);

        // 3. 戦略選択エリアの設定
        JPanel strategyPanel = new JPanel();
        strategyPanel.setLayout(new BoxLayout(strategyPanel, BoxLayout.Y_AXIS)); // 縦に並べる
        strategyPanel.setBorder(BorderFactory.createTitledBorder("処理戦略を選択"));
        strategyButtonGroup = new ButtonGroup();

        // ProcessingStrategy enum の各値に対してラジオボタンを作成
        for (ProcessingStrategy strategy : ProcessingStrategy.values()) {
            JRadioButton radioButton = new JRadioButton(strategy.getProcessor().getDescription());
            radioButton.setActionCommand(strategy.name()); // enumの定数名をActionCommandとして設定
            // ラジオボタン選択時に戦略説明ラベルを更新するリスナー
            radioButton.addActionListener(e -> updateStrategyDescriptionLabel());
            strategyButtonGroup.add(radioButton);
            strategyPanel.add(radioButton);
            if (strategy == ProcessingStrategy.values()[0]) { // 最初の戦略をデフォルトで選択
                radioButton.setSelected(true);
            }
        }
        add(strategyPanel, BorderLayout.WEST);

        // 4. 制御エリア (実行ボタンと戦略説明ラベル)
        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 10, 10));
        JButton executeButton = new JButton("処理実行");
        strategyDescriptionLabel = new JLabel("戦略: " + ProcessingStrategy.values()[0].getProcessor().getDescription()); // 初期説明
        controlPanel.add(executeButton);
        controlPanel.add(strategyDescriptionLabel);
        // メインパネルを中央に配置するため、さらにパネルでラップ
        JPanel centerPanel = new JPanel(new BorderLayout());
        centerPanel.add(controlPanel, BorderLayout.NORTH); // 制御パネルを中央パネルの上部に
        add(centerPanel, BorderLayout.CENTER);


        // 5. 出力エリアの設定
        JPanel outputPanel = new JPanel(new BorderLayout(5,5));
        outputPanel.setBorder(BorderFactory.createTitledBorder("処理結果"));
        outputTextArea = new JTextArea(5, 30);
        outputTextArea.setLineWrap(true);
        outputTextArea.setWrapStyleWord(true);
        outputTextArea.setEditable(false); // 結果表示用なので編集不可
        JScrollPane outputScrollPane = new JScrollPane(outputTextArea);
        outputPanel.add(outputScrollPane, BorderLayout.CENTER);
        centerPanel.add(outputPanel, BorderLayout.CENTER); // 出力パネルを中央パネルの中央に

        // 6. 実行ボタンにActionListenerを追加
        executeButton.addActionListener(e -> {
            String selectedActionCommand = strategyButtonGroup.getSelection().getActionCommand();
            ProcessingStrategy selectedStrategyEnum = ProcessingStrategy.valueOf(selectedActionCommand); // ActionCommandからenum定数を取得

            if (selectedStrategyEnum != null) {
                TextProcessor processor = selectedStrategyEnum.getProcessor(); // enumから対応するProcessorインスタンスを取得
                String inputText = inputTextArea.getText();
                String resultText = processor.process(inputText); // 処理を実行
                outputTextArea.setText(resultText); // 結果を表示
                updateStrategyDescriptionLabel(); // 戦略説明を更新 (念のため)
            } else {
                outputTextArea.setText("エラー: 処理戦略が選択されていません。");
            }
        });

        // 7. フレームのパッキングと表示
        pack(); // コンポーネントの推奨サイズに合わせてフレームサイズを調整
        setLocationRelativeTo(null); // ウィンドウを画面中央に表示
    }

    /**
     * 選択されているラジオボタンに応じて、戦略説明ラベルのテキストを更新します。
     */
    private void updateStrategyDescriptionLabel() {
        ButtonModel selectedModel = strategyButtonGroup.getSelection();
        if (selectedModel != null) {
            String actionCommand = selectedModel.getActionCommand();
            ProcessingStrategy selectedStrategyEnum = ProcessingStrategy.valueOf(actionCommand);
            strategyDescriptionLabel.setText("戦略: " + selectedStrategyEnum.getProcessor().getDescription());
        } else {
            strategyDescriptionLabel.setText("戦略: (未選択)");
        }
    }

    /**
     * アプリケーションのメインエントリポイント。
     * GUIをイベントディスパッチスレッドで安全に起動します。
     *
     * @param args コマンドライン引数 (未使用)
     */
    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new TextProcessingApp().setVisible(true));
    }
}
```
