---
title: ファイル処理
---

>オブジェクト指向プログラミングおよび演習1 第09回  
>  
>Javaでのファイル入出力について学ぼう

## はじめに

ファイル処理は、多くのJavaアプリケーションで不可欠な要素です。設定ファイルの読み込み、データの永続化、外部システムとの連携など、さまざまな場面でファイル操作が必要になります。この資料では、Javaにおけるテキストファイルおよびバイナリファイルの基本的な扱い方から、より実践的なテクニックまでを解説します。

ファイル操作をおこなう際には、予期せぬエラー（例：ファイルが見つからない、アクセス権限がない）が発生する可能性もあるため、適切な例外処理が重要です。また、大量のデータを効率的に扱うために、ストリームの概念を理解することも不可欠です。

以下の点を習得することを目指します。

1.  ストリームの概念と種類
2.  テキストファイルの読み書き（文字コードの扱いを含む）
3.  バイナリファイルの読み書き
4.  `try-with-resources`構文による安全なリソース管理
5.  `java.nio.file`パッケージ（NIO.2）を用いたモダンなファイル操作
6.  各種データ形式ファイル（CSV, Properties, JSON, XML）の基本的な扱い

## ストリームとは

ストリームとは、データの流れを抽象化したものです。プログラムがデータを読み書きする際、データソース（ファイル、ネットワーク接続、メモリー上の配列など）やデータシンク（同様にファイルなど）との間で、データが連続的に流れるイメージです。

JavaのI/O (Input/Output)システムは、このストリームをベースに設計されています。ストリームを利用すると、データの種類やサイズにかかわらず、統一的な方法で入出力処理をおこなえます。

主なストリームの種類には以下のようなものがあります。

* バイトストリーム: データをバイト単位で扱います。画像ファイルや音声ファイルなど、あらゆる種類のバイナリデータを処理するのに適します。代表的なクラスとして `InputStream` と `OutputStream` があります。
* キャラクタストリーム: データを文字単位で扱います。テキストファイルの処理に適し、内部的に文字エンコーディング（例: UTF-8, Shift_JIS）を扱います。代表的なクラスとして `Reader` と `Writer` があります。

Javaでは、ファイルだけでなく、標準入出力（キーボード入力 `System.in`、コンソール出力 `System.out`）もストリームとして扱われます。

## Javaにおけるファイル入出力の基礎

Javaでファイル入出力処理をおこなう際、とくに大きなファイルを扱う場合は注意が必要です。ファイルの内容全体を一度にメモリーへ読み込もうとすると、ファイルのサイズによってはメモリー不足 (`OutOfMemoryError`) を引き起こし、プログラムが強制終了する可能性もあります。

これを避けるため、Javaのファイル処理では、データを少しずつ（たとえば、1行ずつや一定のバッファーサイズで）読み書きするストリーム処理が基本になります。

### `try-with-resources`構文によるリソース管理

ファイルストリームなどのリソースは、使用後に必ず閉じる（クローズする）必要があります。リソースを閉じ忘れると、ファイルがロックされたままになったり、システムリソースを浪費したりする原因になります。

Java SE 7以降では、`try-with-resources`構文が導入され、リソース管理が大幅に簡潔かつ安全になりました。この構文を使用すると、`try`ブロックの最後で自動的にリソースの`close()`メソッドが呼び出されるため、`finally`ブロックで明示的に`close()`処理を記述する必要はありません。

`try-with-resources`構文で扱えるリソースは、`java.lang.AutoCloseable`インターフェイスまたはそのサブインターフェイスである`java.io.Closeable`を実装しているクラスのオブジェクトです。

```java
// try-with-resources構文の基本的な形式
// ResourceType1 と ResourceType2 は AutoCloseable を実装したクラス
try (ResourceType1 resource1 = new ResourceType1();
     ResourceType2 resource2 = new ResourceType2()) {
    // resource1 や resource2 を使った処理
} catch (IOException e) {
    // 例外処理
    e.printStackTrace();
}
// tryブロックを抜けると、resource2.close()、resource1.close() の順で自動的に呼び出される
```

## テキストファイルの読み込み

テキストファイルは、人間が読める文字データで構成されたファイルです。プログラム設定、ログファイル、CSVデータなど、さまざまな用途で利用されます。

### `BufferedReader` を使った行単位の読み込み

`java.io.BufferedReader`クラスを使用すると、テキストファイルを効率的に1行ずつ読み込めます。文字ベースのストリームである`Reader`をラップし、バッファリング機能を提供します。

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class TextFileReaderExample {
    public static void main(String[] args) {
        String filePath = "example.txt"; // 読み込むファイルパス

        // java.io.FileReaderとBufferedReaderを使用する従来の方法 (try-with-resources使用)
        try (FileReader fr = new FileReader(filePath); // ファイルリーダーを作成
             BufferedReader br = new BufferedReader(fr)) { // バッファードリーダーでラップ
            String line;
            System.out.println("--- FileReaderとBufferedReaderによる読み込み ---");
            while ((line = br.readLine()) != null) { // 1行ずつ読み込み、ファイルの終端(null)まで繰り返す
                System.out.println(line); // 読み込んだ行をコンソールに出力
            }
        } catch (IOException e) {
            System.err.println("ファイル読み込み中にエラーが発生しました (FileReader): " + e.getMessage());
        }

        System.out.println(); // 区切り線

        // java.nio.file.FilesとBufferedReaderを使用する方法 (推奨)
        Path path = Paths.get(filePath);
        try (BufferedReader br = Files.newBufferedReader(path, StandardCharsets.UTF_8)) { // Files.newBufferedReaderで文字コードを指定して作成
            String line;
            System.out.println("--- Files.newBufferedReaderによる読み込み (UTF-8) ---");
            while ((line = br.readLine()) != null) { // 1行ずつ読み込み
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("ファイル読み込み中にエラーが発生しました (Files.newBufferedReader): " + e.getMessage());
        }
    }
}
```

### `java.util.Scanner` を使った読み込み

`java.util.Scanner`クラスは、テキスト入力を解析するための便利なクラスです。ファイルだけでなく、標準入力や文字列からもデータを読み取れます。

```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Scanner;

public class ScannerExample {
    public static void main(String[] args) {
        String filePath = "example.txt";
        Path path = Paths.get(filePath);

        // Scanner を try-with-resources で使用
        try (Scanner scanner = new Scanner(Files.newBufferedReader(path, StandardCharsets.UTF_8))) {
            System.out.println("--- Scannerによる行単位の読み込み ---");
            while (scanner.hasNextLine()) { // 次の行が存在するか確認
                String line = scanner.nextLine(); // 次の行を読み込む
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("ファイル読み込み中にエラーが発生しました (Scanner): " + e.getMessage());
        }

        System.out.println();

        // Scanner を使って特定のデリミターで区切られた値を読み込む例
        String data = "リンゴ,150,赤";
        try (Scanner dataScanner = new Scanner(data)) {
            dataScanner.useDelimiter(","); // デリミターをコンマに設定
            System.out.println("--- Scannerによるデリミター指定読み込み ---");
            while (dataScanner.hasNext()) { // 次のトークンが存在するか確認
                System.out.println(dataScanner.next()); // 次のトークンを読み込む
            }
        }
    }
}
```

### `java.nio.file.Files` クラスを使った簡潔な読み込み

`java.nio.file.Files`クラスには、テキストファイルの読み込みをより簡潔におこなうための便利なメソッドが用意されています。

```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.stream.Stream;

public class FilesReadExample {
    public static void main(String[] args) {
        String filePath = "example.txt";
        Path path = Paths.get(filePath);

        // ファイルの全行をリストとして読み込む (小さなファイル向き)
        try {
            System.out.println("--- Files.readAllLinesによる読み込み ---");
            List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8); // 全行をList<String>として読み込む
            for (String line : lines) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("ファイル読み込み中にエラーが発生しました (Files.readAllLines): " + e.getMessage());
        }

        System.out.println();

        // Java 11以降: ファイルの内容を単一の文字列として読み込む (小さなファイル向き)
        try {
            System.out.println("--- Files.readStringによる読み込み (Java 11+) ---");
            String content = Files.readString(path, StandardCharsets.UTF_8); // ファイル全体を単一のStringとして読み込む
            System.out.println(content);
        } catch (IOException e) {
            System.err.println("ファイル読み込み中にエラーが発生しました (Files.readString): " + e.getMessage());
        } catch (UnsupportedOperationException e) {
            System.err.println("Files.readString は Java 11 以降でサポートされています。");
        }


        System.out.println();

        // Stream API を使ってファイルを行ストリームとして処理 (大きなファイルにも対応可能)
        System.out.println("--- Files.linesによるStream処理 ---");
        try (Stream<String> linesStream = Files.lines(path, StandardCharsets.UTF_8)) { // ファイルを行ごとのStream<String>として開く
            linesStream.forEach(System.out::println); // 各行に対して処理を実行 (ここではコンソール出力)
        } catch (IOException e) {
            System.err.println("ファイル読み込み中にエラーが発生しました (Files.lines): " + e.getMessage());
        }
    }
}
```

### 文字コードの指定

テキストファイルを扱う際には、文字コード（エンコーディング）の指定が重要です。文字コードが異なると、文字化けが発生する可能性もあります。

* `java.nio.charset.Charset`クラス: 文字コードセットを表します。`Charset.forName("UTF-8")`のように特定の文字コードセットを取得したり、`Charset.defaultCharset()`でシステムのデフォルト文字コードセットを取得したりできます。
* `java.nio.charset.StandardCharsets`クラス: `UTF-8`, `ISO_8859_1`など、標準的な文字コードセットが定数として定義されます。一般的には`StandardCharsets.UTF_8`の使用が推奨されます。

多くのファイル読み込みメソッドでは、引数で`Charset`オブジェクトを指定できます。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CharacterSetExample {
    public static void main(String[] args) {
        String filePath = "example_sjis.txt"; // Shift_JISでエンコードされたファイルを想定
        Path path = Paths.get(filePath);

        // Shift_JIS (MS932) を指定して読み込む例
        // MS932はWindows環境でのShift_JISの実装で、より多くの文字を扱えます。
        Charset shiftJisCharset = Charset.forName("MS932");
        try (BufferedReader br = Files.newBufferedReader(path, shiftJisCharset)) {
            System.out.println("--- Shift_JIS (MS932) でファイルを読み込み ---");
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("ファイル読み込みエラー (Shift_JIS): " + e.getMessage());
        }

        // UTF-8で読み込む例（ファイルがUTF-8でエンコードされている場合）
        String utf8FilePath = "example_utf8.txt";
        Path utf8Path = Paths.get(utf8FilePath);
        try (BufferedReader br = Files.newBufferedReader(utf8Path, StandardCharsets.UTF_8)) {
            System.out.println("\n--- UTF-8 でファイルを読み込み ---");
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("ファイル読み込みエラー (UTF-8): " + e.getMessage());
        }
    }
}
```

## テキストファイルの書き込み

プログラムの実行結果やデータをテキストファイルとして保存する処理も一般的です。

### `BufferedWriter` を使った書き込み

`java.io.BufferedWriter`クラスは、テキストデータを効率的にファイルへ書き込むために使用されます。文字ベースのストリームである`Writer`をラップし、バッファリング機能を提供します。

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.List;

public class TextFileWriterExample {
    public static void main(String[] args) {
        String filePath = "output.txt";

        List<String> linesToWrite = Arrays.asList(
            "これは1行目のテキストです。",
            "This is the second line.",
            "三行目。",
            "改行を含む\nテキストも書き込めます。"
        );

        // java.io.FileWriterとBufferedWriterを使用する従来の方法 (try-with-resources使用)
        try (FileWriter fw = new FileWriter(filePath); // ファイルライターを作成（デフォルトの文字コード、上書きモード）
             BufferedWriter bw = new BufferedWriter(fw)) { // バッファードライターでラップ
            System.out.println("--- FileWriterとBufferedWriterによる書き込み ---");
            for (String line : linesToWrite) {
                bw.write(line); // 文字列を書き込む
                bw.newLine();   // プラットフォームに応じた改行文字を書き込む
            }
            System.out.println(filePath + " に書き込みました。");
        } catch (IOException e) {
            System.err.println("ファイル書き込み中にエラーが発生しました (FileWriter): " + e.getMessage());
        }

        System.out.println();

        // java.nio.file.FilesとBufferedWriterを使用する方法 (推奨)
        Path path = Paths.get("output_nio.txt");
        try (BufferedWriter bw = Files.newBufferedWriter(path,
                                                        StandardCharsets.UTF_8, // 文字コードをUTF-8に指定
                                                        StandardOpenOption.CREATE, // ファイルが存在しない場合は新規作成
                                                        StandardOpenOption.WRITE,  // 書き込みモードで開く
                                                        StandardOpenOption.TRUNCATE_EXISTING // ファイルが存在する場合は既存の内容を削除
                                                        // StandardOpenOption.APPEND // 追記モードの場合はこちらを使用
                                                        )) {
            System.out.println("--- Files.newBufferedWriterによる書き込み (UTF-8) ---");
            for (String line : linesToWrite) {
                bw.write(line);
                bw.newLine();
            }
            System.out.println(path.getFileName() + " に書き込みました。");
        } catch (IOException e) {
            System.err.println("ファイル書き込み中にエラーが発生しました (Files.newBufferedWriter): " + e.getMessage());
        }
    }
}
```

### `java.nio.file.Files` クラスを使った簡潔な書き込み

`Files`クラスには、テキストファイルの書き込みを簡潔におこなうためのメソッドも用意されています。

```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.List;

public class FilesWriteExample {
    public static void main(String[] args) {
        // Files.write() を使って複数行を書き込む
        Path pathLines = Paths.get("output_lines.txt");
        List<String> lines = Arrays.asList("最初の行", "The second line", "３番目の行");
        try {
            System.out.println("--- Files.write (List) による書き込み ---");
            Files.write(pathLines, lines, StandardCharsets.UTF_8, // 文字列のリストを書き込む。各要素が1行となる。
                        StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            System.out.println(pathLines.getFileName() + " に書き込みました。");
        } catch (IOException e) {
            System.err.println("ファイル書き込みエラー (Files.write List): " + e.getMessage());
        }

        System.out.println();

        // Java 11以降: Files.writeString() を使って単一の文字列を書き込む
        Path pathString = Paths.get("output_string.txt");
        String content = "これはファイルに書き込む文字列です。\n複数行も\n含めることができます。";
        try {
            System.out.println("--- Files.writeString (Java 11+) による書き込み ---");
            Files.writeString(pathString, content, StandardCharsets.UTF_8, // 単一の文字列をファイルに書き込む
                              StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            System.out.println(pathString.getFileName() + " に書き込みました。");
        } catch (IOException e) {
            System.err.println("ファイル書き込みエラー (Files.writeString): " + e.getMessage());
        } catch (UnsupportedOperationException e) {
            System.err.println("Files.writeString は Java 11 以降でサポートされています。");
        }
    }
}
```

### 書き込みオプション (`StandardOpenOption`)

`Files.newBufferedWriter()`や`Files.write()`メソッドなどでは、`java.nio.file.StandardOpenOption`列挙型を使いファイルのオープン方法を指定できます。主なオプションは以下の通りです。

* `CREATE`: ファイルが存在しない場合に新規作成します。
* `CREATE_NEW`: 新規ファイルを作成します。ファイルがすでに存在する場合は例外 (`FileAlreadyExistsException`) がスローされます。
* `WRITE`: 書き込みアクセス用にファイルを開きます。
* `APPEND`: ファイルの末尾に追記します。`WRITE`と組み合わせて使用します。
* `TRUNCATE_EXISTING`: ファイルが存在し、書き込み用に開かれる場合、ファイルの内容を0バイトに切り詰めます。`WRITE`と組み合わせて使用します。
* `READ`: 読み取りアクセス用にファイルを開きます。

これらのオプションは可変長引数として複数指定できます。

## バイナリファイルの読み書き

バイナリファイルは、テキスト以外のデータ（画像、音声、実行ファイル、シリアライズされたオブジェクトなど）を格納するファイルです。バイトストリーム (`InputStream`, `OutputStream`) を用いて処理します。

### `FileInputStream` と `FileOutputStream`

これらは、もっとも基本的なバイト単位のファイル入出力ストリームです。

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;

public class BinaryFileStreamExample {
    public static void main(String[] args) {
        String inputFilePath = "input.bin"; // 読み込むバイナリファイル
        String outputFilePath = "output.bin"; // 書き込むバイナリファイル

        // サンプルバイナリファイルの作成 (事前に用意しておくか、ここで生成)
        try (FileOutputStream fos = new FileOutputStream(inputFilePath)) {
            fos.write(new byte[]{0x01, 0x02, 0x03, 0x04, 0x05});
        } catch (IOException e) {
            System.err.println("サンプルバイナリファイルの作成に失敗: " + e.getMessage());
            return;
        }

        // FileInputStream を使ったバイナリファイルの読み込み
        try (FileInputStream fis = new FileInputStream(inputFilePath)) {
            System.out.println("--- FileInputStream によるバイナリ読み込み ---");
            byte[] buffer = new byte[1024]; // 読み込み用バッファー
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) { // バッファーに読み込み、読み込んだバイト数を返す。終端は-1。
                // 読み込んだデータ (buffer) を処理する (ここでは最初の数バイトを表示)
                System.out.print("読み込んだバイト数: " + bytesRead + ", データ(先頭部分): ");
                for (int i = 0; i < bytesRead && i < 10; i++) {
                    System.out.printf("%02X ", buffer[i]); // 16進数で表示
                }
                System.out.println();
            }
        } catch (IOException e) {
            System.err.println("バイナリファイル読み込みエラー (FileInputStream): " + e.getMessage());
        }

        System.out.println();

        // FileOutputStream を使ったバイナリファイルの書き込み
        byte[] dataToWrite = {0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
        try (FileOutputStream fos = new FileOutputStream(outputFilePath)) { // デフォルトでは上書きモード
            System.out.println("--- FileOutputStream によるバイナリ書き込み ---");
            fos.write(dataToWrite); // バイト配列をファイルに書き込む
            System.out.println(outputFilePath + " にバイナリデータを書き込みました: " + Arrays.toString(dataToWrite));
        } catch (IOException e) {
            System.err.println("バイナリファイル書き込みエラー (FileOutputStream): " + e.getMessage());
        }

        // 追記モードでの書き込み例
        byte[] dataToAppend = {0x1A, 0x1B, 0x1C};
        try (FileOutputStream fosAppend = new FileOutputStream(outputFilePath, true)) { // 第2引数をtrueにすると追記モード
            System.out.println("\n--- FileOutputStream によるバイナリ追記 ---");
            fosAppend.write(dataToAppend);
            System.out.println(outputFilePath + " にバイナリデータを追記しました: " + Arrays.toString(dataToAppend));
        } catch (IOException e) {
            System.err.println("バイナリファイル追記エラー (FileOutputStream): " + e.getMessage());
        }
    }
}
```

### `BufferedInputStream` と `BufferedOutputStream`

これらのクラスは、内部バッファーを持つことで、`FileInputStream` や `FileOutputStream` のパフォーマンスを向上させます。ディスクアクセスの回数を減らせるため、とくに大量のデータを扱う場合に有効です。

```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class BufferedBinaryStreamExample {
    public static void main(String[] args) {
        String sourceFilePath = "source_large.dat"; // 大きなファイルを想定
        String destinationFilePath = "destination_large.dat";

        // ダミーの大きなファイルの作成
        try (FileOutputStream fos = new FileOutputStream(sourceFilePath)) {
            byte[] dummyData = new byte[1024 * 1024]; // 1MBのダミーデータ
            for (int i = 0; i < 5; i++) { // 5MBのファイルを作成
                fos.write(dummyData);
            }
            System.out.println(sourceFilePath + " (5MB) を作成しました。");
        } catch (IOException e) {
            System.err.println("ダミーファイルの作成に失敗: " + e.getMessage());
            return;
        }

        // BufferedInputStream と BufferedOutputStream を使ったファイルのコピー
        long startTime = System.currentTimeMillis();
        try (FileInputStream fis = new FileInputStream(sourceFilePath);
             BufferedInputStream bis = new BufferedInputStream(fis); // FileInputStreamをBufferedInputStreamでラップ
             FileOutputStream fos = new FileOutputStream(destinationFilePath);
             BufferedOutputStream bos = new BufferedOutputStream(fos)) { // FileOutputStreamをBufferedOutputStreamでラップ

            System.out.println("--- BufferedStreamによるファイルコピー開始 ---");
            byte[] buffer = new byte[8192]; // 8KBのバッファー
            int bytesRead;
            while ((bytesRead = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, bytesRead); // 読み込んだ分だけ書き込む
            }
            System.out.println(destinationFilePath + " にファイルをコピーしました。");
        } catch (IOException e) {
            System.err.println("ファイルコピー中にエラーが発生しました: " + e.getMessage());
        }
        long endTime = System.currentTimeMillis();
        System.out.println("コピー処理時間: " + (endTime - startTime) + " ms");
    }
}
```

### `DataInputStream` と `DataOutputStream`

Javaのプリミティブデータ型（`int`, `double`, `boolean`など）や文字列を、プラットフォームに依存しないバイナリ形式で読み書きするために使用します。

```java
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;


public class DataStreamExample {
    public static void main(String[] args) {
        String dataFilePath = "primitive_data.dat";

        // DataOutputStream を使ってプリミティブ型データを書き込む
        try (FileOutputStream fos = new FileOutputStream(dataFilePath);
             DataOutputStream dos = new DataOutputStream(new BufferedOutputStream(fos))) { // パフォーマンス向上のためBufferedOutputStreamを挟む
            System.out.println("--- DataOutputStreamによるプリミティブデータの書き込み ---");
            dos.writeInt(12345);         // int値を書き込む
            dos.writeDouble(3.14159);    // double値を書き込む
            dos.writeBoolean(true);      // boolean値を書き込む
            dos.writeUTF("こんにちは、世界！"); // UTF-8エンコードされた文字列を書き込む
            System.out.println(dataFilePath + " にプリミティブデータを書き込みました。");
        } catch (IOException e) {
            System.err.println("データ書き込みエラー: " + e.getMessage());
        }

        System.out.println();

        // DataInputStream を使ってプリミティブ型データを読み込む
        try (FileInputStream fis = new FileInputStream(dataFilePath);
             DataInputStream dis = new DataInputStream(new BufferedInputStream(fis))) { // パフォーマンス向上のためBufferedInputStreamを挟む
            System.out.println("--- DataInputStreamによるプリミティブデータの読み込み ---");
            int intValue = dis.readInt();            // int値を読み込む
            double doubleValue = dis.readDouble();   // double値を読み込む
            boolean booleanValue = dis.readBoolean(); // boolean値を読み込む
            String stringValue = dis.readUTF();      // UTF-8エンコードされた文字列を読み込む

            System.out.println("読み込んだ int 値: " + intValue);
            System.out.println("読み込んだ double 値: " + doubleValue);
            System.out.println("読み込んだ boolean 値: " + booleanValue);
            System.out.println("読み込んだ String 値: " + stringValue);
        } catch (IOException e) {
            System.err.println("データ読み込みエラー: " + e.getMessage());
        }
    }
}
```
読み込む際は、書き込んだ型と順番を正確に合わせる必要があります。

### オブジェクトの直列化（シリアライズ）

Javaオブジェクトの状態をバイトストリームに変換してファイルに保存したり、ネットワーク経由で送信したりする仕組みを直列化（シリアライズ）と呼びます。逆に、バイトストリームからオブジェクトを復元することを非直列化（デシリアライズ）と呼びます。
この機能を利用するには、`java.io.ObjectOutputStream` と `java.io.ObjectInputStream` を使用します。

#### `Serializable` インターフェイス
直列化したいクラスは `java.io.Serializable` インターフェイスを実装する必要があります。このインターフェイスはメソッドを持たないマーカーインターフェイスで、クラスが直列化可能であることをJVMに伝える役割を果たします。実装しないオブジェクトを直列化しようとすると `java.io.NotSerializableException` がスローされます。

#### `serialVersionUID`
`Serializable` を実装したクラスでは、`serialVersionUID` という `private static final long` 型のフィールドを宣言することを強く推奨します。これはクラスのバージョンを一意に識別するためのIDです。
`serialVersionUID` を明示的に宣言しない場合、Javaコンパイラーがクラスの構造に基づいて自動的に値を生成します。しかし、クラスのフィールドやメソッドをわずかに変更しただけでも、この自動生成される値が変わる可能性もあり、その結果古いバージョンで直列化されたオブジェクトを新しいバージョンのクラスで非直列化しようとすると `java.io.InvalidClassException` が発生することがあります。
`serialVersionUID` を明示的に宣言することで、クラスの互換性をより細かく制御できます。JDK付属の `serialver` ツールで初期値を生成することもできます。

#### `transient` キーワード
フィールドに `transient` キーワードを付与すると、そのフィールドは直列化の対象外になります。パスワードのような機密情報や、一時的な計算結果、あるいは直列化できないオブジェクト（例：スレッドオブジェクト、ファイルハンドル）への参照など、保存したくないまたは保存できないフィールドに対して使用します。非直列化時には、`transient` フィールドは型に応じたデフォルト値（数値型なら0、booleanならfalse、参照型ならnull）で初期化されます。

#### 基本的な直列化・非直列化のサンプル

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Date;

// Serializableインターフェースを実装したクラス
class UserProfile implements Serializable {
    // クラスのバージョン管理に使用。明示的な宣言を推奨。
    private static final long serialVersionUID = 1234567890L;

    private String username;
    private int age;
    private transient String password; // 直列化の対象外とするフィールド
    private Date registrationDate;
    private transient Thread internalThread; // 直列化できないオブジェクトの例

    public UserProfile(String username, int age, String password) {
        this.username = username;
        this.age = age;
        this.password = password; // コンストラクターでは設定
        this.registrationDate = new Date();
        // this.internalThread = new Thread(); // 通常、スレッドは直列化しません
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPassword() {
        return password;
    }


    @Override
    public String toString() {
        return "UserProfile [username=" + username + ", age=" + age +
               ", password=" + (password == null ? "N/A (transient)" : password) + // デシリアライズ後はnullになる
               ", registrationDate=" + registrationDate + "]";
    }
}

public class ObjectSerializationDetailsExample {
    public static void main(String[] args) {
        String objectFilePath = "user_profile.ser";

        UserProfile user = new UserProfile("TestUser123", 30, "s3cr3tP@sswOrd");

        // オブジェクトをファイルに書き込む (シリアライズ)
        System.out.println("--- オブジェクトのシリアライズ ---");
        System.out.println("シリアライズ前のオブジェクト: " + user);
        try (FileOutputStream fos = new FileOutputStream(objectFilePath);
             ObjectOutputStream oos = new ObjectOutputStream(fos)) {
            oos.writeObject(user);
            System.out.println(objectFilePath + " にオブジェクトをシリアライズしました。");
        } catch (IOException e) {
            System.err.println("オブジェクトシリアライズエラー: " + e.getMessage());
            e.printStackTrace();
        }

        System.out.println();
        user.setPassword(null); // 元のオブジェクトのパスワードをクリアして確認しやすくする
        System.out.println("ファイル書き込み後、メモリー上のオブジェクトの状態: " + user);


        // ファイルからオブジェクトを読み込む (デシリアライズ)
        try (FileInputStream fis = new FileInputStream(objectFilePath);
             ObjectInputStream ois = new ObjectInputStream(fis)) {
            System.out.println("\n--- オブジェクトのデシリアライズ ---");
            UserProfile loadedUser = (UserProfile) ois.readObject();
            System.out.println("ファイルからデシリアライズしたオブジェクト: " + loadedUser);
            // transient で宣言された password フィールドはデシリアライズされないため、null (またはデフォルト値) になっている。
            // 必要であれば、デシリアライズ後に再設定するロジックを組む。
            // loadedUser.setPassword("someDefaultOrRestoredPassword");
            // System.out.println("パスワード再設定後のオブジェクト: " + loadedUser);

        } catch (IOException | ClassNotFoundException e) {
            System.err.println("オブジェクトデシリアライズエラー: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

#### カスタム直列化 (`writeObject` / `readObject`)
デフォルトの直列化メカニズムでは不十分な場合や、`transient` フィールドの値を特定のロジックで保存・復元したい場合、クラスに `private void writeObject(ObjectOutputStream out)` と `private void readObject(ObjectInputStream in)` メソッドを定義すると、直列化・非直列化のプロセスをカスタマイズできます。
これらのメソッド内では、`out.defaultWriteObject()` や `in.defaultReadObject()` を呼び出すことで、まずデフォルトの直列化処理（非`transient`かつ非`static`なフィールドの保存・復元）をおこない、その後に追加の処理を記述するのが一般的です。

```java
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Base64; // Base64エンコード用 (Java 8+)
import java.io.FileOutputStream; // mainメソッド用
import java.io.FileInputStream; // mainメソッド用


class SecureUserProfile implements Serializable {
    private static final long serialVersionUID = 2L;

    private String username;
    private transient String sensitiveData; // 直接はシリアライズしないが、カスタム処理で扱う

    public SecureUserProfile(String username, String sensitiveData) {
        this.username = username;
        this.sensitiveData = sensitiveData;
    }

    // カスタム直列化メソッド
    private void writeObject(ObjectOutputStream oos) throws IOException {
        oos.defaultWriteObject(); // デフォルトのフィールド (username) を直列化
        // sensitiveData を暗号化 (ここでは簡易的にBase64エンコード) して書き込む
        if (sensitiveData != null) {
            String encodedData = Base64.getEncoder().encodeToString(sensitiveData.getBytes());
            oos.writeObject(encodedData);
        } else {
            oos.writeObject(null);
        }
        System.out.println("SecureUserProfile.writeObject: sensitiveDataをエンコードして書き込みました。");
    }

    // カスタム非直列化メソッド
    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ois.defaultReadObject(); // デフォルトのフィールド (username) を非直列化
        // 書き込まれたエンコード済みのデータを読み込み、デコードして sensitiveData に復元
        Object encodedDataObj = ois.readObject();
        if (encodedDataObj != null) {
            String encodedData = (String) encodedDataObj;
            this.sensitiveData = new String(Base64.getDecoder().decode(encodedData));
        } else {
            this.sensitiveData = null;
        }
        System.out.println("SecureUserProfile.readObject: sensitiveDataをデコードして復元しました。");
    }

    @Override
    public String toString() {
        return "SecureUserProfile [username=" + username + ", sensitiveData=" + sensitiveData + "]";
    }


    // 使用例
    public static void main(String[] args) {
        String filePath = "secure_user.ser";
        SecureUserProfile user = new SecureUserProfile("SecureUser", "This is very secret!");

        System.out.println("シリアライズ前: " + user);
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
            oos.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("\nデシリアライズ後:");
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
            SecureUserProfile loadedUser = (SecureUserProfile) ois.readObject();
            System.out.println(loadedUser);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

#### 直列化の注意点
* セキュリティー: 信頼できないソースから受信したデータをデシリアライズする場合、悪意のあるバイトストリームによって予期せぬオブジェクトが生成され、脆弱性を突かれる可能性があります（いわゆる「デシリアライゼーション攻撃」または「ガジェット攻撃」）。入力の検証や、`java.io.ObjectInputFilter` (Java 9+) の使用を検討してください。
* パフォーマンス: 大量のオブジェクトや深いネスト構造を持つオブジェクトの直列化・非直列化は、時間とメモリーを消費する可能性があります。
* クラスの互換性: クラス定義が変更された場合（フィールドの追加・削除・型変更など）、非直列化時に問題が発生することもあります。`serialVersionUID` の適切な管理や、カスタム直列化メソッド (`writeObject`/`readObject`) による互換性維持のロジックが必要になることがあります。
* 外部リソースの扱い: ファイルハンドルやネットワークソケット、スレッドなど、実行環境に依存するリソースや直列化できないリソースをフィールドとして持つ場合、それらは `transient` にし、必要であればカスタム直列化メソッドで適切に再初期化する処理を実装する必要があります。

#### `Externalizable` インターフェイス
`Serializable` インターフェイスとは異なり、`java.io.Externalizable` インターフェイスを実装すると、クラス自身が直列化・非直列化の全プロセスを制御します。`writeExternal(ObjectOutput out)` と `readExternal(ObjectInput in)` の2つのメソッドを実装する必要があります。
この方法では開発者が明示的にどのデータをどのように書き込み、読み込むかをすべて記述するため、より細かい制御が可能になり、パフォーマンス面で有利になる場合があります。しかし、実装の責任は大きくなります。また、`Externalizable` を実装したクラスでは、非直列化時に引数なしのpublicなコンストラクターが呼び出されてから `readExternal` が実行されます。

## ファイル操作とファイルシステム

`java.nio.file`パッケージ (NIO.2 - New I/O 2) は、Java SE 7で導入された、より高機能で柔軟なファイルシステム操作APIです。従来の`java.io.File`クラスに代わるものとして推奨されます。

* `Path`インターフェイス: ファイルやディレクトリーのパスを表現します。`Paths.get("path/to/file")`のようにインスタンスを取得します。
* `Files`クラス: ファイルやディレクトリーの作成、削除、コピー、移動、属性取得など、スタティックメソッドを提供します。

```java
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;


public class FileSystemOperationsExample {
    public static void main(String[] args) {
        // Pathオブジェクトの作成
        Path dirPath = Paths.get("my_directory");
        Path filePath = dirPath.resolve("testfile.txt"); // ディレクトリー内のファイルパスを作成
        Path copyFilePath = dirPath.resolve("testfile_copy.txt");
        Path newDirPath = Paths.get("my_new_directory");

        try {
            // ディレクトリーの作成
            if (Files.notExists(dirPath)) {
                Files.createDirectory(dirPath); // 単一のディレクトリーを作成
                System.out.println("ディレクトリーを作成しました: " + dirPath);
            } else {
                System.out.println("ディレクトリーは既に存在します: " + dirPath);
            }

            // ファイルの作成と書き込み (簡単なテキスト)
            if (Files.notExists(filePath)) {
                Files.writeString(filePath, "これはテストファイルです。\nNIO.2を使って作成されました。\n");
                System.out.println("ファイルを作成し書き込みました: " + filePath);
            } else {
                Files.writeString(filePath, "これは追記のテストです。\n", StandardOpenOption.APPEND);
                System.out.println("ファイルに追記しました: " + filePath);
            }


            // ファイルの存在確認
            System.out.println("ファイルが存在するか (" + filePath.getFileName() + "): " + Files.exists(filePath));
            System.out.println("読み取り可能か (" + filePath.getFileName() + "): " + Files.isReadable(filePath));
            System.out.println("書き込み可能か (" + filePath.getFileName() + "): " + Files.isWritable(filePath));
            System.out.println("ファイルサイズ (" + filePath.getFileName() + "): " + Files.size(filePath) + " バイト");

            // ファイルのコピー
            Files.copy(filePath, copyFilePath, StandardCopyOption.REPLACE_EXISTING); // 既存ファイルを置き換えてコピー
            System.out.println(filePath.getFileName() + " を " + copyFilePath.getFileName() + " にコピーしました。");

            // ディレクトリー内のファイル一覧表示
            System.out.println("\nディレクトリー '" + dirPath.getFileName() + "' の内容:");
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(dirPath)) {
                for (Path entry : stream) {
                    System.out.println((Files.isDirectory(entry) ? "[D] " : "[F] ") + entry.getFileName());
                }
            }

            // ファイルの移動 (リネームとして利用)
            Path renamedFilePath = dirPath.resolve("renamed_testfile.txt");
            Files.move(copyFilePath, renamedFilePath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println(copyFilePath.getFileName() + " を " + renamedFilePath.getFileName() + " にリネーム(移動)しました。");

            // ファイルの削除
            Files.deleteIfExists(renamedFilePath); // ファイルが存在すれば削除
            System.out.println(renamedFilePath.getFileName() + " を削除しました。");
            Files.deleteIfExists(filePath);
            System.out.println(filePath.getFileName() + " を削除しました。");


            // ディレクトリーの削除 (空である必要がある)
            if (Files.exists(dirPath) && Files.isDirectory(dirPath) && isDirEmpty(dirPath)) {
                Files.delete(dirPath);
                System.out.println("ディレクトリーを削除しました: " + dirPath);
            } else if (Files.exists(dirPath)) {
                System.out.println("ディレクトリー " + dirPath + " は空ではないため削除できませんでした。");
            }


        } catch (FileAlreadyExistsException e) {
            System.err.println("ファイルまたはディレクトリーが既に存在します: " + e.getFile());
        } catch (IOException e) {
            System.err.println("ファイル操作中にエラーが発生しました: " + e.getMessage());
            e.printStackTrace();
        }
    }

    // ディレクトリーが空かどうかを確認するヘルパーメソッド
    private static boolean isDirEmpty(final Path directory) throws IOException {
        try(DirectoryStream<Path> dirStream = Files.newDirectoryStream(directory)) {
            return !dirStream.iterator().hasNext();
        }
    }
}
```

## ファイルアクセス方式

### シーケンシャルアクセス (Sequential Access)

ファイルの先頭から順にデータを読み書きする方式です。テキストファイルや多くのバイナリファイルの基本的なアクセス方法です。

* メリット:
    * 実装が比較的容易。
    * ストリーミング処理に適し、大きなファイルでもメモリー効率が良い。
    * ディスクI/Oが連続的になるため、一般的に高速。
* デメリット:
    * ファイル内の特定の位置に直接アクセスできません（特定の位置まで読み飛ばす必要があります）。

### ランダムアクセス (Random Access)

ファイルの任意の位置から直接データを読み書きする方式です。`java.io.RandomAccessFile`クラスを使用します。データベースファイルや、固定長レコードを持つファイルなど、特定の部分を頻繁に更新する場合に適します。

```java
import java.io.IOException;
import java.io.RandomAccessFile;

public class RandomAccessExample {
    public static void main(String[] args) {
        String filePath = "random_access_file.dat";
        String content = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        try (RandomAccessFile raf = new RandomAccessFile(filePath, "rw")) { // "r": 読み取り専用, "rw": 読み書き両用
            // ファイルに初期データを書き込む
            raf.writeBytes(content);
            System.out.println("初期データを書き込みました: " + content);

            // ファイルポインターを特定の位置に移動 (seek)
            raf.seek(5); // 6番目のバイト (0-indexed) へ移動
            System.out.println("ファイルポインターを 5 に移動しました。現在の文字: " + (char)raf.readByte());
            raf.seek(5); // ポインターを戻す

            // 特定の位置にデータを上書き
            raf.writeBytes("#####"); // 5バイト分上書き
            System.out.println("位置 5 から '#####' を上書きしました。");

            // ファイルの先頭に戻って内容を確認
            raf.seek(0);
            byte[] buffer = new byte[(int) raf.length()];
            raf.readFully(buffer); // ファイル全体を読み込む
            System.out.println("変更後のファイル内容: " + new String(buffer));

            // ファイルの末尾に追記
            raf.seek(raf.length()); // ファイルポインターを末尾に移動
            raf.writeBytes("\nThis is appended text.");
            System.out.println("末尾にテキストを追記しました。");

            raf.seek(0);
            buffer = new byte[(int) raf.length()];
            raf.readFully(buffer);
            System.out.println("追記後のファイル内容: " + new String(buffer));

        } catch (IOException e) {
            System.err.println("ランダムアクセスファイル処理中にエラー: " + e.getMessage());
        }
    }
}
```

* メリット:
    * ファイル内の任意の位置へ高速にアクセスできる。
* デメリット:
    * 可変長のレコードを扱うのが複雑になる。
    * ファイル構造を正確に把握する必要がある。
    * シーケンシャルアクセスに比べて一般的に低速になる場合があります（とくに細切れのアクセスが多い場合）。

一般的に、テキストファイルやメディアファイルなど、全体を順に処理することが多い場合はシーケンシャルアクセスが適します。特定のレコードを頻繁に読み書きするようなデータベース的な用途ではランダムアクセスが有効です。

## さまざまなデータ形式ファイル

プログラムで扱うデータは、単純なテキストだけでなく、構造化された形式で保存されることがあります。

### CSV (Comma-Separated Values)

コンマ（または他のデリミター）で値を区切ったテキストファイル形式です。表形式のデータを簡潔に表現できます。

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CsvBasicExample {
    public static void main(String[] args) {
        String csvDataLine = "山田太郎,30,東京都";
        String[] values = csvDataLine.split(","); // コンマで分割
        System.out.println("--- String.split()によるCSV解析 ---");
        System.out.println("氏名: " + values[0]);
        System.out.println("年齢: " + values[1]);
        System.out.println("住所: " + values[2]);

        // ファイルからのCSV読み込み（簡易版）
        String csvFilePath = "sample.csv"; // "名前,年齢,都市\n佐藤一郎,25,大阪府\n鈴木花子,35,福岡県" のような内容を想定
        System.out.println("\n--- ファイルからの簡易CSV読み込み ---");
        try (BufferedReader br = new BufferedReader(new FileReader(csvFilePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] row = line.split(",");
                System.out.println(Arrays.toString(row));
            }
        } catch (IOException e) {
            System.err.println("CSVファイル読み込みエラー: " + e.getMessage());
        }

        // 注意: String.split() は単純なCSVにしか対応できません。
        // 値の中にコンマが含まれる場合（例: "商品A, ""説明文, 詳細情報""",1000）や
        // 改行が含まれる場合など、複雑なケースでは正しく処理できません。
        // そのような場合は、Apache Commons CSV や opencsv などの専用ライブラリーの使用を検討してください。
    }
}
```
CSVは単純ですが、値にデリミター文字や改行が含まれる場合、ダブルクォーテーションでの囲みなど、方言が多く存在します（RFC 4180が一応の標準です）。複雑なCSVを扱う場合は、Apache Commons CSVやopencsvといった専用ライブラリーの利用が推奨されます。

### Javaプロパティファイル (`.properties`)

キーと値のペアを格納するテキストファイル形式です。主にアプリケーションの設定情報などに利用されます。`java.util.Properties`クラスを使い簡単に読み書きできます。

* 各行は `キー=値`、`キー:値`、または `キー 値` の形式。
* `#` または `!`で始まる行はコメント。
* 文字コードはデフォルトでISO 8859-1ですが、Java 9以降はUTF-8もサポートします。`load(Reader)`や`store(Writer, String)`で文字コードを指定できます。

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.util.Properties;

public class PropertiesFileExample {
    public static void main(String[] args) {
        String propsFilePath = "config.properties";
        Properties props = new Properties();

        // プロパティの設定とファイルへの書き込み
        props.setProperty("app.name", "My Application");
        props.setProperty("app.version", "1.0.2");
        props.setProperty("user.language", "japanese"); // 日本語もUTF-8で保存可能

        // Java 9 以降推奨: Writer を使ってUTF-8で保存
        try (Writer writer = new FileWriter(propsFilePath, StandardCharsets.UTF_8)) {
            props.store(writer, "Application Configuration"); // 第2引数はコメント
            System.out.println(propsFilePath + " にプロパティをUTF-8で書き込みました。");
        } catch (IOException e) {
            System.err.println("プロパティファイル書き込みエラー: " + e.getMessage());
        }

        System.out.println();

        // プロパティファイルの読み込み
        Properties loadedProps = new Properties();
        // Java 9 以降推奨: Reader を使ってUTF-8で読み込み
        try (Reader reader = new FileReader(propsFilePath, StandardCharsets.UTF_8)) {
            loadedProps.load(reader);
            System.out.println("--- プロパティファイルの読み込み (UTF-8) ---");
            System.out.println("app.name: " + loadedProps.getProperty("app.name"));
            System.out.println("app.version: " + loadedProps.getProperty("app.version"));
            System.out.println("user.language: " + loadedProps.getProperty("user.language"));
            System.out.println("db.host (存在しないキー): " + loadedProps.getProperty("db.host", "localhost")); // デフォルト値指定
        } catch (IOException e) {
            System.err.println("プロパティファイル読み込みエラー: " + e.getMessage());
        }

        // 従来の方法 (InputStream/OutputStream, ISO 8859-1がデフォルト)
        // 日本語などは \uXXXX 形式でエスケープされる
        String legacyPropsFilePath = "config_legacy.properties";
        Properties legacyProps = new Properties();
        legacyProps.setProperty("legacy.key", "Legacy Value");
        legacyProps.setProperty("nihongo.key", "日本語の値"); // これは \uXXXX にエスケープされる

        try (OutputStream os = new FileOutputStream(legacyPropsFilePath)) {
            legacyProps.store(os, "Legacy Properties File");
             System.out.println("\n" + legacyPropsFilePath + " にプロパティをISO 8859-1(デフォルト)で書き込みました。");
        } catch (IOException e) {
            System.err.println("レガシープロパティファイル書き込みエラー: " + e.getMessage());
        }

        Properties loadedLegacyProps = new Properties();
        try (InputStream is = new FileInputStream(legacyPropsFilePath)) {
            loadedLegacyProps.load(is);
            System.out.println("\n--- レガシープロパティファイルの読み込み (ISO 8859-1 デフォルト) ---");
            System.out.println("legacy.key: " + loadedLegacyProps.getProperty("legacy.key"));
            System.out.println("nihongo.key: " + loadedLegacyProps.getProperty("nihongo.key")); // 正しくデコードされる
        } catch (IOException e) {
            System.err.println("レガシープロパティファイル読み込みエラー: " + e.getMessage());
        }
    }
}
```

### XML (eXtensible Markup Language)

タグを使いデータに意味付けをおこない、階層構造を表現できるマークアップ言語です。設定ファイル、データ交換フォーマットなど、広く利用されています。
Javaでは、JAXP (Java API for XML Processing) を用いてDOM (Document Object Model), SAX (Simple API for XML), StAX (Streaming API for XML) といった方法でXMLを解析したり生成したりできます。また、JAXB (Java Architecture for XML Binding) を使うとJavaオブジェクトとXMLをマッピングできます。

```xml
<users>
    <user id="1">
        <name>山田太郎</name>
        <email>yamada@example.com</email>
    </user>
    <user id="2">
        <name>佐藤花子</name>
        <email>sato@example.com</email>
    </user>
</users>
```

XMLの処理は比較的複雑になるため、ここではサンプルコードは割愛します。

### JSON (JavaScript Object Notation)

軽量なデータ交換フォーマットで、人間にも読み書きしやすく、機械にも解析しやすい形式です。Web APIなどで広く利用されています。
JavaでJSONを扱うには、Gson（Google製）, Jackson, org.jsonなどの外部ライブラリーを利用するのが一般的です。

```json
// sample.json の例
{
  "users": [
    {
      "id": 1,
      "name": "山田太郎",
      "email": "yamada@example.com"
    },
    {
      "id": 2,
      "name": "佐藤花子",
      "email": "sato@example.com"
    }
  ]
}
```
以下はGsonライブラリーを使用した簡単な例です。（Gsonライブラリーがクラスパスに通っている必要があります）

```java
// pom.xml に Gson の依存関係を追加する必要があります (Mavenプロジェクトの場合)
// <dependency>
//     <groupId>com.google.code.gson</groupId>
//     <artifactId>gson</artifactId>
//     <version>2.10.1</version> // </dependency>

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

// JSONマッピング用のクラス (JAXBの例と似たようなPOJO)
class UsersContainer { // JSONのルートオブジェクトが "users" というキーを持つオブジェクトであるため、コンテナーを用意
    List<UserDto> users; // フィールド名をJSONのキーに合わせるか、@SerializedNameアノテーションで指定
    public UsersContainer() { users = new ArrayList<>(); }
}

class UserDto {
    int id;
    String name;
    String email;

    public UserDto(int id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
     @Override
    public String toString() {
        return "UserDto{id=" + id + ", name='" + name + "', email='" + email + "'}";
    }
}

public class GsonExample {
    public static void main(String[] args) {
        String jsonFilePath = "users.json";
        Gson gson = new GsonBuilder().setPrettyPrinting().create(); // PrettyPrintingで整形されたJSONを出力

        // JavaオブジェクトからJSONへの変換 (シリアライズ)
        UsersContainer usersToSerialize = new UsersContainer();
        usersToSerialize.users.add(new UserDto(1, "山田太郎", "yamada@example.com"));
        usersToSerialize.users.add(new UserDto(2, "佐藤花子", "sato@example.com"));

        try (FileWriter writer = new FileWriter(jsonFilePath)) {
            gson.toJson(usersToSerialize, writer); // オブジェクトをJSONに変換してファイルに書き出す
            System.out.println(jsonFilePath + " にJSONをシリアライズしました。");
        } catch (IOException e) {
            System.err.println("JSONシリアライズエラー: " + e.getMessage());
        }

        // JSON文字列として取得する例
        // String jsonString = gson.toJson(usersToSerialize);
        // System.out.println("JSON文字列:\n" + jsonString);

        System.out.println();

        // JSONからJavaオブジェクトへの変換 (デシリアライズ)
        try (FileReader reader = new FileReader(jsonFilePath)) {
            UsersContainer deserializedUsers = gson.fromJson(reader, UsersContainer.class); // JSONを読み込みオブジェクトにマッピング
            System.out.println("--- JSONからデシリアライズしたオブジェクト ---");
            if (deserializedUsers != null && deserializedUsers.users != null) {
                 for (UserDto user : deserializedUsers.users) {
                    System.out.println(user);
                }
            }
        } catch (IOException e) {
            System.err.println("JSONデシリアライズエラー: " + e.getMessage());
        }
    }
}
```

## IDEにおける相対パスの基準点

IDE（統合開発環境）でJavaプログラムを実行する際、ファイルパスを相対パスで指定した場合の基準点（カレントディレクトリー）は、通常、プロジェクトのルートディレクトリーになります。

たとえば、以下のようなプロジェクト構造で、

```
MyProject/
├── .idea/ (IntelliJ IDEAの場合)
├── out/
├── src/
│   └── com/
│       └── example/
│           └── Main.java
├── my_project.iml (IntelliJ IDEAの場合)
└── data.txt  <-- これを参照する場合
```

`Main.java` 内で `Path path = Paths.get("data.txt");` のように指定すると、`MyProject/data.txt` を指します。

これはIDEの設定や実行構成によって変わる可能性もあるため、`Paths.get("").toAbsolutePath().toString()` を実行して現在のカレントディレクトリーを確認すると確実です。

```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class RelativePathExample {
    public static void main(String[] args) {
        // カレントディレクトリー（実行時の基準ディレクトリー）の表示
        Path currentRelativePath = Paths.get("");
        System.out.println("カレントディレクトリーの絶対パス: " + currentRelativePath.toAbsolutePath());

        // プロジェクトルート直下に置いたファイルへの相対パス指定
        Path filePath = Paths.get("sample_for_ide.txt"); // プロジェクトルートにこのファイルを作成しておく
        System.out.println("参照するファイルの絶対パス: " + filePath.toAbsolutePath());

        // (ファイル操作の例は省略)
        // try (BufferedReader reader = Files.newBufferedReader(filePath)) {
        //     System.out.println(filePath + " の内容: " + reader.readLine());
        // } catch (IOException e) {
        //     System.err.println("ファイル読み込みエラー: " + e.getMessage());
        // }
    }
}
```

## まとめ

Javaにおけるファイル処理は多岐にわたりますが、基本的な考え方はストリームです。適切なストリームクラスを選択し、`try-with-resources`構文でリソースを確実に管理することが重要です。また、テキストファイルを扱う際は文字コードに注意し、`java.nio.file`パッケージ (NIO.2) を活用することで、よりモダンで堅牢なファイル操作が可能になります。

* 基本的なファイルI/Oでは、`Files`クラスのユーティリティーメソッドが便利です。
* 複雑なデータ構造やパフォーマンスが求められる場合は、適切なストリーム（`Buffered...`, `Data...`, `Object...`など）を組み合わせます。
* 外部データ形式（CSV, JSON, XML）を扱う場合は、専用のライブラリーの利用を検討します。
* オブジェクトの直列化を利用する際は、`Serializable`インターフェイス、`serialVersionUID`、`transient`キーワードの役割を理解し、セキュリティーや互換性にも配慮します。
* 例外処理は、ファイル操作において不可欠です。具体的なエラーに対応した処理を記述します。

この資料で解説した内容を基礎として、さまざまなファイル処理に応用できるよう、実際にコードを書いて試してください。