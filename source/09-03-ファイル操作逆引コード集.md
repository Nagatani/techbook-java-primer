---
title: ファイル処理逆引きサンプルコード集
---
> オブジェクト指向プログラミングおよび演習1 第09回

## はじめに
この資料は、Javaの標準APIのみを使用したファイル処理の逆引きサンプルコード集です。

各セクションで具体的なユースケースに基づいたコード例と解説を提供します。

ここで紹介するサンプルコードは、基本的な操作を理解することを目的としており、必要に応じてエラーハンドリングやリソース管理を強化してください。

---

## 1. 基本的なファイル・ディレクトリ操作
ファイルやディレクトリの作成、削除、情報取得、移動など、日常的な操作のサンプルです。

### 1.1 ファイルやディレクトリの存在を確認する
ファイルやディレクトリが指定されたパスに存在するかどうかを確認します。

#### `java.io.File` を使用する場合
```java
import java.io.File;

public class CheckExistenceFileIO {
    public static void main(String[] args) {
        File file = new File("example.txt");
        File dir = new File("example_dir");

        // ファイルの存在チェック
        // file.exists() は、パスがファイルまたはディレクトリとして存在する場合に true を返します。
        System.out.println("'" + file.getName() + "' exists: " + file.exists());

        // ディレクトリの存在チェック
        System.out.println("'" + dir.getName() + "' exists: " + dir.exists());
    }
}
```

#### `java.nio.file.Files` を使用する場合 (推奨)
```java
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CheckExistenceNIO {
    public static void main(String[] args) {
        Path filePath = Paths.get("nio_example.txt");
        Path dirPath = Paths.get("nio_example_dir");

        // ファイルの存在チェック
        // Files.exists(path) は、パスが存在する場合に true を返します。
        System.out.println("'" + filePath.getFileName() + "' exists: " + Files.exists(filePath));
        // Files.notExists(path) は、パスが存在しない場合に true を返します。
        System.out.println("'" + filePath.getFileName() + "' not exists: " + Files.notExists(filePath));


        // ディレクトリの存在チェック
        System.out.println("'" + dirPath.getFileName() + "' exists: " + Files.exists(dirPath));
    }
}
```

### 1.2 新しいファイルやディレクトリを作成する
空のファイルや新しいディレクトリをファイルシステム上に作成します。

#### `java.io.File` を使用する場合
```java
import java.io.File;
import java.io.IOException;

public class CreateFileDirFileIO {
    public static void main(String[] args) {
        File newFile = new File("new_file_io.txt");
        File newDir = new File("new_dir_io");
        File nestedDir = new File("parent_dir_io/child_dir_io");

        // ファイルの作成
        try {
            // createNewFile() は、ファイルが正常に作成された場合に true を返します。
            // 既に存在する場合は false を返します。
            if (newFile.createNewFile()) {
                System.out.println("ファイルを作成しました: " + newFile.getName());
            } else {
                System.out.println(newFile.getName() + " は既に存在するか、作成に失敗しました。");
            }
        } catch (IOException e) {
            System.err.println(newFile.getName() + " の作成中にエラー: " + e.getMessage());
        }

        // ディレクトリの作成
        // mkdir() は、ディレクトリが正常に作成された場合に true を返します。
        // 親ディレクトリが存在しない場合や、既に存在する場合は false を返します。
        if (newDir.mkdir()) {
            System.out.println("ディレクトリを作成しました: " + newDir.getName());
        } else {
            System.out.println(newDir.getName() + " は既に存在するか、作成に失敗しました。");
        }

        // 複数の階層のディレクトリを作成
        // mkdirs() は、必要な親ディレクトリも含めて作成します。
        if (nestedDir.mkdirs()) {
            System.out.println("ディレクトリ(階層込み)を作成しました: " + nestedDir.getPath());
        } else {
            System.out.println(nestedDir.getPath() + " は既に存在するか、作成に失敗しました。");
        }

        // クリーンアップ (任意)
        newFile.delete();
        newDir.delete();
        nestedDir.delete(); // child_dir_io のみ削除
        new File("parent_dir_io").delete(); // parent_dir_io を削除
    }
}
```

#### `java.nio.file.Files` を使用する場合 (推奨)
```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class CreateFileDirNIO {
    public static void main(String[] args) {
        Path newFilePath = Paths.get("new_file_nio.txt");
        Path newDirPath = Paths.get("new_dir_nio");
        Path nestedDirPath = Paths.get("parent_dir_nio/child_dir_nio");

        // ファイルの作成
        try {
            // Files.createFile(path) は、ファイルを作成します。
            // 既に存在する場合は FileAlreadyExistsException がスローされます。
            if (Files.notExists(newFilePath)) {
                Files.createFile(newFilePath);
                System.out.println("ファイルを作成しました: " + newFilePath.getFileName());
            }
        } catch (IOException e) {
            System.err.println(newFilePath.getFileName() + " の作成中にエラー: " + e.getMessage());
        }

        // ディレクトリの作成
        try {
            // Files.createDirectory(path) は、ディレクトリを作成します。
            // 既に存在する場合は FileAlreadyExistsException がスローされます。親ディレクトリが存在しない場合もエラー。
            if (Files.notExists(newDirPath)) {
                Files.createDirectory(newDirPath);
                System.out.println("ディレクトリを作成しました: " + newDirPath.getFileName());
            }
        } catch (IOException e) {
            System.err.println(newDirPath.getFileName() + " の作成中にエラー: " + e.getMessage());
        }

        // 複数の階層のディレクトリを作成
        try {
            // Files.createDirectories(path) は、必要な親ディレクトリも含めて作成します。
            // 既に存在してもエラーにはなりません。
            Files.createDirectories(nestedDirPath);
            System.out.println("ディレクトリ(階層込み)を作成しました: " + nestedDirPath);
        } catch (IOException e) {
            System.err.println(nestedDirPath + " の作成中にエラー: " + e.getMessage());
        }

        // クリーンアップ (任意)
        try {
            Files.deleteIfExists(newFilePath);
            Files.deleteIfExists(newDirPath);
            Files.deleteIfExists(nestedDirPath); // child_dir_nio を削除
            Files.deleteIfExists(Paths.get("parent_dir_nio")); // parent_dir_nio を削除
        } catch (IOException e) {
            System.err.println("クリーンアップ中にエラー: " + e.getMessage());
        }
    }
}
```

### 1.3 ファイルやディレクトリを削除する
指定されたファイルやディレクトリをファイルシステムから削除します。

#### `java.io.File` を使用する場合
```java
import java.io.File;
import java.io.IOException;

public class DeleteFileDirFileIO {
    public static void main(String[] args) {
        // 削除テスト用のファイルとディレクトリを作成
        File fileToDel = new File("file_to_delete_io.txt");
        File dirToDel = new File("dir_to_delete_io");
        try {
            fileToDel.createNewFile();
            dirToDel.mkdir();
            System.out.println("削除用ファイル・ディレクトリを作成しました。");
        } catch (IOException e) {
            System.err.println("削除用ファイル・ディレクトリの準備に失敗: " + e.getMessage());
            return;
        }

        // ファイルの削除
        // delete() は、ファイルまたは空のディレクトリが正常に削除された場合に true を返します。
        if (fileToDel.delete()) {
            System.out.println(fileToDel.getName() + " を削除しました。");
        } else {
            System.out.println(fileToDel.getName() + " の削除に失敗しました。");
        }

        // ディレクトリの削除 (空である必要がある)
        if (dirToDel.delete()) {
            System.out.println(dirToDel.getName() + " を削除しました。");
        } else {
            System.out.println(dirToDel.getName() + " の削除に失敗しました (空でない可能性があります)。");
        }
    }
}
```

#### `java.nio.file.Files` を使用する場合 (推奨)
```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class DeleteFileDirNIO {
    public static void main(String[] args) {
        // 削除テスト用のファイルとディレクトリを作成
        Path fileToDelPath = Paths.get("file_to_delete_nio.txt");
        Path dirToDelPath = Paths.get("dir_to_delete_nio");
        try {
            if (Files.notExists(fileToDelPath)) Files.createFile(fileToDelPath);
            if (Files.notExists(dirToDelPath)) Files.createDirectory(dirToDelPath);
            System.out.println("削除用ファイル・ディレクトリを作成しました。");
        } catch (IOException e) {
            System.err.println("削除用ファイル・ディレクトリの準備に失敗: " + e.getMessage());
            return;
        }

        // ファイルの削除
        try {
            // Files.delete(path) は、ファイルまたは空のディレクトリを削除します。
            // 存在しない場合は NoSuchFileException がスローされます。
            Files.delete(fileToDelPath);
            System.out.println(fileToDelPath.getFileName() + " を削除しました。");
        } catch (IOException e) {
            System.err.println(fileToDelPath.getFileName() + " の削除中にエラー: " + e.getMessage());
        }

        // ディレクトリの削除 (空である必要がある)
        try {
            Files.delete(dirToDelPath);
            System.out.println(dirToDelPath.getFileName() + " を削除しました。");
        } catch (IOException e) {
            System.err.println(dirToDelPath.getFileName() + " の削除中にエラー (空でない可能性があります): " + e.getMessage());
        }

        // 存在する場合のみ削除 (エラーをスローしない)
        Path anotherFile = Paths.get("another_file.txt");
        try {
            // Files.deleteIfExists(path) は、存在すれば削除し true を、存在しなければ何もしないで false を返します。
            boolean deleted = Files.deleteIfExists(anotherFile);
            if (deleted) {
                System.out.println(anotherFile.getFileName() + " を削除しました。");
            } else {
                System.out.println(anotherFile.getFileName() + " は存在しないため削除されませんでした。");
            }
        } catch (IOException e) {
            // ディレクトリが空でないなどの理由で削除に失敗した場合にスローされることがあります。
            System.err.println(anotherFile.getFileName() + " の deleteIfExists 処理中にエラー: " + e.getMessage());
        }
    }
}
```

### 1.4 ファイルやディレクトリの情報を取得する
ファイルのサイズ、種類（ファイルかディレクトリか）、作成日時、最終更新日時などの属性情報を取得します。

#### `java.io.File` による基本的な情報取得
```java
import java.io.File;
import java.util.Date;

public class FileInfoFileIO {
    public static void main(String[] args) {
        File file = new File("example_info.txt"); // 事前にファイルを作成しておく
        try {
            if (!file.exists()) file.createNewFile();
        } catch (Exception e) { /* ignore */ }


        if (file.exists()) {
            System.out.println("--- Information for: " + file.getName() + " ---");
            // ファイルかどうか
            System.out.println("Is file: " + file.isFile());
            // ディレクトリかどうか
            System.out.println("Is directory: " + file.isDirectory());
            // ファイルサイズ (バイト単位)
            System.out.println("Size: " + file.length() + " bytes");
            // 最終更新日時 (エポックミリ秒)
            long lastModifiedMillis = file.lastModified();
            System.out.println("Last modified (epoch ms): " + lastModifiedMillis);
            System.out.println("Last modified (Date): " + new Date(lastModifiedMillis));
            // 読み取り可能か
            System.out.println("Can read: " + file.canRead());
            // 書き込み可能か
            System.out.println("Can write: " + file.canWrite());
            // 実行可能か
            System.out.println("Can execute: " + file.canExecute());
            // 隠しファイルか
            System.out.println("Is hidden: " + file.isHidden());
            // 絶対パス
            System.out.println("Absolute path: " + file.getAbsolutePath());
        } else {
            System.out.println(file.getName() + " does not exist.");
        }
        // クリーンアップ
        file.delete();
    }
}
```

#### `java.nio.file.Files` による基本的な情報取得 (推奨)
```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.FileTime;
import java.time.LocalDateTime;
import java.time.ZoneId;

public class FileInfoNIO {
    public static void main(String[] args) {
        Path filePath = Paths.get("example_info_nio.txt"); // 事前にファイルを作成しておく
        try {
            if (Files.notExists(filePath)) Files.createFile(filePath);
        } catch (Exception e) { /* ignore */ }

        if (Files.exists(filePath)) {
            System.out.println("--- Information for: " + filePath.getFileName() + " ---");
            try {
                // 通常のファイルかどうか
                System.out.println("Is regular file: " + Files.isRegularFile(filePath));
                // ディレクトリかどうか
                System.out.println("Is directory: " + Files.isDirectory(filePath));
                // シンボリックリンクかどうか
                System.out.println("Is symbolic link: " + Files.isSymbolicLink(filePath));
                // ファイルサイズ (バイト単位)
                System.out.println("Size: " + Files.size(filePath) + " bytes");
                // 最終更新日時
                FileTime lastModifiedTime = Files.getLastModifiedTime(filePath);
                LocalDateTime localLastModified = LocalDateTime.ofInstant(lastModifiedTime.toInstant(), ZoneId.systemDefault());
                System.out.println("Last modified: " + localLastModified);
                // 所有者 (環境によって取得できない場合あり)
                // System.out.println("Owner: " + Files.getOwner(filePath).getName());
                // 読み取り可能か
                System.out.println("Is readable: " + Files.isReadable(filePath));
                // 書き込み可能か
                System.out.println("Is writable: " + Files.isWritable(filePath));
                // 実行可能か
                System.out.println("Is executable: " + Files.isExecutable(filePath));
                // 隠しファイルか
                System.out.println("Is hidden: " + Files.isHidden(filePath));

            } catch (IOException e) {
                System.err.println("属性の取得中にエラー: " + e.getMessage());
            }
        } else {
            System.out.println(filePath.getFileName() + " does not exist.");
        }
         // クリーンアップ
        try { Files.deleteIfExists(filePath); } catch (IOException e) { /* ignore */ }
    }
}
```

#### `Files.readAttributes` と `BasicFileAttributes` を使用した詳細な属性取得
ファイルのサイズ、作成日時、最終更新日時、アクセス日時などの基本的な属性情報を一括で取得します。

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.attribute.BasicFileAttributes;
import java.nio.file.attribute.FileTime;
import java.time.LocalDateTime;
import java.time.ZoneId;

public class FileAttributeReader {

    public static void main(String[] args) {
        Path filePath = Paths.get("attribute_sample.txt");

        // テスト用ファイルを作成
        try {
            if (Files.notExists(filePath)) {
                Files.writeString(filePath, "Sample content for attribute testing.");
            }
            System.out.println(filePath.getFileName() + " の準備ができました。");
        } catch (IOException e) {
            System.err.println(filePath.getFileName() + " の準備に失敗: " + e.getMessage());
            return;
        }

        try {
            // BasicFileAttributes.class を指定して、基本的なファイル属性を読み込みます。
            // このメソッドは、シンボリックリンクを追解決します。追解決しない場合は LinkOption.NOFOLLOW_LINKS を指定します。
            BasicFileAttributes attrs = Files.readAttributes(filePath, BasicFileAttributes.class);

            System.out.println("\n--- File Attributes for: " + filePath.getFileName() + " ---");
            System.out.println("サイズ: " + attrs.size() + " bytes");
            System.out.println("ディレクトリか?: " + attrs.isDirectory());
            System.out.println("通常のファイルか?: " + attrs.isRegularFile());
            System.out.println("シンボリックリンクか?: " + attrs.isSymbolicLink());
            System.out.println("その他か?: " + attrs.isOther()); // ディレクトリ、通常ファイル、シンボリックリンク以外

            // FileTime を LocalDateTime に変換して表示
            FileTime creationTime = attrs.creationTime();
            LocalDateTime localCreationTime = LocalDateTime.ofInstant(creationTime.toInstant(), ZoneId.systemDefault());
            System.out.println("作成日時: " + localCreationTime + " (Raw: " + creationTime + ")");

            FileTime lastAccessTime = attrs.lastAccessTime();
            LocalDateTime localLastAccessTime = LocalDateTime.ofInstant(lastAccessTime.toInstant(), ZoneId.systemDefault());
            System.out.println("最終アクセス日時: " + localLastAccessTime + " (Raw: " + lastAccessTime + ")");

            FileTime lastModifiedTime = attrs.lastModifiedTime();
            LocalDateTime localLastModifiedTime = LocalDateTime.ofInstant(lastModifiedTime.toInstant(), ZoneId.systemDefault());
            System.out.println("最終更新日時: " + localLastModifiedTime + " (Raw: " + lastModifiedTime + ")");

            // ファイルキー (ファイルシステム内でファイルを一意に識別するためのオブジェクト、null の場合あり)
            System.out.println("ファイルキー: " + attrs.fileKey());

        } catch (IOException e) {
            System.err.println(filePath.getFileName() + " の属性取得中にエラー: " + e.getMessage());
        }

        // テスト用ファイルを削除
        try {
            Files.deleteIfExists(filePath);
        } catch (IOException e) {
            System.err.println(filePath.getFileName() + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

### 1.5 ファイルやディレクトリをコピー・移動・リネームする

既存のファイルやディレクトリを別の場所にコピーしたり、移動（リネームを含む）したりします。

#### `java.io.File` を使用したリネーム・移動

`File.renameTo()` はアトミックな操作ではない場合があり、プラットフォームによって挙動が異なることもあります。また、異なるファイルシステム間の移動は通常サポートされません。

```java
import java.io.File;
import java.io.IOException;

public class RenameMoveFileIO {
    public static void main(String[] args) {
        File oldFile = new File("original_name_io.txt");
        File newFile = new File("new_name_io.txt");
        File movedFileDir = new File("moved_dir_io");
        File movedFile = new File(movedFileDir, "original_name_io.txt");

        try {
            // テスト用のファイルとディレクトリを作成
            oldFile.createNewFile();
            movedFileDir.mkdir();
            System.out.println("テスト用ファイル " + oldFile.getName() + " を作成しました。");
            System.out.println("テスト用ディレクトリ " + movedFileDir.getName() + " を作成しました。");
        } catch (IOException e) {
            System.err.println("テスト用ファイルの準備に失敗: " + e.getMessage());
            return;
        }

        // リネーム
        // renameTo(dest) は、リネーム/移動が成功した場合に true を返します。
        if (oldFile.renameTo(newFile)) {
            System.out.println(oldFile.getName() + " を " + newFile.getName() + " にリネームしました。");
        } else {
            System.out.println(oldFile.getName() + " のリネームに失敗しました。");
        }

        // newFileを再度oldFileに戻して移動テストの準備
        if (newFile.exists() && !oldFile.exists()) {
            newFile.renameTo(oldFile);
        } else if (!oldFile.exists() && !newFile.exists()) {
             try { oldFile.createNewFile(); } catch (IOException e) { /* ignore */ }
        }


        // 移動 (同じファイルシステム内)
        if (oldFile.renameTo(movedFile)) {
            System.out.println(oldFile.getName() + " を " + movedFile.getPath() + " に移動しました。");
        } else {
            System.out.println(oldFile.getName() + " の移動に失敗しました。");
        }

        // クリーンアップ
        newFile.delete(); // リネームに成功した場合
        oldFile.delete(); // 移動に失敗した場合や、再度作成した場合
        movedFile.delete();
        movedFileDir.delete();
    }
}
```

#### `java.nio.file.Files` を使用したコピー・移動 (推奨)
`Files.copy()` や `Files.move()` はより詳細なオプションを指定でき、エラー処理も明確です。

```java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class CopyMoveNIO {
    public static void main(String[] args) {
        Path sourcePath = Paths.get("source_nio.txt");
        Path copyDestPath = Paths.get("copied_nio.txt");
        Path moveDestPath = Paths.get("moved_dir_nio/renamed_nio.txt"); // 移動先ディレクトリと新しい名前

        try {
            // テスト用のソースファイルと移動先ディレクトリを作成
            if (Files.notExists(sourcePath)) Files.writeString(sourcePath, "This is the source file.");
            Files.createDirectories(moveDestPath.getParent()); // moved_dir_nio を作成
            System.out.println("テスト用ファイル " + sourcePath.getFileName() + " を作成しました。");
            System.out.println("テスト用ディレクトリ " + moveDestPath.getParent().getFileName() + " を作成しました。");
        } catch (IOException e) {
            System.err.println("テスト用ファイルの準備に失敗: " + e.getMessage());
            return;
        }

        // ファイルのコピー
        try {
            // Files.copy(source, target, options...)
            // StandardCopyOption.REPLACE_EXISTING: ターゲットが既に存在する場合に上書きします。
            // StandardCopyOption.COPY_ATTRIBUTES: ファイル属性もコピーします。
            Files.copy(sourcePath, copyDestPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println(sourcePath.getFileName() + " を " + copyDestPath.getFileName() + " にコピーしました。");
        } catch (IOException e) {
            System.err.println(sourcePath.getFileName() + " のコピー中にエラー: " + e.getMessage());
        }

        // ファイルの移動 (リネームを兼ねることも可能)
        try {
            // Files.move(source, target, options...)
            // StandardCopyOption.REPLACE_EXISTING: ターゲットが既に存在する場合に上書きします。
            // StandardCopyOption.ATOMIC_MOVE: 可能であればアトミック操作として移動します。
            Files.move(sourcePath, moveDestPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println(sourcePath.getFileName() + " を " + moveDestPath.toString() + " に移動/リネームしました。");
        } catch (IOException e) {
            System.err.println(sourcePath.getFileName() + " の移動中にエラー: " + e.getMessage());
        }

        // クリーンアップ
        try {
            Files.deleteIfExists(copyDestPath);
            Files.deleteIfExists(moveDestPath);
            Files.deleteIfExists(moveDestPath.getParent()); // moved_dir_nio
            Files.deleteIfExists(sourcePath); // 移動されたので存在しないはずだが、念のため
        } catch (IOException e) {
            System.err.println("クリーンアップ中にエラー: " + e.getMessage());
        }
    }
}
```

### 1.6 一時ファイルの作成と管理
一時的な作業ファイルを安全に作成します。作成された一時ファイルは、通常、JVMの終了時に自動的に削除されるようマークできます。

#### `Files.createTempFile` を使用した一時ファイルの作成 (NIO.2)
`Files.createTempFile` は、システムの一時ディレクトリまたは指定されたディレクトリに一意な名前のファイルを作成します。

```java
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class TemporaryFileOperations {

    public static void main(String[] args) {
        Path tempFile1 = null;
        Path tempFile2 = null;
        Path tempDir = null;

        try {
            // 1. デフォルトの一時ファイルディレクトリにプレフィックスとサフィックスを指定して作成
            // プレフィックス: "myapp-" , サフィックス: ".tmp"
            // 作成されるファイル名は "myapp-" + (ランダムな文字列) + ".tmp" のようになります。
            tempFile1 = Files.createTempFile("myapp-", ".tmp");
            System.out.println("一時ファイルを作成しました (1): " + tempFile1.toAbsolutePath());
            System.out.println("  存在確認: " + Files.exists(tempFile1));

            // 一時ファイルに書き込み
            try (BufferedWriter writer = Files.newBufferedWriter(tempFile1, StandardOpenOption.WRITE)) {
                writer.write("This is some temporary data.");
                writer.newLine();
            }
            System.out.println("  一時ファイル (1) にデータを書き込みました。サイズ: " + Files.size(tempFile1) + " bytes");


            // 2. 特定のディレクトリに一時ファイルを作成 (サフィックスなし)
            // 事前に一時ファイル用のディレクトリを作成
            Path customTempDir = Paths.get("custom_temp_dir");
            Files.createDirectories(customTempDir); // 存在しない場合は作成
            tempDir = customTempDir; // 後で削除するため保持

            // プレフィックス: "session-" , サフィックス: null (デフォルトは ".tmp")
            tempFile2 = Files.createTempFile(customTempDir, "session-", null);
            System.out.println("一時ファイルを作成しました (2): " + tempFile2.toAbsolutePath());

            // deleteOnExit() は、JVM終了時にファイルを削除するよう試みます。
            // ただし、JVMが異常終了した場合など、必ずしも削除される保証はありません。
            // tempFile1.toFile().deleteOnExit();
            // tempFile2.toFile().deleteOnExit();
            // System.out.println("  JVM終了時に一時ファイルが削除されるようにマークしました。");

        } catch (IOException e) {
            System.err.println("一時ファイルの作成または操作中にエラー: " + e.getMessage());
        } finally {
            // 明示的な削除が推奨されます。
            System.out.println("\n--- Cleaning up temporary files ---");
            try {
                if (tempFile1 != null && Files.exists(tempFile1)) {
                    Files.delete(tempFile1);
                    System.out.println("一時ファイル (1) を削除しました: " + tempFile1.getFileName());
                }
                if (tempFile2 != null && Files.exists(tempFile2)) {
                    Files.delete(tempFile2);
                    System.out.println("一時ファイル (2) を削除しました: " + tempFile2.getFileName());
                }
                if (tempDir != null && Files.exists(tempDir)) {
                    Files.delete(tempDir); // ディレクトリが空でないと失敗する
                    System.out.println("一時ディレクトリを削除しました: " + tempDir.getFileName());
                }
            } catch (IOException e) {
                System.err.println("一時ファイルの削除中にエラー: " + e.getMessage());
            }
        }
    }
}
```

---
## 2. テキストデータの読み書き
プレーンテキスト、CSV、プロパティファイルなど、テキストベースのデータを扱うサンプルです。

### 2.1 プレーンテキストファイルの読み書き
テキストファイルの内容を行単位または全体として読み込んだり、文字列をテキストファイルに書き込んだりします。

#### テキストファイルの読み込み
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;

public class TextFileReader {

    public static void main(String[] args) {
        Path filePath = Paths.get("sample_text_read.txt");

        // 事前にsample.txtを作成し、内容を記述しておく
        try {
            Files.writeString(filePath, "Hello World\nThis is a sample text file.\nJava NIO.2 is cool.");
            System.out.println(filePath + " にサンプルテキストを書き込みました。");
        } catch (IOException e) {
            System.err.println(filePath + " へのサンプルテキスト書き込みに失敗: " + e.getMessage());
            return;
        }

        // Files.newBufferedReader を使用した行単位の読み込み
        System.out.println("--- Reading with newBufferedReader ---");
        // try-with-resources構文で、BufferedReaderが自動的にクローズされるようにします。
        // StandardCharsets.UTF_8 は文字コードを指定しています。環境に合わせて変更してください。
        try (BufferedReader reader = Files.newBufferedReader(filePath, StandardCharsets.UTF_8)) {
            String line;
            // 1行ずつ読み込み、nullになるまでループします (ファイルの終端に達するとnullを返します)。
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println(filePath + " の読み込みに失敗しました (newBufferedReader): " + e.getMessage());
        }

        // Files.readString を使用した全内容の読み込み (Java 11+)
        System.out.println("\n--- Reading with readString (Java 11+) ---");
        try {
            // ファイルの全内容を単一の文字列として読み込みます。
            // 大きなファイルを読み込む場合はメモリ使用量に注意が必要です。
            String content = Files.readString(filePath, StandardCharsets.UTF_8);
            System.out.println(content);
        } catch (IOException e) {
            System.err.println(filePath + " の読み込みに失敗しました (readString): " + e.getMessage());
        } catch (UnsupportedOperationException e) {
            System.err.println("Files.readString は Java 11 以降でサポートされています。");
        }

        // Files.readAllLines を使用した全行リストとしての読み込み
        System.out.println("\n--- Reading with readAllLines ---");
        try {
            // ファイルの全行を List<String> として読み込みます。
            // 各要素が1行に対応します。大きなファイルを読み込む場合はメモリ使用量に注意が必要です。
            List<String> lines = Files.readAllLines(filePath, StandardCharsets.UTF_8);
            for (String line : lines) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println(filePath + " の読み込みに失敗しました (readAllLines): " + e.getMessage());
        }

        // 作成したサンプルファイルを削除
        try {
            Files.deleteIfExists(filePath);
        } catch (IOException e) {
            System.err.println(filePath + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

#### テキストファイルへの書き込み
```java
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.List;

public class TextFileWriter {

    public static void main(String[] args) {
        Path filePath1 = Paths.get("output_text1.txt");
        Path filePath2 = Paths.get("output_text2.txt"); // Java 11+ writeString用
        Path filePath3 = Paths.get("output_text3.txt"); // write (Iterable)用

        // Files.newBufferedWriter を使用した書き込み
        // try-with-resources構文で、BufferedWriterが自動的にクローズされるようにします。
        // StandardOpenOption.CREATE: ファイルが存在しない場合は新規作成します。
        // StandardOpenOption.TRUNCATE_EXISTING: ファイルが存在する場合は既存の内容を上書きします。
        // StandardOpenOption.APPEND: ファイルが存在する場合は末尾に追記します。
        try (BufferedWriter writer = Files.newBufferedWriter(filePath1, StandardCharsets.UTF_8,
                                                            StandardOpenOption.CREATE,
                                                            StandardOpenOption.TRUNCATE_EXISTING)) {
            // 文字列を書き込みます。
            writer.write("こんにちは、世界！");
            // 改行を書き込みます。
            writer.newLine();
            writer.write("これは BufferedWriter を使用したテキスト書き込みのサンプルです。");
            writer.newLine();
            System.out.println(filePath1 + " に書き込みました (newBufferedWriter)。");
        } catch (IOException e) {
            System.err.println(filePath1 + " への書き込みに失敗しました (newBufferedWriter): " + e.getMessage());
        }

        // Files.writeString を使用した文字列の書き込み (Java 11+)
        String content = "Hello from Files.writeString!\nThis is a new line using Java 11 feature.";
        try {
            // 指定した文字列をファイルに書き込みます。
            // デフォルトでは、ファイルが存在しない場合は新規作成、存在する場合は上書きします。
            Files.writeString(filePath2, content, StandardCharsets.UTF_8,
                              StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            System.out.println(filePath2 + " に書き込みました (writeString)。");
        } catch (IOException e) {
            System.err.println(filePath2 + " への書き込みに失敗しました (writeString): " + e.getMessage());
        } catch (UnsupportedOperationException e) {
            System.err.println("Files.writeString は Java 11 以降でサポートされています。");
        }

        // Files.write を使用した行リストの書き込み
        List<String> lines = Arrays.asList(
                "First line from Files.write.",
                "Second line here.",
                "最後に、もう1行。"
        );
        try {
            // 文字列のリスト (Iterable<? extends CharSequence>) をファイルに書き込みます。
            // 各要素が1行として書き込まれ、行末にはシステムの改行コードが自動的に付与されます。
            Files.write(filePath3, lines, StandardCharsets.UTF_8,
                        StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            System.out.println(filePath3 + " に書き込みました (write Iterable)。");
        } catch (IOException e) {
            System.err.println(filePath3 + " への書き込みに失敗しました (write Iterable): " + e.getMessage());
        }

        // 作成したファイルを削除 (任意)
        try {
            Files.deleteIfExists(filePath1);
            Files.deleteIfExists(filePath2);
            Files.deleteIfExists(filePath3);
        } catch (IOException e) {
            System.err.println("出力ファイルの削除に失敗: " + e.getMessage());
        }
    }
}
```

### 2.2 CSVファイルの読み書き
カンマ区切り形式（CSV）のファイルを読み書きします。標準APIのみのため、簡易的な処理を想定しています。

#### CSVファイルの読み込み
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CsvReader {

    public static void main(String[] args) {
        Path csvFilePath = Paths.get("data_csv_read.csv");

        // 事前にdata.csvを作成し、内容を記述しておく
        List<String> csvLines = Arrays.asList(
                "ID,Name,Email",
                "1,Alice,alice@example.com",
                "2,Bob,bob@example.com",
                "3,Charlie,charlie@example.com"
        );
        try {
            Files.write(csvFilePath, csvLines, StandardCharsets.UTF_8);
            System.out.println(csvFilePath + " にサンプルCSVデータを書き込みました。");
        } catch (IOException e) {
            System.err.println(csvFilePath + " へのサンプルCSVデータ書き込みに失敗: " + e.getMessage());
            return;
        }

        List<String[]> records = new ArrayList<>();
        // try-with-resources で BufferedReader を確実にクローズします。
        try (BufferedReader br = Files.newBufferedReader(csvFilePath, StandardCharsets.UTF_8)) {
            String line;
            // 1行ずつ読み込みます。
            while ((line = br.readLine()) != null) {
                // 読み込んだ行をカンマ(,)で分割します。
                // この方法は、値にカンマが含まれていたり、値がダブルクォートで囲まれている場合には正しく動作しません。
                String[] values = line.split(",");
                records.add(values);
            }
        } catch (IOException e) {
            System.err.println(csvFilePath + " の読み込みに失敗しました: " + e.getMessage());
        }

        // 読み込んだデータを表示 (ヘッダー行も含む)
        for (String[] record : records) {
            // 分割された各フィールドをタブ区切りで表示します。
            System.out.println(String.join("\t|\t", record));
        }

        // 作成したサンプルファイルを削除
        try {
            Files.deleteIfExists(csvFilePath);
        } catch (IOException e) {
            System.err.println(csvFilePath + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

#### CSVファイルへの書き込み
```java
import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.Arrays;
import java.util.List;

public class CsvWriter {

    public static void main(String[] args) {
        Path csvFilePath = Paths.get("output_csv_write.csv");

        // 書き込むデータ (String配列のリストとして準備)
        List<String[]> dataToWrite = Arrays.asList(
                new String[]{"ID", "ProductName", "Price"}, // ヘッダー行
                new String[]{"101", "Laptop", "120000"},
                new String[]{"102", "Mouse", "2500"},
                new String[]{"103", "Keyboard", "7000"}
        );

        // try-with-resources で BufferedWriter を確実にクローズします。
        try (BufferedWriter bw = Files.newBufferedWriter(csvFilePath, StandardCharsets.UTF_8,
                                                        StandardOpenOption.CREATE,
                                                        StandardOpenOption.TRUNCATE_EXISTING)) {
            for (String[] record : dataToWrite) {
                // String.join を使って、文字列配列をカンマ区切りの1行の文字列に変換します。
                // この方法は、値にカンマや改行、ダブルクォートが含まれる場合の適切なエスケープ処理を行いません。
                String line = String.join(",", record);
                bw.write(line);
                // 各行の末尾に改行を追加します。
                bw.newLine();
            }
            System.out.println(csvFilePath + " にCSVデータを書き込みました。");
        } catch (IOException e) {
            System.err.println(csvFilePath + " への書き込みに失敗しました: " + e.getMessage());
        }

        // 作成したファイルを削除 (任意)
        try {
            Files.deleteIfExists(csvFilePath);
        } catch (IOException e) {
            System.err.println(csvFilePath + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

#### Recordを用いたCSVファイルからのデータオブジェクト生成
Record型を利用して、CSVの各行からデータオブジェクトを生成します。

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

// CSVの1行に対応するRecordを定義します。
// Java 16以降で利用可能です。
record UserRecord(
    int id,
    String name,
    String email
) {
    // ファクトリメソッドを追加して、文字列配列からUserRecordを生成しやすくします。
    // 不正なデータ（例：IDが数値でない）に対するエラーハンドリングもここで行うことができます。
    public static UserRecord fromCsvLine(String[] csvLine) {
        if (csvLine.length < 3) {
            throw new IllegalArgumentException("CSV行の要素数が不足しています。期待値: 3, 実際値: " + csvLine.length);
        }
        try {
            int id = Integer.parseInt(csvLine[0].trim()); // trim()で前後の空白を除去
            String name = csvLine[1].trim();
            String email = csvLine[2].trim();
            return new UserRecord(id, name, email);
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("IDフィールドが不正な数値形式です: " + csvLine[0], e);
        }
    }
}

public class CsvToRecordReader {

    public static void main(String[] args) {
        Path csvFilePath = Paths.get("user_data_record.csv");

        // 事前にuser_data.csvを作成し、内容を記述しておく
        List<String> csvLines = Arrays.asList(
                "ID,Name,Email", // ヘッダー行
                "1,Alice Smith,asmith@example.com",
                "2,Bob Johnson,bjohnson@example.com",
                " 3 , Carol Williams , cwilliams@example.org " // 不揃いな空白を含むデータ例
        );
        try {
            Files.write(csvFilePath, csvLines, StandardCharsets.UTF_8);
            System.out.println(csvFilePath + " にサンプルCSVデータを書き込みました。");
        } catch (IOException e) {
            System.err.println(csvFilePath + " へのサンプルCSVデータ書き込みに失敗: " + e.getMessage());
            return;
        }

        List<UserRecord> userRecords = new ArrayList<>();
        try (BufferedReader br = Files.newBufferedReader(csvFilePath, StandardCharsets.UTF_8)) {
            // ヘッダー行を読み飛ばす (必要に応じて)
            String headerLine = br.readLine();
            if (headerLine == null) {
                System.err.println("CSVファイルが空か、ヘッダー行がありません。");
                return;
            }
            System.out.println("ヘッダー: " + headerLine);

            String line;
            int lineNumber = 1; // ヘッダーを除いた行番号
            while ((line = br.readLine()) != null) {
                lineNumber++;
                // 空白行はスキップ
                if (line.trim().isEmpty()) {
                    continue;
                }
                String[] values = line.split(",");
                try {
                    UserRecord user = UserRecord.fromCsvLine(values);
                    userRecords.add(user);
                } catch (IllegalArgumentException e) {
                    System.err.println("行 " + lineNumber + " の処理中にエラーが発生しました: " + line + " - " + e.getMessage());
                }
            }
        } catch (IOException e) {
            System.err.println(csvFilePath + " の読み込みに失敗しました: " + e.getMessage());
        }

        // 読み込んだUserRecordオブジェクトを表示
        System.out.println("\n--- Parsed User Records ---");
        for (UserRecord user : userRecords) {
            System.out.println(user); // Recordは自動的にtoString()が適切に実装されます
        }

        // Stream API を使った読み込みと変換 (よりモダンな書き方)
        System.out.println("\n--- Parsed User Records (Stream API) ---");
        try (BufferedReader br = Files.newBufferedReader(csvFilePath, StandardCharsets.UTF_8)) {
            List<UserRecord> userRecordsStreamed = br.lines()
                .skip(1) // ヘッダー行をスキップ
                .filter(line -> !line.trim().isEmpty()) // 空白行を除外
                .map(line -> {
                    String[] values = line.split(",");
                    try {
                        return UserRecord.fromCsvLine(values);
                    } catch (IllegalArgumentException e) {
                        System.err.println("Stream処理中に行エラー: " + line + " - " + e.getMessage());
                        return null; // エラーの場合はnullを返し、後でフィルタリングする (または例外をスロー)
                    }
                })
                .filter(java.util.Objects::nonNull) // nullになったエントリを除外
                .collect(Collectors.toList());

            userRecordsStreamed.forEach(System.out::println);

        } catch (IOException e) {
            System.err.println(csvFilePath + " の読み込みに失敗しました (Stream API): " + e.getMessage());
        }

        // 作成したサンプルファイルを削除
        try {
            Files.deleteIfExists(csvFilePath);
        } catch (IOException e) {
            System.err.println(csvFilePath + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

### 2.3 プロパティファイル (`.properties`) の読み書き
キーと値のペアで構成されるプロパティファイルを読み書きします。主に設定情報の管理に利用されます。

#### プロパティファイルの読み込み
```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

public class PropertiesFileReader {
    private static final String PROPS_FILENAME = "config_read.properties";

    public static void main(String[] args) {
        Path propsFilePath = Paths.get(PROPS_FILENAME);

        // テスト用のプロパティファイルを作成 (UTF-8で)
        try (FileWriter writer = new FileWriter(propsFilePath.toFile(), StandardCharsets.UTF_8)) {
            writer.write("# This is a comment\n");
            writer.write("app.name=My Application\n");
            writer.write("app.version=1.0.2\n");
            writer.write("user.language=japanese\n");
            writer.write("database.url=jdbc:mydb://localhost:5432/mydatabase\n");
            writer.write("greeting=\\u3053\\u3093\\u306B\\u3061\\u306F\\u3001\\u4E16\\u754C\\uff01\n"); // こんにちは、世界！
            System.out.println(PROPS_FILENAME + " をUTF-8で作成しました。");
        } catch (IOException e) {
            System.err.println(PROPS_FILENAME + " の準備に失敗: " + e.getMessage());
            return;
        }

        Properties props = new Properties();
        // try-with-resources で Reader を確実にクローズします。
        // UTF-8エンコーディングのプロパティファイルを読み込む場合は Files.newBufferedReader を使用します。
        try (Reader reader = Files.newBufferedReader(propsFilePath, StandardCharsets.UTF_8)) {
            // Propertiesオブジェクトにファイル内容を読み込みます。
            props.load(reader);
            System.out.println("\n--- " + PROPS_FILENAME + " からプロパティを読み込みました ---");

            // 個々のプロパティ値を取得
            String appName = props.getProperty("app.name");
            String appVersion = props.getProperty("app.version");
            String userLang = props.getProperty("user.language", "english"); // 第2引数はデフォルト値
            String dbUrl = props.getProperty("database.url");
            String greeting = props.getProperty("greeting");

            System.out.println("Application Name: " + appName);
            System.out.println("Application Version: " + appVersion);
            System.out.println("User Language: " + userLang);
            System.out.println("Database URL: " + dbUrl);
            System.out.println("Greeting: " + greeting); // Unicodeエスケープがデコードされている

        } catch (IOException e) {
            System.err.println(PROPS_FILENAME + " の読み込み中にエラー: " + e.getMessage());
        }

        // テスト用ファイルを削除
        try {
            Files.deleteIfExists(propsFilePath);
        } catch (IOException e) {
            System.err.println(PROPS_FILENAME + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

#### プロパティファイルへの書き込み
```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;

public class PropertiesFileWriter {
    private static final String PROPS_FILENAME_OUT = "output_config_write.properties";

    public static void main(String[] args) {
        Path propsFilePath = Paths.get(PROPS_FILENAME_OUT);
        Properties props = new Properties();

        // Propertiesオブジェクトにキーと値を設定
        props.setProperty("server.host", "localhost");
        props.setProperty("server.port", "8080");
        props.setProperty("service.enabled", "true");
        props.setProperty("message.welcome", "ようこそ！"); // 日本語も直接設定可能


        // try-with-resources で Writer を確実にクローズします。
        // UTF-8エンコーディングで書き出す場合は Files.newBufferedWriter を使用します。
        // storeメソッドの第2引数のコメントは、ファイルの先頭に書き込まれます (nullも可)。
        try (Writer writer = Files.newBufferedWriter(propsFilePath, StandardCharsets.UTF_8)) {
            props.store(writer, "Application Configuration - Saved at " + java.time.LocalDateTime.now());
            System.out.println(PROPS_FILENAME_OUT + " にプロパティを書き込みました。");
        } catch (IOException e) {
            System.err.println(PROPS_FILENAME_OUT + " への書き込み中にエラー: " + e.getMessage());
        }

        // テスト用ファイルを削除
        try {
            Files.deleteIfExists(propsFilePath);
        } catch (IOException e) {
            System.err.println(PROPS_FILENAME_OUT + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

---
## 3. XMLデータの処理
XMLファイルの読み込み、解析、生成を行うサンプルです。標準APIのDOMパーサーを使用します。

### 3.1 XMLファイルの読み込みとDOMツリーのトラバース
XMLファイルをパースしてDOM (Document Object Model) オブジェクトを取得し、その内容を解析します。

```java
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class SimpleXmlDomReader {
    private static final String XML_FILENAME = "staff_read.xml";

    public static void main(String[] args) {
        Path xmlFilePath = Paths.get(XML_FILENAME);

        // テスト用のXMLファイルを作成
        String xmlContent = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
                            "<company>\n" +
                            "  <staff id=\"1001\">\n" +
                            "    <firstname>Taro</firstname>\n" +
                            "    <lastname>Yamada</lastname>\n" +
                            "    <nickname>tarochan</nickname>\n" +
                            "    <salary currency=\"JPY\">300000</salary>\n" +
                            "  </staff>\n" +
                            "  <staff id=\"1002\">\n" +
                            "    <firstname>Hanako</firstname>\n" +
                            "    <lastname>Suzuki</lastname>\n" +
                            "    <nickname>hana</nickname>\n" +
                            "    <salary currency=\"JPY\">350000</salary>\n" +
                            "  </staff>\n" +
                            "</company>";
        try {
            Files.writeString(xmlFilePath, xmlContent);
            System.out.println(XML_FILENAME + " を作成しました。");
        } catch (IOException e) {
            System.err.println(XML_FILENAME + " の準備に失敗: " + e.getMessage());
            return;
        }

        try {
            // 1. DocumentBuilderFactoryのインスタンスを取得
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            // XXE対策等を考慮する場合は、ここでfactoryに各種設定を行う
            // factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);

            // 2. DocumentBuilderのインスタンスを取得
            DocumentBuilder builder = factory.newDocumentBuilder();

            // 3. XMLファイルをパースしてDocumentオブジェクトを取得
            Document document = builder.parse(xmlFilePath.toFile());
            document.getDocumentElement().normalize(); // DOMツリーの正規化

            System.out.println("\n--- XML Content from " + XML_FILENAME + " ---");
            Element rootElement = document.getDocumentElement();
            System.out.println("ルート要素: " + rootElement.getNodeName());

            NodeList staffList = rootElement.getElementsByTagName("staff");
            for (int i = 0; i < staffList.getLength(); i++) {
                Node staffNode = staffList.item(i);
                if (staffNode.getNodeType() == Node.ELEMENT_NODE) {
                    Element staffElement = (Element) staffNode;
                    String staffId = staffElement.getAttribute("id");
                    System.out.println("\nStaff ID: " + staffId);

                    String firstname = getElementTextContent(staffElement, "firstname");
                    String lastname = getElementTextContent(staffElement, "lastname");
                    Element salaryElement = (Element) staffElement.getElementsByTagName("salary").item(0);
                    String salary = salaryElement.getTextContent();
                    String currency = salaryElement.getAttribute("currency");

                    System.out.println("  First Name: " + firstname);
                    System.out.println("  Last Name: " + lastname);
                    System.out.println("  Salary: " + salary + " (" + currency + ")");
                }
            }

        } catch (ParserConfigurationException | SAXException | IOException e) {
            System.err.println("XML処理中にエラー: " + e.getMessage());
        }

        // テスト用ファイルを削除
        try {
            Files.deleteIfExists(xmlFilePath);
        } catch (IOException e) {
            System.err.println(XML_FILENAME + " の削除に失敗: " + e.getMessage());
        }
    }

    // 指定された要素名の子要素のテキスト内容を取得するヘルパーメソッド
    private static String getElementTextContent(Element parentElement, String tagName) {
        NodeList nodeList = parentElement.getElementsByTagName(tagName);
        if (nodeList.getLength() > 0) {
            return nodeList.item(0).getTextContent();
        }
        return ""; // 要素が存在しない場合は空文字
    }
}
```

### 3.2 DOMを使用したXMLファイルの生成と書き出し
プログラムでDOMツリーを構築し、それをXMLファイルとして出力します。

```java
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class SimpleXmlDomWriter {
    private static final String XML_OUTPUT_FILENAME = "output_staff_write.xml";

    public static void main(String[] args) {
        Path xmlFilePath = Paths.get(XML_OUTPUT_FILENAME);

        try {
            // 1. DocumentBuilderFactory と DocumentBuilder を取得
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();

            // 2. 新しい Document オブジェクトを作成
            Document document = builder.newDocument();

            // 3. ルート要素を作成して Document に追加
            Element rootElement = document.createElement("employees");
            document.appendChild(rootElement);

            // 4. 子要素を作成して追加 (1人目の従業員)
            Element employee1 = document.createElement("employee");
            employee1.setAttribute("id", "E001");
            rootElement.appendChild(employee1);

            Element name1 = document.createElement("name");
            name1.appendChild(document.createTextNode("Jiro Tanaka"));
            employee1.appendChild(name1);

            // 5. Document オブジェクトを XML ファイルに書き出し
            TransformerFactory transformerFactory = TransformerFactory.newInstance();
            Transformer transformer = transformerFactory.newTransformer();
            transformer.setOutputProperty(OutputKeys.INDENT, "yes"); // インデントを有効に
            transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2"); // インデント幅
            transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8");

            DOMSource source = new DOMSource(document);
            try (OutputStream os = new FileOutputStream(xmlFilePath.toFile())) {
                StreamResult result = new StreamResult(os);
                transformer.transform(source, result);
                System.out.println(XML_OUTPUT_FILENAME + " にXMLデータを書き込みました。");
            }

        } catch (ParserConfigurationException | TransformerException | IOException e) {
            System.err.println("XML生成・書き出し中にエラー: " + e.getMessage());
        }

        // テスト用ファイルを削除
        try {
            Files.deleteIfExists(xmlFilePath);
        } catch (IOException e) {
            System.err.println(XML_OUTPUT_FILENAME + " の削除に失敗: " + e.getMessage());
        }
    }
}
```

---
## 4. バイナリデータの処理
画像ファイルやJavaオブジェクトのシリアライズなど、バイナリ形式のデータを扱うサンプルです。

### 4.1 画像ファイルの読み込み・書き込み
一般的な画像形式（JPEG, PNGなど）のファイルを読み書きします。

#### 画像ファイルの読み込み
```java
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class ImageReader {
    public static void main(String[] args) {
        Path inputFilePath = Paths.get("sample_input_image.png");
        // ダミー画像を作成 (実際には有効な画像を用意)
        try {
            BufferedImage dummyImage = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB);
            ImageIO.write(dummyImage, "png", inputFilePath.toFile());
            System.out.println("ダミー画像を作成: " + inputFilePath.getFileName());
        } catch (IOException e) {
            System.err.println("ダミー画像の作成に失敗。事前に画像ファイルを用意してください。 " + e.getMessage());
        }


        BufferedImage image = null;
        try {
            // ファイルから画像を読み込みます。
            image = ImageIO.read(inputFilePath.toFile());

            if (image != null) {
                System.out.println(inputFilePath.getFileName() + " の読み込みに成功しました。");
                System.out.println("画像の幅: " + image.getWidth() + "px");
                System.out.println("画像の高さ: " + image.getHeight() + "px");
            } else {
                System.err.println(inputFilePath.getFileName() + " の読み込みに失敗。サポートされていない形式かファイルが存在しません。");
            }
        } catch (IOException e) {
            System.err.println(inputFilePath.getFileName() + " の読み込み中にエラー: " + e.getMessage());
        }
        // ダミー画像を削除
        try { Files.deleteIfExists(inputFilePath); } catch (IOException e) { /* ignore */ }
    }
}
```

#### 画像ファイルの書き込み
```java
import javax.imageio.ImageIO;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class ImageWriter {
    public static void main(String[] args) {
        Path outputFilePath = Paths.get("output_image_generated.png");
        String format = "png";

        int width = 300;
        int height = 200;
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);

        Graphics2D g2d = image.createGraphics();
        g2d.setColor(Color.LIGHT_GRAY);
        g2d.fillRect(0, 0, width, height);
        g2d.setColor(Color.BLUE);
        g2d.setFont(new Font("Serif", Font.BOLD, 24));
        g2d.drawString("Hello, Java Image!", 50, 100);
        g2d.dispose();

        try {
            // BufferedImage をファイルとして書き出す
            boolean success = ImageIO.write(image, format, outputFilePath.toFile());
            if (success) {
                System.out.println(outputFilePath.getFileName() + " の書き込みに成功しました。");
            } else {
                System.err.println(outputFilePath.getFileName() + " の書き込みに失敗しました。");
            }
        } catch (IOException e) {
            System.err.println(outputFilePath.getFileName() + " の書き込み中にエラー: " + e.getMessage());
        }
        // 作成した画像を削除
        try { Files.deleteIfExists(outputFilePath); } catch (IOException e) { /* ignore */ }
    }
}
```

### 4.2 オブジェクトの直列化（シリアライズ）
Javaオブジェクトの状態をバイトストリームとして保存（直列化）したり、復元（逆直列化）したりします。

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Date;

// 直列化可能なクラス (Serializableを実装)
class MyDataObject implements Serializable {
    private static final long serialVersionUID = 1L; // 直列化互換性のために重要
    private String message;
    private int number;
    private Date creationDate;
    private transient String temporaryInfo; // transient修飾子は直列化対象外

    public MyDataObject(String message, int number, String temporaryInfo) {
        this.message = message;
        this.number = number;
        this.creationDate = new Date();
        this.temporaryInfo = temporaryInfo;
    }
    @Override
    public String toString() {
        return "MyDataObject{message='" + message + "', number=" + number +
               ", creationDate=" + creationDate + ", temporaryInfo='" + temporaryInfo + "'}";
    }
}

public class ObjectSerialization {
    private static final String FILENAME = "mydata_serialized.ser";

    public static void main(String[] args) {
        // 1. オブジェクトのファイルへの直列化
        MyDataObject data = new MyDataObject("こんにちは、直列化！", 123, "一時データ");
        System.out.println("直列化前のオブジェクト: " + data);
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILENAME))) {
            oos.writeObject(data); // オブジェクトを直列化しファイルに書き込み
            System.out.println("オブジェクトが " + FILENAME + " に直列化されました。");
        } catch (IOException e) {
            System.err.println("オブジェクトの直列化中にエラー: " + e.getMessage());
        }

        // 2. ファイルからのオブジェクトの逆直列化
        MyDataObject deserializedData = null;
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILENAME))) {
            deserializedData = (MyDataObject) ois.readObject(); // ファイルから読み込み逆直列化
            System.out.println("オブジェクトが " + FILENAME + " から逆直列化されました。");
            System.out.println("逆直列化後のオブジェクト: " + deserializedData);
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("オブジェクトの逆直列化中にエラー: " + e.getMessage());
        }

        // 作成したファイルを削除
        try { Files.deleteIfExists(Paths.get(FILENAME)); } catch (IOException e) { /* ignore */ }
    }
}
```

### 4.3 ランダムアクセスファイルによる任意位置への読み書き
ファイルの任意の位置に対して直接読み書きを行います。

```java
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;

public class RandomFileAccessor {
    private static final String FILENAME = "random_access_demo.dat";

    public static void main(String[] args) {
        try {
            Files.writeString(Paths.get(FILENAME), "0123456789ABCDEF"); // 初期データ
        } catch (IOException e) {
            System.err.println(FILENAME + " の準備中にエラー: " + e.getMessage()); return;
        }

        // try-with-resources で RandomAccessFile を確実にクローズ
        // モード: "r" (読み取り専用), "rw" (読み書き両用)
        try (RandomAccessFile raf = new RandomAccessFile(FILENAME, "rw")) {
            // 1. 特定の位置から読み取り
            raf.seek(5); // ファイルポインタを5バイト目に移動
            byte b = raf.readByte();
            System.out.println("位置 5 から読み取ったバイト: " + (char)b); // '5'

            // 2. 特定の位置への書き込み
            raf.seek(10); // ファイルポインタを10バイト目に移動
            raf.write("XYZ".getBytes(StandardCharsets.UTF_8)); // "ABC" を "XYZ" で上書き
            System.out.println("位置 10 に \"XYZ\" を書き込みました。");

            // 3. ファイルの先頭から全体を読み直して確認
            raf.seek(0);
            byte[] fileContent = new byte[(int) raf.length()];
            raf.readFully(fileContent);
            System.out.println("書き込み後のファイル全体: " + new String(fileContent, StandardCharsets.UTF_8));
            // 期待値: "0123456789XYZDEF"

        } catch (IOException e) {
            System.err.println(FILENAME + " のランダムアクセス中にエラー: " + e.getMessage());
        }

        // テスト用ファイルを削除
        try { Files.deleteIfExists(Paths.get(FILENAME)); } catch (IOException e) { /* ignore */ }
    }
}
```

---

## 5. アーカイブ操作 (ZIP)
ZIPファイルの作成と展開を行うサンプルです。

### 5.1 ZIPファイルの作成
複数のファイルを1つのZIPアーカイブに追加します。

```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class ZipFileCreator {
    private static final String ZIP_FILENAME = "my_archive.zip";
    private static final String SOURCE_DIR_NAME = "files_to_zip";

    public static void main(String[] args) {
        Path sourceDir = Paths.get(SOURCE_DIR_NAME);
        Path zipFilePath = Paths.get(ZIP_FILENAME);

        // テスト用のソースファイルとディレクトリを作成
        try {
            Files.createDirectories(sourceDir.resolve("subdir_zip"));
            Files.writeString(sourceDir.resolve("fileA.txt"), "Content of fileA");
            Files.writeString(sourceDir.resolve("subdir_zip/fileB.log"), "Log data in subdir");
            System.out.println("ZIP化対象のソースファイルを作成しました。");
        } catch (IOException e) {
            System.err.println("ZIPソースファイルの準備に失敗: " + e.getMessage()); return;
        }

        // try-with-resources で ZipOutputStream を確実にクローズ
        try (ZipOutputStream zos = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(zipFilePath.toFile())))) {
            System.out.println(ZIP_FILENAME + " を作成開始...");
            addDirectoryToZip(sourceDir, sourceDir, zos); // ヘルパーメソッド呼び出し
            System.out.println(ZIP_FILENAME + " が正常に作成されました。");
        } catch (IOException e) {
            System.err.println(ZIP_FILENAME + " の作成中にエラー: " + e.getMessage());
        }

        // クリーンアップ
        try {
            Files.deleteIfExists(zipFilePath);
            Files.deleteIfExists(sourceDir.resolve("subdir_zip/fileB.log"));
            Files.deleteIfExists(sourceDir.resolve("subdir_zip"));
            Files.deleteIfExists(sourceDir.resolve("fileA.txt"));
            Files.deleteIfExists(sourceDir);
        } catch (IOException e) { System.err.println("クリーンアップ中にエラー: " + e.getMessage()); }
    }

    // ディレクトリ内のファイル/サブディレクトリを再帰的にZIPに追加するヘルパーメソッド
    private static void addDirectoryToZip(Path rootDir, Path sourcePath, ZipOutputStream zos) throws IOException {
        Files.list(sourcePath).forEach(filePath -> {
            try {
                String entryName = rootDir.relativize(filePath).toString().replace('\\', '/');
                if (Files.isDirectory(filePath)) {
                    entryName += "/";
                    zos.putNextEntry(new ZipEntry(entryName));
                    zos.closeEntry();
                    addDirectoryToZip(rootDir, filePath, zos); // 再帰呼び出し
                } else {
                    zos.putNextEntry(new ZipEntry(entryName));
                    try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath.toFile()))) {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = bis.read(buffer)) != -1) {
                            zos.write(buffer, 0, bytesRead);
                        }
                    }
                    zos.closeEntry();
                }
            } catch (IOException e) { throw new RuntimeException("ZIPエントリ追加エラー: " + filePath, e); }
        });
    }
}
```

### 5.2 ZIPファイルの展開
ZIPアーカイブ内のファイルを指定したディレクトリに展開します。

```java
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class ZipFileExtractor {
    private static final String ZIP_TO_EXTRACT = "archive_to_extract_sample.zip";
    private static final String EXTRACTION_TARGET_DIR = "extracted_content";

    public static void main(String[] args) {
        Path zipFilePath = Paths.get(ZIP_TO_EXTRACT);
        Path extractionDir = Paths.get(EXTRACTION_TARGET_DIR);

        // テスト用のZIPファイルを作成 (ZipFileCreatorのロジックを簡略化して使用)
        try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(zipFilePath.toFile()))) {
            zos.putNextEntry(new ZipEntry("entry1.txt"));
            zos.write("Content of entry1".getBytes());
            zos.closeEntry();
            zos.putNextEntry(new ZipEntry("folder/entry2.txt"));
            zos.write("Content of entry2 in folder".getBytes());
            zos.closeEntry();
            System.out.println("展開テスト用のZIPファイルを作成: " + zipFilePath.getFileName());
        } catch (IOException e) {
            System.err.println("展開用ZIPファイルの準備に失敗: " + e.getMessage()); return;
        }

        // try-with-resources で ZipInputStream を確実にクローズ
        try (ZipInputStream zis = new ZipInputStream(new BufferedInputStream(new FileInputStream(zipFilePath.toFile())))) {
            Files.createDirectories(extractionDir); // 展開先ディレクトリを作成
            System.out.println(zipFilePath.getFileName() + " を " + extractionDir + " に展開開始...");
            ZipEntry zipEntry;
            while ((zipEntry = zis.getNextEntry()) != null) {
                Path entryDestPath = extractionDir.resolve(zipEntry.getName());
                // Zip Slip脆弱性対策
                if (!entryDestPath.normalize().startsWith(extractionDir.normalize())) {
                    throw new IOException("不正なZIPエントリ (Zip Slip): " + zipEntry.getName());
                }
                if (zipEntry.isDirectory()) {
                    Files.createDirectories(entryDestPath);
                } else {
                    Files.createDirectories(entryDestPath.getParent()); // 親ディレクトリも作成
                    try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(entryDestPath.toFile()))) {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = zis.read(buffer)) != -1) {
                            bos.write(buffer, 0, bytesRead);
                        }
                    }
                }
                zis.closeEntry();
                System.out.println("  展開: " + entryDestPath);
            }
            System.out.println("ZIPファイルの展開が完了しました。");
        } catch (IOException e) {
            System.err.println(zipFilePath.getFileName() + " の展開中にエラー: " + e.getMessage());
        }

        // クリーンアップ
        try {
            Files.deleteIfExists(zipFilePath);
            if (Files.exists(extractionDir)) {
                 Files.walk(extractionDir).sorted(java.util.Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
            }
        } catch (IOException e) { System.err.println("クリーンアップ中にエラー: " + e.getMessage()); }
    }
}
```

---
## 6. 高度なファイルシステム操作
ディレクトリ構造の探索や、条件に合うファイルの検索など、より複雑なファイル操作のサンプルです。

### 6.1 ディレクトリ内のファイルフィルタリング
特定の条件（拡張子、サイズ、名前のパターンなど）に一致するファイルやディレクトリを一覧表示します。

```java
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class FileFiltering {
    public static void main(String[] args) {
        Path targetDir = Paths.get("."); // カレントディレクトリ
        // テストファイル準備
        try {
            Files.writeString(Paths.get("filter_test1.txt"), "text");
            Files.writeString(Paths.get("filter_test2.log"), "log");
            Files.createDirectory(Paths.get("filter_subdir"));
        } catch (IOException e) { /* ignore */ }

        // 1. 特定の拡張子 (.txt) を持つファイルのみをフィルタリング
        System.out.println("\n--- .txt files in " + targetDir.toAbsolutePath() + " ---");
        DirectoryStream.Filter<Path> txtFilter = entry ->
            Files.isRegularFile(entry) && entry.getFileName().toString().endsWith(".txt");
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(targetDir, txtFilter)) {
            stream.forEach(entry -> System.out.println(entry.getFileName()));
        } catch (IOException e) {
            System.err.println(targetDir + " の読み込み中にエラー (txtFilter): " + e.getMessage());
        }

        // 2. Globパターンを使用したフィルタリング (例: "filter_test*" で始まる)
        System.out.println("\n--- Files starting with 'filter_test' (glob) ---");
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(targetDir, "filter_test*")) {
            stream.forEach(entry -> System.out.println(entry.getFileName()));
        } catch (IOException e) {
            System.err.println(targetDir + " の読み込み中にエラー (glob filter): " + e.getMessage());
        }

        // クリーンアップ
        try {
            Files.deleteIfExists(Paths.get("filter_test1.txt"));
            Files.deleteIfExists(Paths.get("filter_test2.log"));
            Files.deleteIfExists(Paths.get("filter_subdir"));
        } catch (IOException e) { /* ignore */ }
    }
}
```

### 6.2 ディレクトリツリーの再帰的処理
指定したディレクトリ配下のすべてのファイルやサブディレクトリに対して処理を行います。

```java
import java.io.IOException;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

public class RecursiveDirectoryTraversal {
    public static void main(String[] args) {
        Path startDir = Paths.get("."); // カレントディレクトリ
        // テスト用ディレクトリ構造を作成
        try {
            Files.createDirectories(Paths.get("traverse_A/subA1"));
            Files.writeString(Paths.get("traverse_A/fileA.txt"), "content");
            System.out.println("テスト用ディレクトリ構造を作成。");
        } catch (IOException e) { /* ignore */ }


        System.out.println("\n--- Traversing directory tree: " + startDir.toAbsolutePath() + " ---");
        try {
            // SimpleFileVisitorを継承したカスタムビジター
            Files.walkFileTree(startDir, new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                    System.out.println("Entering dir: " + dir.getFileName());
                    return FileVisitResult.CONTINUE; // 走査を継続
                }
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
                    System.out.println("  File: " + file.getFileName() + " (Size: " + attrs.size() + ")");
                    return FileVisitResult.CONTINUE;
                }
                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
                    System.out.println("Exiting dir: " + dir.getFileName());
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            System.err.println("ディレクトリツリーの走査中にエラー: " + e.getMessage());
        }
        // クリーンアップ
        try {
            Files.deleteIfExists(Paths.get("traverse_A/fileA.txt"));
            Files.deleteIfExists(Paths.get("traverse_A/subA1"));
            Files.deleteIfExists(Paths.get("traverse_A"));
        } catch (IOException e) { /* ignore */ }
    }
}
```