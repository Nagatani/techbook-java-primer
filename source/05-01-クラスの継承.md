---
title: クラスの継承
---

> オブジェクト指向プログラミングおよび演習1 第5回
>
> 継承の基礎と実践

## 1\. はじめに：継承とは何か？

### 1.1. ざっくり理解しておこう

オブジェクト指向プログラミングの基本概念として、「カプセル化」「多態性（ポリモーフィズム）」を学びました。これに加え、今回は「継承」の考え方を学びます。

継承は、「受け継ぐこと」といった意味合いがあります。
そのままの意味で、オブジェクトが持つフィールド、メソッドなどを受け継ぐことができるようになる仕組みです。
受け継いだ機能は、そのまま利用することもできますし、上書きして違う機能を提供することもできます。

受け継ぐことができると、開発作業の効率化を図れたり、再利用性を高める効果が見込めます。
ただ、使用するにしてもメリット・デメリットがあるので、この資料を良く読み、「安易な使い方は避けるべき」という考え方を身に付けましょう。

### 1.2. 中核概念：既存の仕組みを利用する

継承は、オブジェクト指向プログラミングにおける基本的なメカニズムの1つです。これは、既存のクラス（親クラス、スーパークラス）を基盤として、新しいクラス（子クラス、サブクラス）を作成することを可能にします。新しいクラスは、基盤となるクラスの非privateなメンバー（フィールドとメソッド）を自動的に受け継ぎます。

継承の本質は、「**is-a**」（〜は〜の一種である）関係にあります。サブクラスは、スーパークラスの**特殊化された**バージョンと考えることができます。
たとえば、ECサイトにおいて「書籍 (Book)」は多種多様な「商品 (Product)」の中の一種です。したがって、`Book` クラスは `Product` クラスを継承することで、商品が共通して持つ特性（商品ID、名称、価格、税込み価格計算など）を受け継ぎつつ、書籍固有の特性（著者名、出版社、ISBNなど）を追加できます。

### 1.3. 理解のためのアナロジー

継承を理解するために、ECサイトの商品カテゴリの階層構造を考えてみましょう。「書籍 (Book)」は「商品 (Product)」の一種であり、「家電製品 (Electronics)」も「商品 (Product)」の一種です。どちらも商品としての共通の特性（価格を持つ、詳細情報を表示するなど）を継承しますが、それぞれ固有の特性（書籍なら著者名や出版社、家電製品ならメーカー名や保証期間など）を追加します。このように、共通の基盤の上に、それぞれの特化した性質を追加していくイメージが継承です。

### 1.4. 主要な用語：スーパークラスとサブクラス

継承関係において、基盤となるクラス、つまり継承される側のクラスを**スーパークラス (Superclass)** または親クラス、基底クラスと呼びます。

一方、スーパークラスから特性を受け継ぐクラスを**サブクラス (Subclass)** または子クラス、派生クラスと呼びます。

サブクラスはスーパークラスを**拡張 (extends)** すると表現され、スーパークラスの特性を継承し、さらに独自の特性を追加したり、継承した振る舞いを変更したりできます。

継承は単にコードの再利用手段であるだけでなく、現実世界や問題領域に見られる分類や特殊化の関係性をソフトウェア上でモデル化するための基本的な方法でもあります。オブジェクト指向プログラミングは現実世界の問題をモデル化することを目指しており、現実世界のエンティティはしばしば階層構造（例：商品 -\> 書籍 -\> 技術書）を形成します。継承はこの階層的な分類（「is-a」関係）を直接反映します。したがって、継承を理解し適切に利用することは、問題の構造を反映した、より直感的で（正しく使えば）保守性の高いソフトウェア設計につながります。これは、単に同じコードを何度も書く手間を省くという表面的な利点以上の意味を持ちます。

## 2\. Javaにおける継承の実装：`extends` キーワード

### 2.1. 構文：`extends`

Javaでクラス間の継承関係を確立するには、`extends` キーワードを使用します。基本的な構文は以下の通りです。

```java
// スーパークラス（親）
class SuperclassName {
    // フィールドとメソッド
}

// サブクラス（子）
class SubclassName extends SuperclassName {
    // 追加のフィールドやメソッド、またはメソッドのオーバーライド
}
```

この宣言により、`SubclassName` は `SuperclassName` の非privateなメンバーへアクセスできるようになります。

### 2.2. 具体的なコード例：`Product` と `Book`

具体的な例を見てみましょう。ECサイトの商品を表す `Product` クラスをスーパークラスとし、その一種である `Book` クラスをサブクラスとして定義します。（先の説明で出てきた`Electronics`クラスについては割愛します）

```java
// スーパークラス (商品全般)
class Product {
    protected String productId;  // 商品ID (サブクラスからもアクセスできるようprotected)
    protected String name;       // 商品名
    protected int price;         // 価格

    // コンストラクタ
    public Product(String productId, String name, int price) {
        this.productId = productId;
        this.name = name;
        this.price = price;
    }

    // 価格に消費税を加算するメソッド (共通の振る舞い)
    public int getPriceWithTax() {
        return (int) (this.price * 1.10); // 消費税10%として計算
    }

    // 商品情報を表示するメソッド (基本的な表示)
    public void displayDetails() {
        System.out.println("商品ID: " + this.productId);
        System.out.println("商品名: " + this.name);
        System.out.println("価格（税抜）: " + this.price + "円");
        System.out.println("価格（税込）: " + getPriceWithTax() + "円");
    }
}

// サブクラス (書籍)
class Book extends Product {
    private String author;     // 著者名 (Book固有)
    private String publisher;  // 出版社 (Book固有)

    // コンストラクタ
    public Book(String productId, String name, int price, String author, String publisher) {
        // スーパークラスのコンストラクタを呼び出し、共通のフィールドを初期化
        super(productId, name, price);
        this.author = author;
        this.publisher = publisher;
    }

    // Book固有の情報を追加して表示するように、スーパークラスのメソッドをオーバーライド
    @Override
    public void displayDetails() {
        super.displayDetails(); // まずスーパークラスの表示処理を呼び出す
        System.out.println("著者: " + this.author);
        System.out.println("出版社: " + this.publisher);
    }

    // Book固有のメソッド
    public String getAuthor() {
        return this.author;
    }
}

// 実行用クラス
public class EcSiteMain {
    public static void main(String[] args) {
        // Bookオブジェクトを作成
        Book myBook = new Book("B001", "Javaプログラミング実践", 3200, "佐々木一郎", "技術書典");

        // スーパークラスProductから継承したフィールドやメソッドを使用
        // (実際にはnameやpriceはコンストラクタ経由で設定、getPriceWithTaxはdisplayDetails内で使用)

        // オーバーライドされたdisplayDetailsメソッドを呼び出し
        myBook.displayDetails();
        // 出力例:
        // 商品ID: B001
        // 商品名: Javaプログラミング実践
        // 価格（税抜）: 3200円
        // 価格（税込）: 3520円
        // 著者: 佐々木一郎
        // 出版社: 技術書典

        // サブクラスBook固有のメソッドを呼び出し
        System.out.println("この本の著者は " + myBook.getAuthor() + " です。");
        // 出力例: この本の著者は 佐々木一郎 です。
    }
}
```

クラス図による図示


<div class="mermaid" style="margin:auto;">
classDiagram
  Product <|-- Book
  Product <|-- Electronics
  class Product {
    #String productId
    #String name
    #int price
    +Product(String productId, String name, int price)
    +int getPriceWithTax()
    +void displayDetails()
  }
  class Book {
    -String author
    -String publisher
    +Book(String productId, String name, int price, String author, String publisher)
    +void displayDetails()  // Override
    +String getAuthor()
  }
  class Electronics {
    - こちらは未実装
  }
</div>

`Book` クラスには `productId` フィールドや `getPriceWithTax()` メソッドは直接定義されていませんが、`Product` クラスから継承しているため、`myBook` オブジェクトはこれらのメンバー（間接的に）利用できます。また、`displayDetails()` は `Book` クラスでオーバーライド（再定義）され、書籍固有の情報も表示するようになっています。

### 2.3. 何が継承されるか？

  * スーパークラスの `public` および `protected` なメンバー（フィールドとメソッド）はサブクラスに継承され、サブクラスから直接アクセスできます。
  * スーパークラスの `private` なメンバーは、サブクラスのオブジェクト内に存在はしますが、サブクラスから直接アクセスすることは**できません**。これは、カプセル化の原則を維持するためです。
  * （補足）アクセス修飾子なし（デフォルト、パッケージプライベート）のメンバーは、同じパッケージ内のサブクラスにのみ継承されます。
  * 重要な点として、**コンストラクタは継承されません**。コンストラクタはクラス固有の初期化処理であり、そのまま引き継がれるものではありません。これは初心者が混乱しやすいポイントであり、次のセクションで詳しく説明します。

## 3\. 継承におけるコンストラクタ

### 3.1. コンストラクタの役割：初期化

まず、コンストラクタはオブジェクトが生成される際（例：`new ClassName()`）に呼び出され、そのオブジェクトの初期化を行う特別なメソッドであることを思い出しましょう。

### 3.2. 連鎖反応：スーパークラスコンストラクタの呼び出し

サブクラスのオブジェクトが生成されるとき、サブクラス自身のコンストラクタが実行される**前に**、必ずそのスーパークラスのコンストラクタが**先に**呼び出されます。

この呼び出しは継承階層を遡って行われます。
たとえば、クラスCがクラスBを継承し、クラスBがクラスAを継承している場合、`new C()` でオブジェクトを生成すると、A→B→Cの順でコンストラクタが呼び出されます。

以下の汎用的なコードは、この呼び出し順序を示しています。

```java
class A {
    A() {
        System.out.println("Aのコンストラクタが呼び出されました。");
    }
}

class B extends A {
    B() {
        // ここで暗黙的に super(); が呼び出される
        System.out.println("Bのコンストラクタが呼び出されました。");
    }
}

class C extends B {
    C() {
        // ここで暗黙的に super(); が呼び出される
        System.out.println("Cのコンストラクタが呼び出されました。");
    }

    public static void main(String[] args) {
        new C(); // Cのオブジェクトを生成
    }
}
```

シーケンス図による処理の流れの図示：

<div class="mermaid" style="margin:auto;">
sequenceDiagram
  participant User
  participant C_Constructor as new C()
  participant B_Constructor as B()
  participant A_Constructor as A()
  User->>C_Constructor: オブジェクト生成
  C_Constructor->>B_Constructor: super() (暗黙的)
  B_Constructor->>A_Constructor: super() (暗黙的)
  A_Constructor-->>B_Constructor: Aの初期化完了
  B_Constructor-->>C_Constructor: Bの初期化完了
  C_Constructor-->>User: Cの初期化完了、オブジェクト返却
</div>

実行結果：

```bash
Aのコンストラクタが呼び出されました。
Bのコンストラクタが呼び出されました。
Cのコンストラクタが呼び出されました。
```

### 3.3. デフォルトコンストラクタの暗黙的な呼び出し

サブクラスのコンストラクタ内で、明示的にスーパークラスのコンストラクタ呼び出し（`super(...)`）を記述しない場合、Javaコンパイラは自動的にスーパークラスの**引数なしのコンストラクタ**（デフォルトコンストラクタ）を呼び出す `super();` というコードをコンストラクタの先頭に挿入します。

**非常に重要な注意点：** もしスーパークラスに引数なしのコンストラクタが存在せず（たとえば、引数付きのコンストラクタしか定義されていない場合）、かつサブクラスのコンストラクタで明示的に `super(...)` を使ってスーパークラスの既存のコンストラクタを呼び出さない場合、**コンパイルエラー**が発生します。これは、Javaがスーパークラスの初期化を保証しようとするものの、呼び出すべき引数なしのコンストラクタが見つからないためです。

### 3.4. 明示的な呼び出し：`super()`

サブクラスのコンストラクタから、スーパークラスの特定のコンストラクタを明示的に呼び出すには、`super()` キーワードを使用します。

  * 構文：`super();`（引数なしコンストラクタを呼び出す）または `super(引数リスト);`（引数リストに一致するコンストラクタを呼び出す）。
  * **ルール：** `super(...)` の呼び出しは、もし記述する場合、サブクラスのコンストラクタ本体の**必ず最初のステートメント**でなければなりません。これは、サブクラス固有の初期化を行う前に、オブジェクトのスーパークラス部分が完全に初期化されている必要があるためです。

ECサイトの `Product` と `Book` の例で見てみましょう。`Product` クラスは引数付きのコンストラクタ `Product(String productId, String name, int price)` を持っています。

```java
// スーパークラス (再掲)
class Product {
    protected String productId;
    protected String name;
    protected int price;

    // 引数付きコンストラクタのみを持つ (デフォルトコンストラクタはない)
    public Product(String productId, String name, int price) {
        System.out.println("Productコンストラクタ呼び出し (ID: " + productId + ")");
        this.productId = productId;
        this.name = name;
        this.price = price;
    }
    // ... 他のメソッドは省略 ...
}

// サブクラス (再掲)
class Book extends Product {
    private String author;
    private String publisher;

    public Book(String productId, String name, int price, String author, String publisher) {
        // 明示的にスーパークラス Product のコンストラクタを呼び出す必要がある
        super(productId, name, price); // これがないとコンパイルエラー
                                       // (Productに引数なしコンストラクタがないため)
        System.out.println("Bookコンストラクタ呼び出し (著者: " + author + ")");
        this.author = author;
        this.publisher = publisher;
    }
    // ... 他のメソッドは省略 ...

    public static void main(String[] args) {
        new Book("B002", "Effective Java", 3500, "Joshua Bloch", "Pearson");
    }
}
```

実行結果（コンストラクタ呼び出し部分）：

```bash
Productコンストラクタ呼び出し (ID: B002)
Bookコンストラクタ呼び出し (著者: Joshua Bloch)
```

`super()` がコンストラクタの最初の文でなければならないという厳格なルールは、恣意的なものではありません。これは、継承におけるオブジェクト構築の重要な原則、すなわち「拡張部分を追加する前に、まず土台を構築しなければならない」という原則を強制するものです。サブクラスのオブジェクトは、その内部にスーパークラス型の「内部」オブジェクトを含んでいます。サブクラスの状態や振る舞いは、スーパークラスの状態が最初に適切に初期化されていることに依存する可能性があります（たとえば、サブクラスのメソッドが継承されたフィールドを使用する場合など）。`super()` の呼び出しを最初に強制することで、サブクラス固有の初期化が行われる前に、スーパークラス部分が完全に構築されることが保証されます。これにより、サブクラスのロジックが未初期化または不整合な状態のスーパークラスメンバーにアクセスしてしまう潜在的なエラーを防ぎ、階層を遡って安全で予測可能な初期化順序が保証されるのです。

## 4\. キーワード：`this` と `super`

### 4.1. `this`：現在のオブジェクトへの参照

`this` は、クラス自身のメソッドやコンストラクタ内から、**現在のオブジェクトインスタンス**（自分自身）を参照するための特別な参照変数です。

* 用途1：変数の曖昧さの解消
    - インスタンス変数（フィールド）とローカル変数（メソッドの引数など）が同じ名前を持つ場合に、両者を区別するために `this` を使用します。これはコンストラクタやセッターメソッドで非常によく見られるパターンです。

```java
class Product { // Productクラスの例
    private String name; // インスタンス変数

    // 引数 'name' がインスタンス変数 'name' を隠蔽（シャドーイング）
    public void setName(String name) {
        // 'this.name' でインスタンス変数を明示的に指す
        this.name = name;
    }
}
```

* 用途2：他のコンストラクタの呼び出し (`this(...)`)
  - 同じクラス内の別のコンストラクタを呼び出す（コンストラクタチェーン）ために `this(...)` を使用します。
  - **ルール：** `this(...)` の呼び出しは、コンストラクタ内の**最初のステートメント**でなければなりません。
  - 注意点：コンストラクタの最初のステートメントとして呼び出せるのは `this(...)` か `super(...)` のどちらか一方のみです（`this(...)` は、それが連鎖する先のコンストラクタで暗黙的または明示的に `super()` を呼び出すため）。

```java
class Item { // 汎用的な例
    String id;
    String name;

    // 基本となるコンストラクタ
    Item(String id, String name) {
        this.id = id;
        this.name = name;
    }

    // IDのみを指定するコンストラクタ（名前はデフォルト値）
    Item(String id) {
        // 上記のコンストラクタを呼び出す
        this(id, "Unnamed Item");
    }
}
```

### 4.2. `super`：スーパークラスへの参照

`super` は、サブクラス内から**スーパークラスのメンバー**（フィールドやメソッド）へアクセスするために使用されるキーワードです。

* **用途1：スーパークラスコンストラクタの呼び出し (`super(...)`)**
  セクション3で説明した通り、サブクラスのコンストラクタからスーパークラスのコンストラクタを呼び出すために使用します。（`Product` と `Book` の例を参照）
* **用途2：オーバーライドされたメソッドへのアクセス**
  サブクラスがスーパークラスのメソッドをオーバーライドした場合に、サブクラスのメソッド内から `super.メソッド名()` を使って、スーパークラスの元のメソッド実装を呼び出すことができます。（例はセクション5の `Book` クラスの `displayDetails` メソッドを参照）
* **用途3：隠蔽されたフィールドへのアクセス（非推奨）**
  サブクラスでスーパークラスと同じ名前のフィールドを定義した場合（フィールドの隠蔽）、`super.フィールド名` でスーパークラスのフィールドにアクセスできます。しかし、これはコードの混乱を招く可能性があるため、一般的には推奨されない使い方です。通常は `super` をメソッドやコンストラクタの呼び出しに使用します。

`this` と `super` は単なるキーワードではなく、オブジェクトの階層内における異なる**文脈的な視点**を表しています。`this` は「オブジェクト全体」の視点であり、`super` は「親クラスからの貢献」の視点です。サブクラスのオブジェクト（例：`myBook`）でメソッド（例：`getPriceWithTax()`）が呼び出された場合、たとえそのメソッドが継承されたものであっても、`getPriceWithTax()` 内の `this` は `Book` オブジェクト自身を指します。もし `Book` が `Product` の `displayDetails()` をオーバーライドし、その中で `super.displayDetails()` を呼び出した場合、`super` キーワードは `Book` オブジェクトの文脈から、とくに `Product` クラスの `displayDetails()` の実装をターゲットにします。この区別は、ポリモーフィズムや、オーバーライドされたメソッドが親バージョンとどのように相互作用するかを理解する上で極めて重要です。`this` は常に実行時の実際のオブジェクト型に解決されるのに対し、`super` は現在のクラスレベルから継承チェーンを「上方向」に直接辿るパスを提供します。

## 5\. メソッドのオーバーライド

### 5.1. 概念：特化した振る舞い

メソッドのオーバーライドとは、スーパークラスですでに定義されているインスタンスメソッドを、それを継承したサブクラスで独自に再定義（上書き）することです。

目的は、サブクラスが親から継承した振る舞いを変更または置換し、より特化した動作をさせることです。たとえば、`Product` クラスの `displayDetails()` メソッドは基本的な商品情報を表示しますが、`Book` サブクラスではこれに加えて著者名や出版社も表示するようにオーバーライドします。

### 5.2. オーバーライドのルール

メソッドを正しくオーバーライドするには、以下のルールに従う必要があります。

1.  サブクラスのメソッドは、スーパークラスのメソッドと**完全に同じ名前**を持つこと。
2.  サブクラスのメソッドは、スーパークラスのメソッドと**完全に同じパラメータリスト**（引数の数、型、順序）を持つこと。
3.  サブクラスのメソッドは、スーパークラスのメソッドと**同じ戻り値の型**を持つこと（または、その型のサブタイプであること。これは共変戻り値型と呼ばれますが、初心者向けには「同じ戻り値の型」と覚えておけば十分です）。
4.  サブクラスのメソッドの**アクセスレベル**は、スーパークラスのメソッドのアクセスレベルより**制限を厳しくすることはできません**（例：`public` を `private` にはできない）。しかし、**緩くすることは可能**です（例：`protected` を `public` にする）。

これらのルールを満たさない場合、オーバーライドではなく、新しいメソッドの定義（オーバーロードなど）と見なされます。

### 5.3. `@Override` アノテーション

`@Override` アノテーションは、メソッドの直前に記述し、そのメソッドがスーパークラスのメソッドをオーバーライドする意図であることをコンパイラと他の開発者に伝えるためのものです。

`@Override` を使用するメリット：

  * **コンパイル時のチェック：** メソッド名や引数の型などを誤って記述し、オーバーライドのルールを満たしていない場合、コンパイラがエラーを検出してくれます。これにより、タイプミスによる意図しないバグ（オーバーライドしたつもりが新しいメソッドを作ってしまった、など）を防ぐことができます。
  * **可読性の向上：** コードを読む人に対して、そのメソッドが意図的にスーパークラスのメソッドを上書きしていることを明確に伝えます。

必須ではありませんが、オーバーライドする際には**強く推奨**されます。（`Book` クラスの `displayDetails` メソッドの例を参照）

### 5.4. スーパークラスメソッドの呼び出し：`super.メソッド名()`

オーバーライドしたメソッド内から、`super.メソッド名()` を使用して、スーパークラスの元の実装を呼び出すことができます。これは、元の機能の一部を利用しつつ、追加の処理を行いたい場合によく使われます。

例（`Product` と `Book` の `displayDetails`）：

```java
class Product {
    // ... (productId, name, price, constructor, getPriceWithTax) ...
    public void displayDetails() {
        System.out.println("商品ID: " + this.productId);
        System.out.println("商品名: " + this.name);
        System.out.println("価格（税抜）: " + this.price + "円");
        System.out.println("価格（税込）: " + getPriceWithTax() + "円");
    }
}

class Book extends Product {
    private String author;
    private String publisher;

    public Book(String productId, String name, int price, String author, String publisher) {
        super(productId, name, price);
        this.author = author;
        this.publisher = publisher;
    }

    @Override // アノテーション推奨！
    public void displayDetails() {
        // まずスーパークラス（Product）のdisplayDetailsを実行
        super.displayDetails();
        // 次にBook固有の情報を追加
        System.out.println("著者: " + this.author);
        System.out.println("出版社: " + this.publisher);
    }

    public static void main(String[] args) {
        Book myBook = new Book("B003", "デザインパターン解説", 4000, "Erich Gamma", "Softbank Publishing");
        myBook.displayDetails();
    }
}
```

実行結果：

```bash
商品ID: B003
商品名: デザインパターン解説
価格（税抜）: 4000円
価格（税込）: 4400円
著者: Erich Gamma
出版社: Softbank Publishing
```

### 5.5. 制限：`final` メソッドと `static` メソッド

  * スーパークラスで `final` と宣言されたメソッドは、サブクラスで**オーバーライドすることはできません**。これは、サブクラスにそのメソッドの重要な振る舞いを変更させたくない場合に使用されます。
  * `static` メソッドはクラスに属し、インスタンスには属しません。そのため、`static` メソッドは**オーバーライドできません**（サブクラスで同じシグネチャの `static` メソッドを定義することはできますが、これは「隠蔽」または「再定義」と呼ばれ、ポリモーフィズムの対象となるオーバーライドとは異なります）。初心者向けには、`static` メソッドは通常の意味でのオーバーライドはされない、と理解しておけば良いでしょう。

## 6\. 継承の利点

継承を利用することには、いくつかの重要な利点があります。これらを `Product` とそのサブクラス（`Book`, `Electronics` など）の例で見てみましょう。

### 6.1. コードの再利用性

これはもっとも一般的に挙げられる利点です。共通の属性や振る舞いを一度スーパークラスに定義すれば、複数のサブクラスがそのコードを書き直すことなく再利用できます。
例：`Product` クラスで定義された `productId`, `name`, `price` といったフィールドや、`getPriceWithTax()` メソッドは、`Book` クラスや、もし作成するなら `Electronics`（家電）, `Clothing`（衣類）などのサブクラスでそのまま（あるいはコンストラクタ経由で初期化して）利用できます。

### 6.2. 拡張性

既存のクラスの機能を拡張して新しいクラスを作成することが容易になります。サブクラスは、継承した機能に加えて、新しいフィールドやメソッドを追加して、振る舞いを特化させることができます。
例：`Book` クラスは `Product` クラスを継承し、書籍固有の `author`（著者）フィールドや `getAuthor()` メソッド、そして出版社情報を追加しています。同様に `Electronics` クラスなら `brand`（ブランド）や `warrantyPeriod`（保証期間）を追加できます。

### 6.3. 保守性

スーパークラス内の共通コードに加えられた変更やバグ修正は、それを継承しているすべてのサブクラスに自動的に反映されます。これにより、更新作業の手間が削減され、保守性が向上します。
例：もし消費税率が変更になった場合、`Product` クラスの `getPriceWithTax()` メソッドの税率計算ロジックを修正するだけで、`Book`, `Electronics` など、すべての商品の税込価格計算が正しく更新されます。

### 6.4. ポリモーフィズム（多態性）

継承はポリモーフィズムを実現するための重要な手段です。ポリモーフィズムとは、スーパークラス型の参照変数で、そのサブクラス型のオブジェクトを扱えるという性質です。
例：`Product myItem = new Book("B001", "Java...", 3000, "...", "...");` や `Product anotherItem = new Electronics("E001", "Smart TV...", ...);` のように記述できます。

そして、スーパークラス型の参照変数を通じてメソッドを呼び出す（例：`myItem.displayDetails()`）と、実際に変数に格納されているオブジェクトの型（この場合は `Book`）で**オーバーライドされた**メソッドが実行されます。これにより、オブジェクトの種類に応じて異なる振る舞いをさせることができ、柔軟で動的なプログラムを作成できます。

```java
// ポリモーフィズムの例
public class PolymorphismExample {
    public static void main(String[] args) {
        Product product1 = new Book("B004", "Clean Code", 4500, "Robert C. Martin", "Prentice Hall");
        // Electronicsクラスの定義は省略 (2.2のProduct/Bookと同様に作成したと仮定)
        // Product product2 = new Electronics("E002", "Wireless Mouse", 5000, "Logitech", 24);

        // Product型として扱う
        Product[] cart = {
            product1,
            // product2, // Electronicsオブジェクトも同様に追加可能
            new Book("B005", "はじめてのプログラミング", 2000, "田中花子", "翔泳社")
        };

        for (Product item : cart) {
            System.out.println("----- カート内の商品情報 -----");
            item.displayDetails(); // 実際のオブジェクトの型に応じたdisplayDetailsが呼び出される
            System.out.println("共通の税込価格: " + item.getPriceWithTax() + "円");

            // instanceof で型を調べて固有のメソッドを呼び出すことも可能
            if (item instanceof Book) {
                Book bookItem = (Book) item; // キャストが必要
                System.out.println("この本の著者は: " + bookItem.getAuthor());
            }
            // if (item instanceof Electronics) { ... }
            System.out.println();
        }
    }
}
```

ポリモーフィズムは非常に強力な概念であり、通常は別の講義でより詳しく扱われますが、継承がそれを可能にする基盤であることを理解しておきましょう。

## 7\. 継承の欠点と注意点（重要なセクション）

継承は強力なツールですが、乱用するとさまざまな問題を引き起こす可能性があります。とくに以下の点に注意が必要です。

### 7.1. 密結合 (Tight Coupling)

`extends` を使用した継承は、サブクラスとスーパークラスの間に非常に強い結びつき（密結合）を生み出します。サブクラスは、スーパークラスの公開されたインターフェイス（メソッドシグネチャ）だけでなく、しばしばその**実装の詳細**にも依存するようになります。

これが問題となる理由は、スーパークラスの実装が変更されると（たとえ公開メソッドのシグネチャが変わらなくても）、その変更がサブクラスの動作を破壊する可能性があるためです。

### 7.2. 脆弱な基底クラス問題 (Fragile Base Class Problem)

これは密結合の直接的な結果です。スーパークラス（基底クラス）に対する一見安全そうな変更が、予期せずサブクラスの機能を壊してしまう可能性があるという問題です。

**概念的な例:**
（この例は汎用的なもので、元の資料のものを参考にしています）

1.  スーパークラス `CountingList` に `add()` と `addAll()` メソッドがあるとします。`addAll()` は内部的に `add()` を繰り返し呼び出すことで実装されています。要素が追加されるたびに内部カウンターを増やすとします。
2.  サブクラス `SpecialCountingList` は、特定の種類の要素が追加された場合にのみカウンターを増やすために `add()` メソッドをオーバーライドします。このサブクラスは、スーパークラスの `addAll()` がオーバーライドされた `add()` を（スーパークラスの実装通りに）呼び出すことに依存しています。
3.  後日、スーパークラスの作者が `addAll()` の効率を上げるために、内部実装を直接的な内部データ構造操作に変更し、`add()` を呼び出さなくなりました。
4.  すると、`SpecialCountingList` オブジェクトで `addAll()` を呼び出しても、オーバーライドされた `add()` がバイパスされるため、カウンターが期待通りに更新されなくなります。サブクラスは、スーパークラスの内部的な変更によって壊れてしまいました。

スーパークラスの作者は、すべてのサブクラスの存在や実装を知っているとは限らないため、スーパークラスの変更は常にリスクを伴います。

### 7.3. 複雑さと階層の問題

* 深い継承階層（例：A -\> B -\> C -\> D...）は、コードの理解やデバッグを困難にします。メソッド呼び出しや状態変化を追跡するには、複数のクラスをナビゲートする必要があります。
* 共通の基底クラスを共有する多くのサブクラスを持つ広い階層は、「神クラス (God Class)」問題を引き起こす可能性があります。スーパークラスが過度に多くの責任を負い、肥大化し、変更が困難になるのです。これは、クラスの責任を単一に保つべきという単一責任の原則（SRP: Single Responsibility Principle）に違反します。

### 7.4. 保守と仕様変更の問題

密結合と脆弱な基底クラス問題のため、確立されたシステムのスーパークラスを変更することは、リスクが高く時間のかかる作業になる可能性があります。変更の影響を受ける可能性のあるすべてのサブクラスに対して、広範なテストが必要になることがあります。

要求仕様が変更された場合、既存の継承構造が不適切になり、困難なリファクタリング（コードの再設計）を強いられることがあります。スーパークラスがサブクラスのニーズに合わせて頻繁に変更される必要がある場合、拡張に対しては開かれ、修正に対しては閉じているべきというオープン・クローズドの原則（OCP: Open-Closed Principle）がしばしば破られます。

### 7.5. 不要なメンバーの継承

サブクラスは、スーパークラスの非privateなメンバーを**すべて**継承します。サブクラスが必要とするのはスーパークラスの機能の一部だけである場合でも、不要なメソッドまで継承してしまい、そのサブクラスの文脈では意味をなさない、あるいは誤用される可能性のあるメソッドを公開してしまうことがあります。

例：`Product` クラスに、物理的な商品向けの `getShippingWeight()`（配送重量を取得する）メソッドがあったとします。もし、電子書籍を表す `EBook` クラスがこの `Product` クラスを継承した場合、`EBook` オブジェクトも `getShippingWeight()` メソッドを持つことになりますが、電子書籍に配送重量は通常ありません。このように、サブクラスにとって不適切な機能を継承してしまう可能性があります。
（元の資料にあった `Stack` が `ArrayList` を継承する例も、この問題を示す良い例です。スタックに不要な `add(index, element)` のようなメソッドを継承してしまいます。）

### 7.6. 可読性の問題

サブクラスの振る舞いを完全に理解するためには、しばしばそのスーパークラス（場合によってはさらにその上のクラス）のコードも読んで理解する必要があり、認知的な負荷が増加します。

継承の主な利点として挙げられるコードの再利用性（とくに**実装**の再利用）が、実はその主要な欠点（密結合、脆弱性）の根本原因でもあります。

`extends` を介した実装の再利用は、`implements` を介したインターフェイス（契約）の再利用よりも本質的にリスクが高いと言えます。なぜなら、`extends` は「何をするか」（メソッドシグネチャ、インターフェイス）と「どのようにするか」（メソッドの実装）の両方を継承するからです。
サブクラスは、たとえ公開メソッド（「何をするか」）を通じてのみ対話しているつもりでも、暗黙のうちにスーパークラスの「どのようにするか」（特定の実装詳細）に依存してしまうことがよくあります。
スーパークラスがその「どのようにするか」（内部実装）を変更すると、たとえ「何をするか」（公開インターフェイス）が同じままでも、古い「どのようにするか」に依存していたサブクラスは壊れてしまう可能性があるのです。
このことから、実装の継承（`extends`）は慎重に使用すべきであるといえます。
`extends`を使う際には、真の強い「is-a」関係が存在し、かつスーパークラスが安全な拡張のために明示的に設計されているか、非常に安定している場合に限定すべきであるという結論に至ります。

## 8\. Javaにおける継承の特殊な側面

Javaの継承には、言語特有のルールや特徴があります。

### 8.1. 単一クラス継承

Javaのクラスは、`extends` キーワードを使って直接継承できるスーパークラスは**一つだけ**です。これは単一継承と呼ばれます。

この制限は、複数のスーパークラスから競合する実装を継承した場合に生じる曖昧さ（「ダイヤモンド問題」と呼ばれる。C++など多重実装継承を許す言語で発生しうる）を回避するために設けられています。

Javaでは、複数の**インターフェイス**を実装すること（`implements` キーワード）は可能です。これが、異なるクラス階層にまたがってポリモーフィズムを実現するための主要な方法となります。

### 8.2. `final` クラス

`final` キーワードを付けて宣言されたクラスは、**サブクラス化（継承）することができません**。

```java
final class ImmutableProductData {
    //... このクラスは継承できない。たとえば不変性を保証したい場合など。
}

// class SpecialProductData extends ImmutableProductData {} // コンパイルエラー！
```

`final` クラスは、セキュリティ上の理由（例：Javaの `String` クラスは `final` です）や、クラスの実装がこれ以上変更されるべきではないことを保証したい場合に使用されます。

### 8.3. `Object` クラス：すべてのクラスの根源

クラス定義で明示的に `extends` を使用しない場合、そのクラスは暗黙的に `java.lang.Object` クラスを継承します。たとえば、私たちの `Product` クラスも、明示的に `extends` を書いていませんが、`Object` クラスを継承しています。

したがって、Javaの**すべての**クラスは、直接的または間接的に `Object` クラスを継承しています。`Object` クラスはJavaのクラス階層の頂点に位置します。

`Object` クラスから継承される共通のメソッド（例：`toString()`, `equals()`, `hashCode()` など）があり、これらはしばしばサブクラスでオーバーライドされます。

## 9\. 継承 vs. 代替策：適切な選択

継承は選択肢の1つであり、常に最良の解決策とは限りません。他の設計アプローチと比較検討することが重要です。

### 9.1. リトマス試験：「is-a」 vs. 「has-a」

継承を使用する主な判断基準は、サブクラスがスーパークラスの**真の「is-a」**（〜は〜の一種である）関係にあるかどうかです。
もし関係性が「has-a」（〜は〜を持つ）や「uses-a」（〜は〜を使う）に近い場合は、通常、**コンポジション（合成）**の方が適しています。

例：

* 「書籍 (Book)」は「商品 (Product)」の一種である (`Book` **is a** `Product`) -\> 継承が適切かもしれない。
* 「注文 (Order)」は複数の「商品 (Product)」を持つ (`Order` **has** `Product`s) -\> コンポジションが適切（`Order` クラスが `Product` オブジェクトのリストを内部に保持する）。
* 「商品 (Product)」は「レビュー (Review)」情報を持つ (`Product` **has** `Review`s) -\> コンポジションが適切（`Product` クラスが `Review` オブジェクトのリストを内部に保持する）。

### 9.2. コンポジション／デリゲーション：推奨される代替策

* **コンポジション（合成）：** あるクラスが、機能を提供するために他のクラスのインスタンスを内部に保持するように設計すること。
* **デリゲーション（委譲）：** 保持しているクラスが、特定のタスクを実行するために、内部に保持している別のクラスのインスタンスのメソッドを呼び出すこと。

コンポジション／デリゲーションの利点：

* **疎結合 (Loose Coupling):** 委譲先のクラスのインターフェイスが安定していれば、その内部実装が変更されても、保持しているクラスが壊れる可能性は低くなります。
* **柔軟性：** 内部で保持するインスタンスを実行時に（潜在的に）切り替えることが可能です。
* **責任の明確化：** 不要なメソッドを継承することがなく、クラスの責務が明確になります。

概念例：`Product` クラスが、税金計算ロジックを、内部に保持する `TaxCalculator` オブジェクトへ委譲する。これにより、税計算ロジックの変更が `TaxCalculator` のみに限定されたり、異なる税計算ルール（国別など）を `TaxCalculator` の実装を差し替えることで対応できるようになります。

### 9.3. インターフェイス：契約の定義

インターフェイス (`interface`) は、クラスが実装すべきメソッドの**契約（何をすべきか）**を定義しますが、その実装（どのようにするか）は提供しません。

クラスはインターフェイスを `implements` キーワードを使って実装します。1つのクラスが複数のインターフェイスを実装することも可能です。

利点：実装の継承に伴う密結合なしでポリモーフィズムと抽象化を実現できます。しばしばコンポジションと組み合わせて使用されます。
たとえば、`Discountable`（割引可能）というインターフェイスを定義し、`Product` や `Book` がそれを実装することで、さまざまな商品に共通の割引処理を適用できるようになります。

### 9.4. 比較表：継承 vs. コンポジション／デリゲーション

以下の表は、継承とコンポジション／デリゲーションの主な違いをまとめたものです。どちらのアプローチを選択すべきか判断する際の助けとなります。

| 特徴 | 継承 (`extends`) | コンポジション／デリゲーション (`has-a`) |
| ---------------- | -------------------------------------- | ------------------------------------------------- |
| **関係性** | 「is-a」（特殊化） | 「has-a」／「uses-a」（協調） |
| **結合度** | 密結合（実装に依存） | 疎結合（理想的にはインターフェイスに依存） |
| **柔軟性** | 低い（コンパイル時に固定） | 高い（実行時に実装を変更可能） |
| **コード再利用** | 実装の自動的な再利用 | 包含オブジェクトのメソッド呼び出しによる再利用 |
| **ポリモーフィズム** | スーパークラス参照により直接実現 | インターフェイスにより実現（より柔軟） |
| **脆弱性** | 高い（脆弱な基底クラス問題） | 低い |
| **使用場面** | 真の「is-a」、安定した基底、フレームワーク | 他のほとんどの場合、柔軟性が必要な場合 |

この比較表は、2つの基本的なアプローチを直接対比させることで、それぞれのトレードオフを明確にします。とくに、「コンポジションを継承より優先する」という設計原則の根拠を理解するのに役立ちます。結合度、柔軟性、「is-a」対「has-a」といった重要な概念の違いを視覚的に整理し、より適切な設計判断を下すための指針となります。

## 10\. まとめとベストプラクティス

### 10.1. 主要概念の再確認

* **継承:** `extends` キーワードを使い、スーパークラスからサブクラスへ特性を引き継ぐ仕組み。（例：`Product` と `Book`）
* **コンストラクタ:** サブクラス生成時にはスーパークラスのコンストラクタが先に呼ばれる。`super()` で明示的に呼び出す。（例：`Book` のコンストラクタ内の `super(...)`）
* **`this` と `super`:** `this` は自オブジェクト、`super` はスーパークラスへの参照。
* **オーバーライド:** `@Override` アノテーションを使い、スーパークラスのメソッドをサブクラスで再定義する。（例：`Book` の `displayDetails` メソッド）
* **Javaの特性:** 単一クラス継承、`final` クラス（継承不可）、すべてのクラスは `Object` を継承。

### 10.2. 黄金律：コンポジションを継承より優先する

オブジェクト指向設計における一般的な原則として、「**実装の継承（`extends`）よりもコンポジション／デリゲーションを優先する**」というものがあります。

その理由はコンポジションの方が一般的に、より柔軟で保守しやすく結合度の低い（疎結合な）設計につながるためです。

### 10.3. 継承が適切な場合

とはいえ、継承が有用で適切な場面も存在します。

  * サブクラスとスーパークラスの間に、明確で安定した「is-a」関係がある場合。（例：「書籍 (Book)」は「商品 (Product)」の一種）
  * 継承パターンに依存するフレームワーク内で設計する場合。
  * スーパークラスが、拡張されることを意図して特別に設計され、その使用方法が文書化されている場合。

### 10.4. 最後に

`extends` を使う前に、クラス間の関係性を批判的に考えることが重要です。

単にコードを再利用したいという理由だけで安易に継承を選ぶのではなく、コンポジションやインターフェイスといった他の選択肢も検討しましょう。
目標は、単に動作するコードを書くだけでなく、明確で保守しやすく変更に強いコードを書くことです。
そのためには、継承を慎重に用い、コンポジションやインターフェイスといったテクニックを適切に組み合わせることが求められます。

