---
title: "クラスの書き方とメンバ"
---

>オブジェクト指向プログラミングおよび演習1 第３回

## 1. はじめに - 手続き型からオブジェクト指向

皆さんが学んできたC言語は、主に**手続き型プログラミング** という考え方に基づいています。
これは、プログラムを「手順（関数）」の集まりとして捉え、データを関数に渡して処理する手法です。

一方、Javaは**オブジェクト指向プログラミング (OOP)** を中心とした言語です。
OOPはプログラムを、**オブジェクト** の集まりとして捉えます。
それぞれのオブジェクトは、各々の**データ（状態）** と、そのデータを操作する**手続き（振る舞い・機能）** をまとめて扱います。

### なぜオブジェクト指向なのか

* 現実世界のモデリング:「顧客」「商品」「注文」のように、現実世界の概念をそのままプログラムの構成要素（オブジェクト）として表現しやすいため、設計が直感的になります。
* 再利用性の向上: 一度作成したクラス（オブジェクトの設計図）は、使い回すことができます。たとえば、「商品」クラスを作れば、在庫管理システムでも、販売システムなどの他のシステムでも利用できます。
* 保守性の向上: データとそれに関連する操作がクラス内にまとまっている（これを**カプセル化**と言います）ため、変更の影響範囲を特定しやすく、修正や機能追加が容易になります。バグが特定のクラス内に限定されやすくなります。
* 分業のしやすさ: 大規模なシステム開発において、クラス単位で開発を分担しやすくなり、適切なカプセル化により、効率の良い開発を進められます。

C言語の手続き型でも大抵のアプリケーションは作成できますが、複雑で大規模なシステムを構築する場合において、オブジェクト指向のアプローチが有効になる場面が多くあります。

## 2. クラスとオブジェクト - お店の商品を例に

オブジェクト指向の基本的な構成要素が「クラス」と「オブジェクト」です。

お店の商品管理を例に考えてみましょう。


### C言語の構造体とJavaのクラス

C言語では、商品のデータを構造体で定義し、そのデータを操作する関数を別途用意していました。

```c
#include <stdio.h>
#include <string.h>

// C言語: データと操作は別々
struct Product {
    char name[50];
    int price;
    int stock;
};

// 在庫があるか確認する関数
int C_isInStock(struct Product *p) {
    return p->stock > 0;
}

int main() {
    struct Product apple;
    strcpy(apple.name, "Apple");
    apple.price = 150;
    apple.stock = 50;

    if (C_isInStock(&apple)) { // 関数にデータを渡してチェック
        printf("%s is in stock.\n", apple.name);
    }
    return 0;
}
```

Javaでは、これらをクラスとして一体化します。
（便宜上1つにまとめて書いていますが、それぞれのクラスを`Product.java`,`Shop.java`の2つのファイルでわけて書いてください。）

```java
// Java: データ(フィールド)と操作(メソッド)がクラス内にまとまる
public class Product {
    String name;
    int price;
    int stock;

    // 在庫があるか確認するメソッド
    boolean isInStock() {
        // this.stock は、このメソッドが呼び出されたオブジェクト自身の stock フィールドを指す
        return this.stock > 0;
    }

    // 現在の状態を表示するメソッド
    void displayInfo() {
        System.out.println("商品名: " + this.name + ", 価格: " + this.price + "円, 在庫: " + this.stock + "個");
    }
}

public class Shop {
    public static void main(String[] args) {
        // Product クラスから apple オブジェクトを生成
        Product apple = new Product();
        apple.name = "りんご";
        apple.price = 150;
        apple.stock = 50;

        // オブジェクト自身が持つメソッドを呼び出す
        if (apple.isInStock()) {
            System.out.println(apple.name + " は在庫があります。");
        }
        apple.displayInfo();
    }
}
```

Javaのアプローチでは、`apple` というオブジェクト自身が `isInStock()` という「在庫確認能力」を持っている、というより管理しやすい形でプログラムを表現できます。

商品自体に在庫管理能力を持たせるべきか、商品を管理する別のクラスを作成してそちらで在庫管理を行わせるか、こういった組み合わせを考える作業を **設計** と呼びます。

設計は正解がなく、状況に応じて最適な選択を行う必要があります。オブジェクト指向でプログラミングを行う場合、もっとも難しいと思われる部分です。
すぐに良い設計を思い浮かぶことはないと考えて、より良い設計はないかを意識しましょう。


### クラス (Class): 商品情報の「テンプレート」

クラスは、同じ種類のモノが共通して持つべき情報（状態や属性）と、できること（機能）を定義した「設計図」や「テンプレート」をイメージしてください。

例:  
お店にはさまざまな商品がありますが、「商品」というカテゴリで共通して「商品名」「価格」「在庫数」といった情報を持っています。また、「価格を表示する」「在庫があるか確認する」といった共通の操作が考えられます。この共通の定義をまとめたものが `Product` クラスです。

C言語との比較:  
C言語の構造体 (`struct`) は、関連するデータをまとめるものでした。
Javaのクラスは、これらのデータ（**フィールド**）に加えて、そのデータを扱う**手続き（メソッド）**、たとえば `displayPrice()` や `isInStock()` といった関数に相当するものも一緒にクラス内で定義します。これが大きな違いです。

### オブジェクト (Object): 具体的な「商品」そのもの

オブジェクトは、クラスという設計図に基づいて、メモリ上に実際に作成された「実体」です。インスタンス (Instance) とも呼ばれます。

例:  
`Product` クラス（設計図）から、「りんご（商品名: "りんご", 価格: 150, 在庫数: 50）」という具体的な商品オブジェクトや、「みかん（商品名: "みかん", 価格: 100, 在庫数: 80）」という別の商品オブジェクトを作成します。

オブジェクトの生成（インスタンス化）は`new`というキーワードを使って、クラスからオブジェクトを生成します。  
`Product apple = new Product();` のように書きます。

### カプセル化： データと操作をひとまとめにする利点

クラスによって、関連性の高いデータ（フィールド）とそれを操作する手続き（メソッド）が1つの単位にまとめられます。これを**カプセル化**と呼びます。

* **安全性:** 外部から直接フィールドを不正に変更されることを防ぎ、メソッドを通じてのみ操作させるように制限できます（アクセス修飾子 `private` などを使いますが、ここでは概念だけ説明します）。これにより、データの整合性を保ちやすくなります。
* **独立性:** クラス内部の仕組みを変更しても、外部への影響を最小限に抑えられます。たとえば、価格の計算方法が変わっても、`displayPrice()` メソッドの呼び出し方は変わらないように作れます。

#### 【練習】クラスの使い方を練習してみよう

##### 1. データの追加

上記のサンプルプログラムにて、リンゴのデータに加え、「name:みかん , price:80 , stock:200」となるように新しいオブジェクトをお店に追加してみましょう。

##### 2. 配列化

さらに、複数のデータを配列化し、多くの商品データを登録、登録されたデータの在庫をすべて表示するプログラムを考えてみましょう。


## 3. フィールドとメソッド - 商品の情報とできること

クラスの具体的な中身（メンバ）である「フィールド」と「メソッド」について、もう少し詳しく見ていきましょう。

### フィールド (Field): 商品の「状態」や「属性」

オブジェクトが持つべき具体的な**データ**を保持します。
管理対象となるオブジェクトの「状態」や「属性」を表します。

フィールドは、クラス内で変数を宣言することで定義します。

* 例（`Product` クラスの場合）
    * `String name;` // 商品名（文字列型）
    * `int price;` // 価格（整数型）
    * `int stock;` // 在庫数（整数型）

クラスを元に生成されたオブジェクト（インスタンス）は、それぞれ独自のフィールドに各々の値を持ちます。

### メソッド (Method): 商品の「機能」や「振る舞い」

オブジェクトが行える**操作**や**処理**を定義し、オブジェクトの「機能」や「振る舞い」を表します。

クラス内に関数を定義するような形で記述します。

* 例
    * フィールドの値を参照する（例: `getPrice()`, `getName()`）。
    * フィールドの値を変更する（例: `reduceStock(int amount)`, `setPrice(int newPrice)`）。
    * 特定の計算や処理を行う（例: `calculateTaxIncludedPrice()` 税込み価格を計算する）。
    * 情報を表示する（例: `displayInfo()`）。

#### `this` キーワード
メソッド内では、`this` というキーワードを使うことで、そのメソッドを呼び出している**オブジェクト自身**を参照できます。

`this.name` は「このオブジェクトの `name` フィールド」、`this.displayInfo()` は「このオブジェクトの `displayInfo` メソッド」を意味します。

多くの場合、フィールド名がメソッド内のローカル変数と衝突しなければ `this` は省略可能ですが、明示的につけることでコードが読みやすくなることもあります（とくににコンストラクタや値をフィールドに設定する目的のセッターメソッドでよく使われます）。

### `Product` クラスの例

```java
public class Product {
    String name;
    int price;
    int stock;

    // 在庫があるか確認するメソッド
    boolean isInStock() {
        return this.stock > 0;
    }

    // 現在の状態を表示するメソッド
    void displayInfo() {
        System.out.println("商品名: " + this.name + ", 価格: " + this.price + "円, 在庫: " + this.stock + "個");
    }

    // 価格をメッセージ形式で表示するメソッド
    void displayPrice() {
        System.out.println(this.name + " の価格は " + this.price + "円です。");
    }

    // 商品を売るメソッド (在庫を減らす)
    // amount: 売る数量
    void sell(int amount) {
        if (this.stock >= amount) {
            this.stock -= amount; // this.stock = this.stock - amount; と同じ
            System.out.println(this.name + " を " + amount + "個販売しました。残り在庫: " + this.stock);
        } else {
            System.out.println("エラー: " + this.name + " の在庫が足りません。(在庫: " + this.stock + ", 要求: " + amount + ")");
        }
    }

    // 在庫を補充するメソッド
    void restock(int amount) {
        this.stock += amount;
        System.out.println(this.name + " を " + amount + "個入荷しました。現在の在庫: " + this.stock);
    }
}

public class ShopInventory {
    public static void main(String[] args) {
        Product pencil = new Product();
        pencil.name = "鉛筆";
        pencil.price = 80;
        pencil.stock = 100;

        pencil.displayPrice(); // 鉛筆 の価格は 80円です。

        if (pencil.isInStock()) {
            System.out.println(pencil.name + " は在庫があります。");
        }

        pencil.sell(30); // 鉛筆 を 30個販売しました。残り在庫: 70
        pencil.sell(80); // エラー: 鉛筆 の在庫が足りません。(在庫: 70, 要求: 80)
        pencil.restock(50); // 鉛筆 を 50個入荷しました。現在の在庫: 120
        pencil.sell(80); // 鉛筆 を 80個販売しました。残り在庫: 40
    }
}
```

このように、フィールド（データ）とメソッド（操作）が一体となることで、「商品」オブジェクトが自身の情報に基づいて振る舞う、より現実に近いモデルをプログラムで表現できます。


## 4. コンストラクタ - 初期化する

クラスから `new` を使ってオブジェクトを生成するとき、そのオブジェクトのフィールド（たとえば、商品の名前や価格）に初期値を設定したい場合がほとんどです。

毎回 `apple.name = "りんご"; apple.price = 150;` のように手動で設定するのは手間ですし、設定し忘れる可能性もあります。

そこで登場するのが**コンストラクタ (Constructor)** です。

コンストラクタは、`new` でオブジェクトが生成される**直後に自動的に呼び出される**特別なメソッドです。
主な目的は、オブジェクトの**フィールドを初期化**することで、オブジェクトが利用可能な状態（適切な初期状態）になることを保証することです。

* なぜ必要か？:
    * **初期値の保証:** オブジェクト生成時に、フィールドが必ず意味のある値で初期化されるように強制できます（例: 価格が未設定のまま商品が作られるのを防ぐ）。
    * **必須情報の指定:** オブジェクトを作るために最低限必要な情報（例: 商品名と価格）を、生成時に引数として渡すように要求できます。
    * **定型的な初期化処理:** オブジェクト生成時に毎回行う必要のあるセットアップ処理（例: IDの自動採番、関連オブジェクトの生成など）を記述できます。
* 書き方のルール:
    1.  メソッド名は、**クラス名と完全に同じ**にする。
    2.  **戻り値の型（`void` など）を記述しない**。（戻り値を返せない）

### 特殊な**デフォルトコンストラクタ**

もしクラス内にコンストラクタを1つも定義しない場合、Javaコンパイラが「引数なし、中身が空のコンストラクタ」（デフォルトコンストラクタ）を自動的に生成します。

しかし、自分で1つでもコンストラクタを定義すると、このデフォルトコンストラクタは自動生成されなくなります。

### コンストラクタの例 (`Product` クラス):

```java
public class Product {
    String name;
    int price;
    int stock;

    // コンストラクタ (商品名と価格を引数で受け取り初期化)
    Product(String productName, int productPrice) {
        System.out.println("Productコンストラクタ(String, int) 呼び出し中...");
        // フィールド名と引数名が同じなので、this を使ってフィールドであることを明示
        this.name = productName;
        this.price = productPrice;
        this.stock = 0; // 在庫は初期状態で0にしておく
        System.out.println("商品「" + this.name + "」を価格" + this.price + "円で登録しました。");
    }

    // コンストラクタのオーバーロード (商品名、価格、初期在庫数を引数で受け取る)
    Product(String productName, int productPrice, int initialStock) {
        System.out.println("Productコンストラクタ(String, int, int) 呼び出し中...");
        this.name = productName;
        this.price = productPrice;
        this.stock = initialStock; // 引数で受け取った初期在庫を設定
        System.out.println("商品「" + this.name + "」を価格" + this.price + "円、初期在庫" + this.stock + "個で登録しました。");
    }

    // ... (他のメソッドは省略) ...

}

public class ShopSetup {
    public static void main(String[] args) {
        // コンストラクタを使ってオブジェクトを生成＆初期化
        // new Product(...) の時点でコンストラクタが呼ばれる
        Product orange = new Product("オレンジ", 120); // 1つ目のコンストラクタが呼ばれる
        Product banana = new Product("バナナ", 100, 50); // 2つ目のコンストラクタが呼ばれる

        System.out.println("--- 商品情報 ---");
        orange.displayInfo();
        banana.displayInfo();

        // Product grape = new Product(); // これはエラー！
        // 理由：引数ありのコンストラクタを定義したため、
        //      引数なしのデフォルトコンストラクタは自動生成されなくなった。
        //      もし引数なしでも生成したい場合は、引数なしのコンストラクタも自分で定義する必要がある。
    }
}
```

### 実行結果:

```bash
Productコンストラクタ(String, int) 呼び出し中...
商品「オレンジ」を価格120円で登録しました。
Productコンストラクタ(String, int, int) 呼び出し中...
商品「バナナ」を価格100円、初期在庫50個で登録しました。
--- 商品情報 ---
商品名: オレンジ, 価格: 120円, 在庫: 0個
商品名: バナナ, 価格: 100円, 在庫: 50個
```

### コンストラクタのオーバーロード

上記の例のように、同じクラス内に**引数の型、数、または並び順が異なる**複数のコンストラクタを定義できます。

これを**オーバーロード (Overload)** と呼びます。
これにより、オブジェクトの生成方法にバリエーションを持たせることができます（例: 初期在庫を指定する場合としない場合など、どちらにも対応可能）。

オーバーロードはカプセル化の際に重要な役割を持ちます。
次回以降の解説になりますが、コンストラクタの他に、通常のメソッドもオーバーロードを実現できます。


## まとめ

Javaのクラスは、「C言語の構造体に関数を内包できるようにしたもの」と覚えておくとよいでしょう。

クラス設計のポイントは、どのデータ（状態）とそれに対するメソッド（機能）をどうやってまとめて管理するか、をしっかりと考えることです。

設計から学ぶことはそれなりに難易度が高いので、プログラムの書き方をきちんと覚えつつ、どのように管理するかを継続的に考えましょう。

