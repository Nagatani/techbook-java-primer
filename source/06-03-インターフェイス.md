---
title: インターフェイス
---

> オブジェクト指向プログラミングおよび演習1 第6回  
>  
> インターフェイス、多重継承、そして堅牢なシステム設計への応用

## 1\. インターフェイス(interface)とは？ なぜ必要なのか？

### 1.1. 抽象化のその先へ：インターフェイスの核心

抽象クラスをさらに抽象化し「**型**」だけを定義するメカニズム、それがインターフェイスです。
インターフェイスには、**定数**と **メソッドのシグネチャ（名前、引数、戻り値の型）** を定義します。メソッドの具体的な処理内容は記述しません（Java 8以降の`default`メソッドを除く）。

**インターフェイスを実装(implements)するクラスは、インターフェイスで定義されたすべての抽象メソッドを具体的に実装する責任を負います。** これにより、インターフェイスは実装クラスに対して特定の振る舞いを強制する「**契約(Contract)**」としての役割を果たします。

### 1.2. インターフェイスが解決する課題：具体例で学ぶ

#### シナリオ：さまざまな決済手段を扱うシステム

ECサイトを開発しているとしましょう。顧客はクレジットカード、銀行振込、電子マネーなど、さまざまな方法で支払いができます。これらの決済手段をシステムで統一的に扱うにはどうすれば良いでしょうか？

```java
// 課題：決済手段ごとに処理がバラバラ
class CreditCardProcessor {
    public void processCreditPayment(double amount) {
        System.out.println(amount + "円をクレジットカードで処理しました。");
    }
}

class BankTransferProcessor {
    public void executeBankTransfer(double amount) {
        System.out.println(amount + "円を銀行振込で処理しました。");
    }
}

class EwalletProcessor {
    public void payWithEwallet(double amount) {
        System.out.println(amount + "円を電子マネーで処理しました。");
    }
}

// 利用側のコード
public class Shop {
    public void checkout(Object paymentProcessor, double totalAmount) {
        if (paymentProcessor instanceof CreditCardProcessor) {
            ((CreditCardProcessor) paymentProcessor).processCreditPayment(totalAmount);
        } else if (paymentProcessor instanceof BankTransferProcessor) {
            ((BankTransferProcessor) paymentProcessor).executeBankTransfer(totalAmount);
        } else if (paymentProcessor instanceof EwalletProcessor) {
            ((EwalletProcessor) paymentProcessor).payWithEwallet(totalAmount);
        }
        // 新しい決済手段が増えるたびに、ここのif-else文を修正する必要がある...
    }
}
```

上記のコードでは、決済手段が増えるたびに`Shop`クラスの`checkout`メソッドを修正する必要があります。これは変更に弱く、拡張性の低い設計です。

#### インターフェイスによる解決策

ここでインターフェイス`PaymentStrategy`を定義します。

```java
// 解決策：決済インターフェイスを定義
interface PaymentStrategy {
    void pay(double amount); // 支払う、という共通の「振る舞い」を定義
}

// 各決済手段クラスがPaymentStrategyインターフェイスを実装
class CreditCardPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println(amount + "円をクレジットカードで処理しました。");
    }
}

class BankTransferPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println(amount + "円を銀行振込で処理しました。");
    }
}

class EwalletPayment implements PaymentStrategy {
    @Override
    public void pay(double amount) {
        System.out.println(amount + "円を電子マネーで処理しました。");
    }
}

// 利用側のコードがシンプルに！
public class Shop {
    public void checkout(PaymentStrategy paymentMethod, double totalAmount) {
        // どんな決済手段クラスのインスタンスが来ても、同じ pay メソッドを呼び出せる！
        paymentMethod.pay(totalAmount);
    }

    public static void main(String[] args) {
        Shop shop = new Shop();
        PaymentStrategy creditCard = new CreditCardPayment();
        PaymentStrategy bankTransfer = new BankTransferPayment();
        PaymentStrategy eWallet = new EwalletPayment();

        System.out.println("--- クレジットカード決済 ---");
        shop.checkout(creditCard, 5000);

        System.out.println("\n--- 銀行振込決済 ---");
        shop.checkout(bankTransfer, 12000);

        System.out.println("\n--- 電子マネー決済 ---");
        shop.checkout(eWallet, 300);

        // 新しい決済手段（例：ポイント払い）が登場しても、
        // PaymentStrategyを実装したクラスを作るだけで、Shopクラスの修正は不要！
        // class PointPayment implements PaymentStrategy { /* ... */ }
        // PaymentStrategy pointPayment = new PointPayment();
        // shop.checkout(pointPayment, 100);
    }
}
```

インターフェイス`PaymentStrategy`を導入することで、`Shop`クラスは具体的な決済手段クラス（`CreditCardPayment`など）を知らなくても、`PaymentStrategy`型として統一的に扱えるようになりました。これを **ポリモーフィズム（多態性）** と呼びます。
新しい決済手段が増えても、`PaymentStrategy`インターフェイスを実装したクラスを追加するだけで対応でき、`Shop`クラスの修正は不要です。
これにより、**疎結合で拡張性の高い**システムが実現できます。

### 1.3. 「インターフェイスを作る」ということは「仕様」を決定すること

前述の通り、「インターフェイスを作る」ということは、それを実装するクラスに「〇〇というメソッドを持っており、実行すると✕✕という結果が期待できる」という **公開仕様（API: Application Programming Interfaceの一部とも言える）** を定義することと等しいです。

インターフェイスは、クラスがどのような振る舞いを持つべきかを規定する設計図であり、オブジェクト指向設計において非常に重要な役割を担います。

## 2\. Javaのインターフェイス：基本構文と機能

### 2.1. `interface`定義構文

インターフェイスを定義するには、`class`キーワードの代わりに`interface`キーワードを使用します。

```java
package jp.ac.ait.payment; // パッケージ宣言

// public: どこからでもアクセス可能
// interface: インターフェイスであることを示す
// Payable: インターフェイス名
public interface Payable {

    // 定数フィールド (暗黙的に public static final)
    String CURRENCY = "JPY"; // 日本円を表す通貨コード
    double MAX_AMOUNT = 1000000.00; // 1回の支払い上限額

    // 抽象メソッド (暗黙的に public abstract)
    // 戻り値の型: boolean (支払いが成功したかどうか)
    // メソッド名: processPayment
    // 引数: double amount (支払金額)
    boolean processPayment(double amount);

    // 別の抽象メソッド
    String getPaymentStatus(String transactionId);
}
```

#### ポイント：

  * インターフェイス内のフィールドは、自動的に`public static final`（定数）として扱われます。明示的に修飾子を記述する必要はありません。
  * インターフェイス内のメソッド（`default`メソッド、`static`メソッドを除く）は、自動的に`public abstract`（抽象メソッド）として扱われます。メソッド本体（`{}`ブロック）を持つことはできません。

### 2.2. `interface`実装構文 (`implements`)

クラスがインターフェイスを実装するには、`implements`キーワードを使用します。

```java
package jp.ac.ait.payment.impl;

import jp.ac.ait.payment.Payable; // Payableインターフェイスをインポート

// CreditCardProcessorクラスがPayableインターフェイスを実装する
public class CreditCardProcessor implements Payable {

    private String cardNumber;
    private String expiryDate;

    public CreditCardProcessor(String cardNumber, String expiryDate) {
        this.cardNumber = cardNumber;
        this.expiryDate = expiryDate;
    }

    // Payableインターフェイスの抽象メソッドをオーバーライドして実装
    @Override
    public boolean processPayment(double amount) {
        if (amount > Payable.MAX_AMOUNT) { // インターフェイスの定数を参照
            System.out.println("エラー: 支払い上限額を超えています。(" + amount + Payable.CURRENCY + ")");
            return false;
        }
        // ここにクレジットカード決済処理を記述 (例: 外部API呼び出し)
        System.out.println(amount + Payable.CURRENCY + " をクレジットカード (" + cardNumber + ") で処理しました。");
        return true;
    }

    @Override
    public String getPaymentStatus(String transactionId) {
        // ここに取引IDに基づく決済状況の取得処理を記述
        return "取引ID: " + transactionId + " の決済は完了しています。";
    }

    // CreditCardProcessorクラス独自のメソッド
    public void displayCardDetails() {
        System.out.println("カード番号: " + cardNumber + ", 有効期限: " + expiryDate);
    }
}
```

#### ポイント：

* インターフェイスを実装するクラスは、そのインターフェイスが持つ**すべての抽象メソッドをオーバーライド（実装）しなければなりません。** しない場合、コンパイルエラーとなります。
* `@Override`アノテーションは、メソッドがスーパークラスまたはインターフェイスのメソッドを正しくオーバーライドしていることをコンパイラに伝えるもので、記述を推奨します。

### 2.3. 複数のインターフェイスを実装する

Javaのクラスは、単一のクラスしか継承できません（単一継承）が、 **複数のインターフェイスを実装する（多重実装）ことは可能** です。これにより、クラスにさまざまな役割や能力を持たせることができます。

```java
package jp.ac.ait.devices;

// データをログに記録する機能を提供するインターフェイス
interface Loggable {
    void log(String message);
}

// 設定を読み書きする機能を提供するインターフェイス
interface Configurable {
    void loadConfiguration(String filePath);
    String getSetting(String key);
}

// LoggableとConfigurableの両方を実装するクラス
class AdvancedDevice implements Loggable, Configurable {

    @Override
    public void log(String message) {
        System.out.println("[LOG] " + message);
    }

    @Override
    public void loadConfiguration(String filePath) {
        System.out.println(filePath + " から設定を読み込みました。");
        // 実際の読み込み処理
    }

    @Override
    public String getSetting(String key) {
        // 設定値を取得する処理
        return "設定値 for " + key;
    }

    public void startDevice() {
        log("デバイスを起動します。");
        loadConfiguration("device.conf");
        System.out.println("デバイスが起動しました。初期設定: " + getSetting("initialMode"));
    }
}

public class MultiInterfaceDemo {
    public static void main(String[] args) {
        AdvancedDevice myDevice = new AdvancedDevice();
        myDevice.startDevice();

        // AdvancedDeviceはLoggableとしても扱える
        Loggable logger = myDevice;
        logger.log("これはロガー経由のメッセージです。");

        // AdvancedDeviceはConfigurableとしても扱える
        Configurable configManager = myDevice;
        configManager.loadConfiguration("new_config.xml");
        System.out.println("新しい設定 'volume': " + configManager.getSetting("volume"));
    }
}
```

`AdvancedDevice`クラスは、`Loggable`インターフェイスの`log`メソッドと、`Configurable`インターフェイスの`loadConfiguration`メソッドおよび`getSetting`メソッドをすべて実装する必要があります。これにより、`AdvancedDevice`のインスタンスは`Loggable`型または`Configurable`型として扱えます（アップキャスト）。

### 2.4. `interface`が持てるもの (Java 8以降の進化)

Javaのバージョンアップに伴い、インターフェイスの機能も拡張されてきました。

#### 1.定数フィールド (Constant Fields)
* 暗黙的に`public static final`です。
* 例: `int MAX_USERS = 100;`

#### 2.抽象メソッド (Abstract Methods)
* 暗黙的に`public abstract`です。実装クラスでのオーバーライドが必須です。
* 例: `void connect(String host);`

#### 3.`default`メソッド (Default Methods) - Java 8以降
* インターフェイス内で具体的な実装を持つことができるメソッドです。
* `default`キーワードを付けて宣言します。
* 主な目的は、**既存のインターフェイスに新しいメソッドを追加する際に、そのインターフェイスを実装しているすべてのクラスに影響を与えずに機能拡張を行うこと（後方互換性の維持）**です。
* 実装クラスは`default`メソッドをオーバーライドすることも、そのまま利用することもできます。

```java
interface MyList<E> {
    void add(E element);
    E get(int index);
    int size();

    // defaultメソッドの例: リストが空かどうかを判定する
    default boolean isEmpty() {
        return size() == 0; // size() 抽象メソッドを利用
    }

    // defaultメソッドから他のdefaultメソッドや抽象メソッドを呼び出せる
    default void printSize() {
        if (isEmpty()) {
            System.out.println("リストは空です。");
        } else {
            System.out.println("リストのサイズ: " + size());
        }
    }
}

class MyArrayList<E> implements MyList<E> {
    private Object[] elements = new Object[10];
    private int currentSize = 0;

    @Override
    public void add(E element) { /* ... 実装 ... */ elements[currentSize++] = element; }
    @Override
    public E get(int index) { /* ... 実装 ... */ return (E)elements[index]; }
    @Override
    public int size() { /* ... 実装 ... */ return currentSize; }

    // isEmpty() は MyList の default 実装を利用できる
    // もちろん、MyArrayList 独自の実装でオーバーライドも可能
    // @Override
    // public boolean isEmpty() {
    //     System.out.println("MyArrayListのisEmptyが呼ばれました");
    //     return currentSize == 0;
    // }
}

public class DefaultMethodDemo {
    public static void main(String[] args) {
        MyList<String> list = new MyArrayList<>();
        list.add("Apple");
        System.out.println("isEmpty: " + list.isEmpty()); // defaultメソッド呼び出し
        list.printSize(); // defaultメソッド呼び出し
        System.out.println("Size: " + list.size());
    }
}
```

#### 4.`static`メソッド (Static Methods) - Java 8以降

* インターフェイスに直接属する静的メソッドで、インスタンス化せずに`インターフェイス名.メソッド名()`で呼び出せます。
* 主に、**インターフェイスに関連するユーティリティメソッドを提供する**ために使用されます。
* `static`メソッドは、実装クラスに継承されたり、オーバーライドされたりすることはありません。

```java
interface StringUtils {
    // staticメソッドの例: 文字列がnullまたは空かチェック
    static boolean isNullOrEmpty(String str) {
        return str == null || str.isEmpty();
    }

    static String getDefaultGreeting() {
        return "Hello, " + getPlatformDefaultUser(); // private staticメソッドを呼び出し
    }

    // Java 9 以降では private static メソッドも定義可能
    private static String getPlatformDefaultUser() {
        // 本来はOSなどからユーザー名を取得する処理
        return "Guest";
    }
}

public class StaticMethodDemo {
    public static void main(String[] args) {
        String name1 = "Java";
        String name2 = null;
        String name3 = "";

        System.out.println(name1 + " isNullOrEmpty: " + StringUtils.isNullOrEmpty(name1)); // false
        System.out.println("null isNullOrEmpty: " + StringUtils.isNullOrEmpty(name2));    // true
        System.out.println("\"\" isNullOrEmpty: " + StringUtils.isNullOrEmpty(name3));  // true

        System.out.println(StringUtils.getDefaultGreeting());
    }
}
```

#### 5.`private`メソッド (Private Methods) - Java 9以降

* インターフェイス内の`default`メソッドや`static`メソッドから呼び出されるヘルパーメソッドとして、コードの共通化や可読性向上のために使用できます。
* インターフェイスの外部や実装クラスからは呼び出せません。
* `private static`メソッドも可能です（上記`StringUtils`の例を参照）。

```java
interface DataProcessor {
    void process(String data);

    default void processWithLogging(String data) {
        logBeforeProcessing(data); // privateメソッド呼び出し
        process(data); // 抽象メソッド呼び出し
        logAfterProcessing(data);  // privateメソッド呼び出し
    }

    private void logBeforeProcessing(String data) {
        System.out.println("[INFO] Processing data: " + data.substring(0, Math.min(data.length(), 10)) + "...");
    }

    private void logAfterProcessing(String data) {
        System.out.println("[INFO] Finished processing data.");
    }
}

class SimpleDataProcessor implements DataProcessor {
    @Override
    public void process(String data) {
        System.out.println("Data processed: " + data.toUpperCase());
    }
}

public class PrivateMethodDemo {
    public static void main(String[] args) {
        DataProcessor processor = new SimpleDataProcessor();
        processor.processWithLogging("This is some important data to be processed.");
        // processor.logBeforeProcessing("test"); // コンパイルエラー！ privateメソッドにはアクセスできない
    }
}
```

### 2.5. `interface`は`interface`を「継承」できる (`extends`)

クラスがクラスを継承するように、インターフェイスも他のインターフェイスを`extends`キーワードを使って継承できます。これにより、インターフェイスの階層構造を作ることができます。

```java
package jp.ac.ait.media;

// 基本的な再生機能
interface Playable {
    void play();
    void stop();
}

// Playableを継承し、録画機能を追加
interface Recordable extends Playable {
    void record();
    void pauseRecording();
}

// Recordableを実装するクラスは、Playableのメソッドも実装する必要がある
class DigitalMediaPlayer implements Recordable {
    @Override
    public void play() {
        System.out.println("音楽を再生します。");
    }

    @Override
    public void stop() {
        System.out.println("再生を停止します。");
    }

    @Override
    public void record() {
        System.out.println("録音を開始します。");
    }

    @Override
    public void pauseRecording() {
        System.out.println("録音を一時停止します。");
    }
}

public class InterfaceInheritanceDemo {
    public static void main(String[] args) {
        Recordable player = new DigitalMediaPlayer();
        player.play();
        player.record();
        player.pauseRecording();
        player.stop();

        Playable basicPlayer = new DigitalMediaPlayer(); // RecordableはPlayableでもある
        basicPlayer.play();
        // basicPlayer.record(); // コンパイルエラー! Playableインターフェイスにはrecordメソッドはない
    }
}
```

子インターフェイス（例：`Recordable`）は、親インターフェイス（例：`Playable`）のすべての抽象メソッドと定数を継承します。子インターフェイスを実装するクラスは、親インターフェイスと子インターフェイスのすべての抽象メソッドを実装する必要があります。

**注意点：** インターフェイスの継承は強力ですが、むやみに深い階層を作ると複雑性が増します。
設計の意図を明確にし、適切な粒度でインターフェイスを定義することが重要です。

### 2.6. `interface`の特徴まとめ

* **インスタンス化不可**: 抽象クラスと同様に、`new`演算子で直接インスタンス化できません。
    * ただし、型として宣言し、そのインターフェイスを実装したクラスのインスタンスを代入できます（ポリモーフィズム）。
    * 例: `List<String> myList = new ArrayList<>();`（`List`はインターフェイス、`ArrayList`は実装クラス）
* **持てるメンバ**:
    * 定数（暗黙的に `public static final`）
    * 抽象メソッド（暗黙的に `public abstract`）
    * `default`メソッド（Java 8以降、実装を持つ）
    * `static`メソッド（Java 8以降、実装を持つ）
    * `private`メソッド（Java 9以降、インターフェイス内部でのみ使用可能）
* **多重実装可能**: クラスは複数のインターフェイスを`implements`できます。
    * 実装するすべてのインターフェイスの抽象メソッドをオーバーライドする必要があります。
* **インターフェイス間の継承**: インターフェイスは他のインターフェイスを`extends`で継承できます（多重継承も可能）。

## 3\. インターフェイスとクラス設計：システム開発現場の視点から

インターフェイスは、単なるJavaの文法機能を超え、堅牢で柔軟なシステムを設計するための強力なツールです。開発現場では、インターフェイスを効果的に活用することで、以下のようなメリットが得られます。

### 3.1. 契約(Contract)としての役割：振る舞いの保証

インターフェイスは、それを実装するクラスが特定のメソッド群（振る舞い）を持つことを保証する「契約」として機能します。

#### 例：シリアライズ可能なオブジェクト

Javaの`java.io.Serializable`インターフェイスは、メソッドを一切持たない「マーカーインターフェイス」の一例です。このインターフェイスを実装したクラスのオブジェクトは、JVMによって特別な方法で扱われ、直列化（オブジェクトの状態をバイトストリームに変換すること）が可能であることを示します。

```java
import java.io.*;

// Serializableインターフェイスを実装することで、このクラスのオブジェクトが直列化可能であることを示す
class User implements Serializable {
    // private static final long serialVersionUID = 1L; // 直列化互換性のためのバージョンID (推奨)
    private String username;
    private transient String password; // transient: 直列化対象外とするフィールド

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{username='" + username + "', password='" + (password == null ? "N/A" : "******") + "'}";
    }
}

public class SerializationDemo {
    public static void main(String[] args) {
        User user = new User("john_doe", "s3cr3tP@sswOrd");

        // シリアライズ (オブジェクトをファイルに保存)
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("user.ser"))) {
            oos.writeObject(user);
            System.out.println("Userオブジェクトをシリアライズしました: " + user);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // デシリアライズ (ファイルからオブジェクトを復元)
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream("user.ser"))) {
            User loadedUser = (User) ois.readObject();
            System.out.println("Userオブジェクトをデシリアライズしました: " + loadedUser);
            // passwordフィールドはtransientなので、デシリアライズ後はnullになる
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

`Serializable`を実装するという「契約」を守ることで、`ObjectOutputStream`などの機構がそのオブジェクトを特別に扱うことができるようになります。

### 3.2. 疎結合(Loose Coupling)の実現：依存関係の低減

インターフェイスを介してオブジェクトを操作することで、**具体的な実装クラスへの依存を減らし、コンポーネント間の結合度を低く保つことができます。** これを疎結合と呼びます。

**例：データベースアクセスの抽象化**

さまざまなデータベース（MySQL, PostgreSQL, Oracleなど）に対応するアプリケーションを考えます。

```java
// データベース操作のインターフェイス
interface CustomerRepository {
    Customer findById(long id);
    void save(Customer customer);
}

class Customer { /* ... */ } // Customerクラスの詳細は省略

// MySQL用の実装
class MySqlCustomerRepository implements CustomerRepository {
    @Override
    public Customer findById(long id) {
        System.out.println("MySQL: ID " + id + " の顧客を検索");
        // MySQLアクセス処理
        return new Customer(/* ... */);
    }
    @Override
    public void save(Customer customer) {
        System.out.println("MySQL: 顧客情報を保存");
        // MySQL保存処理
    }
}

// PostgreSQL用の実装
class PostgreSqlCustomerRepository implements CustomerRepository {
    @Override
    public Customer findById(long id) {
        System.out.println("PostgreSQL: ID " + id + " の顧客を検索");
        // PostgreSQLアクセス処理
        return new Customer(/* ... */);
    }
    @Override
    public void save(Customer customer) {
        System.out.println("PostgreSQL: 顧客情報を保存");
        // PostgreSQL保存処理
    }
}

// 顧客サービス (インターフェイスに依存)
class CustomerService {
    private final CustomerRepository repository; // 具体的なDB実装ではなく、インターフェイスに依存

    // DI (Dependency Injection) の一例: コンストラクタで依存性を注入
    public CustomerService(CustomerRepository repository) {
        this.repository = repository;
    }

    public Customer getCustomerDetails(long id) {
        return repository.findById(id);
    }

    public void registerCustomer(Customer customer) {
        repository.save(customer);
    }
}

public class LooseCouplingDemo {
    public static void main(String[] args) {
        // 使用するDB実装を切り替え可能
        CustomerRepository mysqlRepo = new MySqlCustomerRepository();
        CustomerService mysqlService = new CustomerService(mysqlRepo);
        mysqlService.getCustomerDetails(1L);

        System.out.println("---");

        CustomerRepository pgRepo = new PostgreSqlCustomerRepository();
        CustomerService pgService = new CustomerService(pgRepo); // 別の実装を注入
        pgService.getCustomerDetails(2L);

        // もし将来的にOracleDBに対応する場合、
        // OracleCustomerRepository を作り、CustomerServiceに注入するだけで良い。
        // CustomerServiceクラスのコード変更は不要。
    }
}
```

`CustomerService`は`CustomerRepository`インターフェイスにのみ依存しており、具体的なデータベース実装（`MySqlCustomerRepository`や`PostgreSqlCustomerRepository`）には依存していません。これにより、使用するデータベースを変更したい場合でも、`CustomerService`のコードを修正することなく、新しいリポジトリ実装を注入するだけで対応できます。
このような設計は、**依存性逆転の原則 (Dependency Inversion Principle: DIP)** の一部であり、上位モジュール（`CustomerService`）が下位モジュール（具体的なDBリポジトリ）に直接依存せず、両者が抽象（インターフェイス）に依存するという考え方です。

### 3.3. ポリモーフィズム(Polymorphism)の活用：柔軟な処理の実現

インターフェイス型で宣言された変数には、そのインターフェイスを実装したさまざまなクラスのインスタンスを代入できます。そして、同じメソッド呼び出しでも、実際のインスタンスの型に応じて異なる処理が実行されます。これをポリモーフィズム（多態性）と呼びます。

**例：描画可能なオブジェクト**

```java
// 描画可能なオブジェクトを表すインターフェイス
interface Drawable {
    void draw(); // 描画する
    String getShapeName();
}

class Circle implements Drawable {
    private int radius;
    public Circle(int radius) { this.radius = radius; }
    @Override
    public void draw() { System.out.println("半径" + radius + "の円を描画します。"); }
    @Override
    public String getShapeName() { return "円"; }
}

class Rectangle implements Drawable {
    private int width, height;
    public Rectangle(int width, int height) { this.width = width; this.height = height; }
    @Override
    public void draw() { System.out.println("幅" + width + ", 高さ" + height + "の長方形を描画します。"); }
    @Override
    public String getShapeName() { return "長方形"; }
}

class Triangle implements Drawable {
    private int base, height;
    public Triangle(int base, int height) { this.base = base; this.height = height; }
    @Override
    public void draw() { System.out.println("底辺" + base + ", 高さ" + height + "の三角形を描画します。"); }
    @Override
    public String getShapeName() { return "三角形"; }
}

public class PolymorphismDemo {
    // Drawableインターフェイスを実装したオブジェクトのリストを受け取り、描画するメソッド
    public static void drawAllShapes(java.util.List<Drawable> shapes) {
        for (Drawable shape : shapes) {
            System.out.print(shape.getShapeName() + ": ");
            shape.draw(); // 同じ draw() メソッド呼び出しでも、実際のオブジェクトによって動作が変わる
        }
    }

    public static void main(String[] args) {
        java.util.List<Drawable> myShapes = new java.util.ArrayList<>();
        myShapes.add(new Circle(5));
        myShapes.add(new Rectangle(10, 4));
        myShapes.add(new Triangle(6, 3));
        // 新しい図形 (例: Starクラス) を追加する場合も、Drawableを実装していれば
        // drawAllShapes メソッドの修正は不要！
        // myShapes.add(new Star());

        drawAllShapes(myShapes);
    }
}
```

`drawAllShapes`メソッドは、`Drawable`インターフェイスのリストを受け取ります。ループ内で`shape.draw()`を呼び出すと、`shape`変数が実際に参照しているオブジェクト（`Circle`、`Rectangle`、または`Triangle`）の`draw`メソッドが実行されます。新しい図形クラスを追加する場合でも、`Drawable`インターフェイスを実装していれば、`drawAllShapes`メソッドを変更する必要はありません。

### 3.4. 拡張性(Extensibility)の向上：機能追加の容易化

インターフェイスを中心に設計することで、システムに新しい機能を追加する際に、既存のコードへの影響を最小限に抑えることができます。

**例：プラグインアーキテクチャ**

アプリケーションにプラグイン機能を持たせたい場合、プラグインの共通仕様をインターフェイスで定義します。

```java
// プラグインインターフェイス
interface Plugin {
    String getName();        // プラグイン名を取得
    void execute();          // プラグインの主処理を実行
    void initialize();       // 初期化処理
    void terminate();        // 終了処理
}

// 具体的なプラグインの実装1: HelloWorldPlugin
class HelloWorldPlugin implements Plugin {
    @Override public String getName() { return "Hello World Plugin"; }
    @Override public void initialize() { System.out.println(getName() + ": 初期化中..."); }
    @Override public void execute() { System.out.println("Hello, World from Plugin!"); }
    @Override public void terminate() { System.out.println(getName() + ": 終了処理中..."); }
}

// 具体的なプラグインの実装2: DataBackupPlugin
class DataBackupPlugin implements Plugin {
    @Override public String getName() { return "Data Backup Plugin"; }
    @Override public void initialize() { System.out.println(getName() + ": バックアップ準備完了。"); }
    @Override public void execute() { System.out.println("データのバックアップを実行しました..."); }
    @Override public void terminate() { System.out.println(getName() + ": バックアップ完了通知。"); }
}

// プラグインを管理・実行するクラス
class PluginManager {
    private java.util.List<Plugin> plugins = new java.util.ArrayList<>();

    public void registerPlugin(Plugin plugin) {
        plugin.initialize();
        plugins.add(plugin);
        System.out.println("プラグイン '" + plugin.getName() + "' を登録しました。");
    }

    public void executeAllPlugins() {
        if (plugins.isEmpty()) {
            System.out.println("実行可能なプラグインがありません。");
            return;
        }
        System.out.println("\n--- 全てのプラグインを実行 ---");
        for (Plugin plugin : plugins) {
            System.out.println("実行中: " + plugin.getName());
            plugin.execute();
        }
        System.out.println("--- 全てのプラグイン実行完了 ---");
    }

    public void shutdownAllPlugins() {
        System.out.println("\n--- 全てのプラグインをシャットダウン ---");
        for (int i = plugins.size() - 1; i >= 0; i--) { // 登録と逆順で終了処理
            Plugin plugin = plugins.get(i);
            System.out.println("シャットダウン中: " + plugin.getName());
            plugin.terminate();
        }
        plugins.clear();
        System.out.println("--- 全てのプラグインシャットダウン完了 ---");
    }
}

public class PluginDemo {
    public static void main(String[] args) {
        PluginManager manager = new PluginManager();

        // 新しいプラグインを簡単に登録できる
        manager.registerPlugin(new HelloWorldPlugin());
        manager.registerPlugin(new DataBackupPlugin());
        // さらに新しいプラグイン (例: AnalyticsPlugin) ができたら、
        // Pluginインターフェイスを実装して manager.registerPlugin するだけで良い。

        manager.executeAllPlugins();
        manager.shutdownAllPlugins();
    }
}
```

`PluginManager`は`Plugin`インターフェイスにのみ依存しています。新しいプラグインを追加するには、`Plugin`インターフェイスを実装したクラスを作成し、`PluginManager`に登録するだけです。`PluginManager`自体のコードを変更する必要はありません。

### 3.5. テスト容易性(Testability)の向上：モックとスタブ

インターフェイスは、ユニットテストの際に**モックオブジェクト**や**スタブ**を作成しやすくします。

  * **スタブ(Stub)**: テスト対象のコードが依存するコンポーネントの代わりに、固定の値を返す単純な実装。
  * **モック(Mock)**: スタブの機能に加え、呼び出しの検証（特定のメソッドが期待通りに呼ばれたかなど）も行えるオブジェクト。

**例：通知サービスのテスト**

ユーザー登録時にメールで通知を送るサービスを考えます。実際のメール送信処理はテスト時には実行したくありません。

```java
// 通知サービスインターフェイス
interface NotificationService {
    void sendNotification(String userId, String message);
}

// 実際のメール送信を行う実装 (本番用)
class EmailNotificationService implements NotificationService {
    @Override
    public void sendNotification(String userId, String message) {
        System.out.println("ユーザー " + userId + " にメール送信: " + message);
        // 実際のメール送信API呼び出しなど
    }
}

// ユーザー登録処理クラス
class UserRegistration {
    private NotificationService notificationService;

    public UserRegistration(NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void registerUser(String userId, String password) {
        // ユーザー登録処理 ...
        System.out.println("ユーザー " + userId + " を登録しました。");
        notificationService.sendNotification(userId, "ようこそ！登録が完了しました。");
    }
}

// --- テストコード ---
// NotificationServiceのモック実装 (テスト用)
class MockNotificationService implements NotificationService {
    public String lastUserId;
    public String lastMessage;
    public int notificationCount = 0;

    @Override
    public void sendNotification(String userId, String message) {
        this.lastUserId = userId;
        this.lastMessage = message;
        this.notificationCount++;
        System.out.println("[MOCK] ユーザー " + userId + " に通知: " + message);
    }
}

// JUnitなどのテストフレームワークを使うと、より簡単にモックを作成・検証できる (例: Mockito)
public class TestabilityDemo {
    public static void main(String[] args) { // 本来はJUnitなどのテストメソッド内で行う
        MockNotificationService mockService = new MockNotificationService();
        UserRegistration registration = new UserRegistration(mockService); // モックを注入

        registration.registerUser("testUser123", "pass");

        // 検証: sendNotificationが1回呼ばれたか？
        if (mockService.notificationCount != 1) {
            System.err.println("テスト失敗: notificationCountが不正です。期待値:1, 実際:"+mockService.notificationCount);
        }
        // 検証: 正しいユーザーIDとメッセージで呼ばれたか？
        if (!"testUser123".equals(mockService.lastUserId)) {
            System.err.println("テスト失敗: lastUserIdが不正です。期待値:testUser123, 実際:"+mockService.lastUserId);
        }
        if (!"ようこそ！登録が完了しました。".equals(mockService.lastMessage)) {
            System.err.println("テスト失敗: lastMessageが不正です。");
        }
        System.out.println("モックオブジェクトによるテストが完了しました。");
    }
}
```

テスト時には、実際の`EmailNotificationService`の代わりに`MockNotificationService`を`UserRegistration`に注入します。これにより、外部システム（メールサーバー）に依存せず`UserRegistration`のロジックをテストでき、かつ通知が正しく行われようとしたか（メソッドが呼ばれたか、引数は適切か）を検証できます。
Mockitoのようなモックフレームワークを利用すると、このようなモックオブジェクトの作成や検証がさらに簡単になります。

### 3.6. API設計とフレームワークでの活用

* ライブラリやフレームワークのAPI
    - 多くのJavaライブラリやフレームワーク（例: Java Collections Frameworkの`List`, `Map`, `Set`、Spring Frameworkの各種インターフェイス）は、インターフェイスをAPIの主要な構成要素として提供しています。これにより、利用者は特定の実装に縛られず、フレームワークの提供する機能を柔軟に利用できます。
* サービスプロバイダインターフェイス (SPI)
    - ライブラリやフレームワークが拡張ポイントを提供し、利用者が独自の実装を提供できるようにするための仕組みです。たとえば、`java.sql.Driver`インターフェイスは、各データベースベンダーがJDBCドライバを実装するためのSPIです。

### 3.7.のまえに
#### デザインパターン入門：ソフトウェア設計の知恵袋

ここで少し寄り道をして、「**デザインパターン**」という言葉について簡単に触れておきましょう。皆さんはこの講義ではじめて耳にするかもしれません。

##### デザインパターンとは？

一言で言うと、「**ソフトウェア設計における特定の問題に対する、繰り返し利用可能な、実績のある解決策の型（かた）**」のことです。過去の多くのエンジニアたちがさまざまなシステムを開発する中で、「こういう問題には、こういう設計をすると上手くいくことが多い」という知見やノウハウを蓄積してきました。デザインパターンは、これらの成功例を整理し、再利用しやすい形でカタログ化したものと言えます。

##### なぜデザインパターンが役立つのか？

デザインパターンを学ぶことには、以下のようなメリットがあります。

1.  **共通言語の獲得**:
    開発者同士が「この部分はストラテジーパターンを使おう」といった共通の言葉でコミュニケーションできるようになり、設計の意図が伝わりやすくなります。
2.  **設計品質の向上**:
    実績のある解決策を利用することで、ゼロから設計を考えるよりも効率的に、かつ堅牢で柔軟なシステムを構築しやすくなります。
3.  **再利用性と保守性の向上**:
    パターン化された構造は理解しやすく、コードの再利用や将来の変更・拡張が容易になる傾向があります。

##### インターフェイスとデザインパターン

この講義で学んでいる**インターフェイスは、実は多くのデザインパターンで非常に重要な役割を果たします。** インターフェイスが持つ「契約」「疎結合」「ポリモーフィズム」といった特性は、デザインパターンが目指す柔軟性、拡張性、保守性の高い設計を実現するための鍵となることが多いのです。

この講義では、個々のデザインパターンの詳細に深入りはしません。しかし、インターフェイスの強力な応用例として、これから紹介するいくつかのデザインパターンでインターフェイスがどのように活用されているかを知ることは、皆さんの設計スキルを一段階引き上げる上で非常に有益です。将来的にデザインパターンを本格的に学ぶ際にも、ここでのインターフェイスの知識がきっと役立つでしょう。


### 3.7. デザインパターンとの関連
インターフェイスは、多くのデザインパターンを実現する上で中心的な役割を果たします。


* **ストラテジーパターン (Strategy Pattern)**: アルゴリズムのファミリーを定義し、それぞれをカプセル化し、それらを交換可能にする。アルゴリズムの選択をクライアントから独立させる。
    * `PaymentStrategy`の例は、ストラテジーパターンの一種です。
* **ファクトリーメソッドパターン (Factory Method Pattern)**: オブジェクトの生成をサブクラスに委ねる。どのクラスのインスタンスを生成するかをサブクラスが決定する。
    * 戻り値の型としてインターフェイスを使用し、具体的なインスタンスはサブクラスのファクトリーメソッドが生成します。
* **オブザーバーパターン (Observer Pattern)**: あるオブジェクト（Subject）の状態が変化したときに、それに依存する複数のオブジェクト（Observer）に自動的に通知し、更新する。
    * Observerは通常インターフェイスとして定義され、具体的なObserverクラスがそれを実装します。
* **デコレーターパターン (Decorator Pattern)**: オブジェクトに新しい責務を動的に追加する。継承よりも柔軟な方法で機能を拡張できる。
    * デコレーターと被装飾オブジェクトは共通のインターフェイスを実装します。

**例：ストラテジーパターン（ソート戦略）**

```java
import java.util.Arrays;
import java.util.List;
import java.util.Collections; // Collections.sort を使う場合

// ソート戦略インターフェイス
interface SortStrategy {
    void sort(List<Integer> list);
}

// バブルソート実装 (簡易版)
class BubbleSortStrategy implements SortStrategy {
    @Override
    public void sort(List<Integer> list) {
        System.out.println("バブルソートでソートします。");
        int n = list.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (list.get(j) > list.get(j + 1)) {
                    // 要素を入れ替え
                    Collections.swap(list, j, j + 1);
                }
            }
        }
    }
}

// クイックソート実装 (簡易版 - Java標準のソートを利用)
class QuickSortStrategy implements SortStrategy {
    @Override
    public void sort(List<Integer> list) {
        System.out.println("クイックソート（実際はCollections.sort）でソートします。");
        Collections.sort(list); // 簡単のためJava標準のソートを利用
    }
}

// ソート処理を行うコンテキストクラス
class SorterContext {
    private SortStrategy strategy;

    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }

    public void executeSort(List<Integer> list) {
        if (strategy == null) {
            System.out.println("ソート戦略が設定されていません。");
            return;
        }
        strategy.sort(new java.util.ArrayList<>(list)); // 元のリストを変更しないようにコピーを渡す
    }
}

public class StrategyPatternDemo {
    public static void main(String[] args) {
        List<Integer> data = Arrays.asList(5, 1, 9, 3, 7);
        SorterContext sorter = new SorterContext();

        System.out.println("元のデータ: " + data);

        // バブルソート戦略を選択
        sorter.setStrategy(new BubbleSortStrategy());
        List<Integer> dataForBubble = new java.util.ArrayList<>(data); // ソート用にコピー
        sorter.strategy.sort(dataForBubble); // 直接ソートを実行
        System.out.println("バブルソート結果: " + dataForBubble);


        System.out.println("---");

        // クイックソート戦略を選択
        sorter.setStrategy(new QuickSortStrategy());
        List<Integer> dataForQuick = new java.util.ArrayList<>(data); // ソート用にコピー
        sorter.strategy.sort(dataForQuick); // 直接ソートを実行
        System.out.println("クイックソート結果: " + dataForQuick);
    }
}
```

`SorterContext`は、具体的なソートアルゴリズム（`BubbleSortStrategy`や`QuickSortStrategy`）に依存せず、`SortStrategy`インターフェイスに依存します。実行時にソート戦略を切り替えることができます。

## 4\. インターフェイスと多重継承の問題 (Java 8以降の`default`メソッド)

### 4.1. `default`修飾子を用いた処理の実装（再掲と補足）

Java 8で導入された`default`メソッドにより、インターフェイスに具体的な実装を持つメソッドを定義できるようになりました。これは主に、既存のインターフェイスに新しいメソッドを追加する際に、そのインターフェイスを実装している膨大な数のクラスすべてに修正を強いることなく、後方互換性を保ちつつ機能拡張を行うために導入されました。

```java
interface Vehicle {
    void start();
    void stop();

    // defaultメソッド: 全ての乗り物に共通の警告音機能
    default void honk() {
        System.out.println("Beep beep!");
    }

    // 別のdefaultメソッド
    default String getInfo() {
        return "This is a vehicle.";
    }
}

class Car implements Vehicle {
    @Override public void start() { System.out.println("Car engine started."); }
    @Override public void stop() { System.out.println("Car stopped."); }

    // Carクラス独自のhonk実装でオーバーライドすることも可能
    @Override
    public void honk() {
        System.out.println("Car horn: Honk honk!");
    }
}

class Bicycle implements Vehicle {
    @Override public void start() { System.out.println("Bicycle started pedaling."); }
    @Override public void stop() { System.out.println("Bicycle applied brakes."); }

    // Bicycleにはクラクションがないので、honkはVehicleのdefault実装を利用する
    // あるいは、Bicycle用にhonkをオーバーライドして「何もしない」または「ベルを鳴らす」なども可能
    @Override
    public void honk() {
        System.out.println("Ring ring! (Bicycle bell)");
    }

    @Override
    public String getInfo() {
        return "This is a bicycle."; // VehicleのgetInfoをオーバーライド
    }
}

public class DefaultMethodEvolution {
    public static void main(String[] args) {
        Vehicle myCar = new Car();
        myCar.start();
        myCar.honk(); // Car.honk()が呼ばれる
        System.out.println(myCar.getInfo());
        myCar.stop();

        System.out.println("---");

        Vehicle myBike = new Bicycle();
        myBike.start();
        myBike.honk(); // Bicycle.honk()が呼ばれる
        System.out.println(myBike.getInfo());
        myBike.stop();
    }
}
```

### 4.2. 多重実装と`default`メソッドの衝突 (The Diamond Problem)

クラスが複数のインターフェイスを実装し、かつそれらのインターフェイスが同じシグネチャを持つ`default`メソッドを提供している場合、**実装クラスでそのメソッドを明示的にオーバーライドしないとコンパイルエラーが発生します。** これは、どのインターフェイスの`default`メソッドを使用すべきかコンパイラが判断できないためです（菱形問題、Diamond Problemと呼ばれる問題の一種）。

#### シナリオ1：衝突が発生し、オーバーライドが必須なケース*

```java
interface Alarm {
    default void activate() {
        System.out.println("Alarm activated!");
    }
    void notifyStatus();
}

interface Monitor {
    default void activate() {
        System.out.println("Monitor activated!");
    }
    String getMonitorType();
}

// AlarmとMonitorの両方を実装するが、activate()が衝突する
// class SecuritySystem implements Alarm, Monitor { // このままではコンパイルエラー
//     // エラーメッセージ例:
//     // SecuritySystem inherits unrelated defaults for activate() from types Alarm and Monitor

//     @Override
//     public void notifyStatus() { System.out.println("Security system is active."); }

//     @Override
//     public String getMonitorType() { return "Infrared"; }

//     // activate() をオーバーライドして衝突を解決する必要がある
// }

class SecuritySystem implements Alarm, Monitor {
    @Override
    public void notifyStatus() { System.out.println("Security system is active."); }

    @Override
    public String getMonitorType() { return "Infrared"; }

    // 衝突するactivate()メソッドをオーバーライドして解決
    @Override
    public void activate() {
        // どちらか一方のデフォルト実装を明示的に呼び出すか、独自の処理を記述する
        Alarm.super.activate();    // Alarmインターフェイスのactivateを呼び出す
        // Monitor.super.activate(); // Monitorインターフェイスのactivateを呼び出すことも可能
        System.out.println("Security System specific activation sequence.");
        // もし両方呼びたい場合は両方記述する
        // Monitor.super.activate();
    }
}

public class DefaultMethodConflictDemo {
    public static void main(String[] args) {
        SecuritySystem system = new SecuritySystem();
        system.activate(); // SecuritySystemでオーバーライドされたactivateが呼ばれる
        system.notifyStatus();
        System.out.println("Monitor type: " + system.getMonitorType());
    }
}
```

#### 解決策：

1.  **実装クラスでメソッドをオーバーライドする**: これがもっとも一般的な解決策です。独自のロジックを実装するか、`インターフェイス名.super.メソッド名()`構文を使って特定のインターフェイスの`default`実装を明示的に呼び出すことができます。
2.  **一方のインターフェイスの`default`メソッドを、もう一方のインターフェイスが継承し、オーバーライドする（より具体的な`default`実装を提供する）**: これはインターフェイス設計レベルでの解決策です。

**シナリオ2：片方のインターフェイスがもう片方を継承している場合（衝突は自動解決されることがある）**

```java
interface BaseFeature {
    default void performAction() {
        System.out.println("BaseFeature action performed.");
    }
}

interface EnhancedFeature extends BaseFeature {
    // BaseFeatureのperformActionをオーバーライドするdefaultメソッド
    @Override
    default void performAction() {
        BaseFeature.super.performAction(); // 親のdefaultメソッドを呼ぶこともできる
        System.out.println("EnhancedFeature action performed with enhancements.");
    }
    void specificEnhancedOperation();
}

// このクラスはBaseFeatureとEnhancedFeatureの両方の型を持つが、
// performActionはより具体的なEnhancedFeatureのものが使われる。
class AdvancedComponent implements EnhancedFeature { // BaseFeatureも暗黙的に実装
    @Override
    public void specificEnhancedOperation() {
        System.out.println("Specific enhanced operation executed.");
    }
    // performAction()をオーバーライドしなくても、EnhancedFeatureのdefault実装が使われる。
    // もしAdvancedComponentでperformActionをオーバーライドすれば、それが優先される。
}

public class DefaultMethodHierarchyDemo {
    public static void main(String[] args) {
        AdvancedComponent component = new AdvancedComponent();
        component.performAction();
        component.specificEnhancedOperation();

        EnhancedFeature ef = component;
        ef.performAction(); // EnhancedFeatureのdefaultメソッド

        BaseFeature bf = component;
        bf.performAction(); // これもEnhancedFeatureのdefaultメソッド (ポリモーフィズム)
    }
}
```

このケースでは、`AdvancedComponent`が`EnhancedFeature`を実装しており、`EnhancedFeature`は`BaseFeature`を継承して`performAction`をオーバーライドしています。この場合、`AdvancedComponent`のインスタンスで`performAction`を呼び出すと、`EnhancedFeature`で定義された`default`メソッドが使用されます。これは、継承階層においてより具体的な実装が優先されるためです。

**Javaのクラスの多重継承が禁止されている理由とインターフェイス**

Javaではクラスの多重継承（複数のクラスを`extends`すること）は、主に「菱形問題」に代表されるような複雑な継承関係やメソッドの衝突、状態の多重継承による曖昧さを避けるために、意図的に許可されていません。
インターフェイスは元々、状態（フィールド）を持たず、メソッドの実装も持たなかったため、多重実装してもこれらの問題は発生しにくいと考えられていました。`default`メソッドの導入により、インターフェイスも振る舞いの一部を持てるようになりましたが、上記のような衝突解決ルールを設けることで、ある程度の制御が効くようになっています。しかし、依然として設計の複雑さを増す可能性はあるため、`default`メソッドの多用や複雑なインターフェイス階層には注意が必要です。

## 5\. インターフェイスを扱う上でのベストプラクティスと注意点

### 1.インターフェイスは設計段階で用意する (Design by Contract)

* システムのコンポーネント間の「契約」を早期に定義することで、並行開発がしやすくなり、変更に強い構造を築けます。
* まずインターフェイスを定義し、次にその実装クラスを作成するというトップダウンのアプローチが推奨されます。

### 2.インターフェイスの仕様変更は慎重に

* インターフェイスは多くのクラスに実装される可能性があるため、一度公開したインターフェイスにメソッドを追加・変更・削除すると、影響範囲が非常に大きくなります。
* Java 8以降の`default`メソッドは、既存の実装クラスを壊さずにメソッドを追加する手段を提供しますが、それでも意味的な互換性には注意が必要です。
* 変更が必要な場合は、新しいバージョンのインターフェイスを作成する（例：`List`と`List2`）、あるいは既存インターフェイスを継承して拡張するなどの方法を検討します。

### 3.命名規則に従う

* **`~able`**: `Runnable`, `Serializable`, `Comparable` のように、特定の能力や性質を持つことを示す場合。
* **`~Listener`**: `ActionListener`, `MouseListener` のように、イベントを待ち受けるオブジェクトであることを示す場合。
* **`~Handler`**: `MessageHandler`, `ExceptionHandler` のように、何かを処理する役割を持つ場合。
* **`~Service`**: `UserService`, `PaymentService` のように、特定のビジネスサービスを提供するインターフェイス。
* **`~Repository`**: `CustomerRepository`, `ProductRepository` のように、データアクセスを担当するインターフェイス（リポジトリパターン）。
* 一般的には名詞または形容詞で、そのインターフェイスが何を表すか、どんな役割を持つかを明確に示す名前を付けます。

### 4.適切な粒度でインターフェイスを定義する (Interface Segregation Principle - ISP)

* **単一責任の原則 (Single Responsibility Principle: SRP)** をインターフェイスにも適用し、1つのインターフェイスが多くの責務を持ちすぎないようにします。
* クライアント（インターフェイスの利用者）が、自身が使用しないメソッドに依存しないように、インターフェイスを適切に分割します。これを**インターフェイス分離の原則 (ISP)** と呼びます。
* 例：巨大な`GodInterface`を作るのではなく、`Readable`, `Writable`, `Closable` のように機能を分割します。


```java
// ISPに違反する可能性のある例 (Fat Interface)
interface Worker {
    void work();
    void eat();
    void sleep();
}
// HumanWorkerは全て実装できる
class HumanWorkerImpl implements Worker {
    @Override public void work() { System.out.println("人間が働きます。"); }
    @Override public void eat() { System.out.println("人間が食事をします。"); }
    @Override public void sleep() { System.out.println("人間が寝ます。"); }
}
// RobotWorkerはeat()やsleep()は不要かもしれない
class RobotWorkerImpl implements Worker {
    @Override public void work() { System.out.println("ロボットが働きます。"); }
    @Override public void eat() { /* No-op or throw UnsupportedOperationException */ } // 不要なメソッド
    @Override public void sleep() { /* No-op or throw UnsupportedOperationException */ } // 不要なメソッド
}

// ISPに従った改善例
interface Workable { void work(); }
interface Eatable { void eat(); }
interface Sleepable { void sleep(); }

class HumanWorkerImplV2 implements Workable, Eatable, Sleepable {
    @Override public void work() { System.out.println("人間(v2)が働きます。"); }
    @Override public void eat() { System.out.println("人間(v2)が食事をします。"); }
    @Override public void sleep() { System.out.println("人間(v2)が寝ます。"); }
}
class RobotWorkerImplV2 implements Workable {
    @Override public void work() { System.out.println("ロボット(v2)が働きます。"); }
}
```

### 5.定数だけを持つインターフェイスは避ける (Constant Interface Antipattern)

インターフェイスは本来「型」を定義し、クラスの振る舞いを規定するためのものです。定数だけを定義するためだけにインターフェイスを使用するのは、その目的から外れています（アンチパターンとされています）。

定数をまとめたい場合は、以下のような代替手段を検討しましょう。

#### `final`クラスに`public static final`定数を定義する

```java
public final class AppConstants {
    private AppConstants() {} // インスタンス化防止
    public static final String DEFAULT_ENCODING = "UTF-8";
    public static final int MAX_CONNECTIONS = 10;
}
// 利用時: AppConstants.DEFAULT_ENCODING
```

#### **列挙型 (`enum`)**: 関連する定数のグループを定義する場合に非常に有効です。
```java
public enum Status {
    PENDING, PROCESSING, COMPLETED, FAILED;
}
// 利用時: Status.COMPLETED
```
* ユーティリティクラスが定数を必要とするなら、そのクラス内に`private static final`で定義する。

Javaの標準ライブラリでも過去には`java.io.ObjectStreamConstants`のような定数インターフェイスがありましたが、現代のJavaプログラミングでは推奨されません。

### 6.マーカーインターフェイスの理解と適切な使用

* `java.io.Serializable`や`java.lang.Cloneable`のように、メソッドを持たない（あるいは`default`メソッドのみを持つ）インターフェイスをマーカーインターフェイス（またはタグインターフェイス）と呼びます。
* これらは、クラスに特定の性質や能力があることをJVMやフレームワークに伝えるための「印」として機能します。
* 独自にマーカーインターフェイスを定義することも可能ですが、アノテーション (`@Annotation`) の方がより適切な場合も多いため、目的や用途に応じて使い分けを検討しましょう。アノテーションはメタデータを付与するのに対し、マーカーインターフェイスは型システムの一部となります。

### 7.`default`メソッドの乱用を避ける

* `default`メソッドは便利ですが、インターフェイスの主目的が「仕様の定義」であることを忘れてはいけません。安易に多くの実装を`default`メソッドで提供し始めると、インターフェイスが実質的な具象クラス（あるいは抽象クラス）に近づき、インターフェイスの利点である「実装からの分離」が損なわれる可能性もあります。
* `default`メソッドは、主に後方互換性の維持や、複数の実装クラスで共通して利用できる自明なユーティリティ機能の提供に限定するのが良いでしょう。


----

# 練習課題
## 処理の選択と実行

### 目的:

* **インターフェイス**の定義と実装の基本を理解する。
* **ポリモーフィズム**を用いて、異なるクラスのインスタンスをインターフェイス型で統一的に扱う方法を理解する。
* Java Swingでラジオボタンによる選択と、ボタンアクションからオブジェクトのメソッドを呼び出す基本的な流れを学ぶ。

### 課題内容:

1. `Executable` という名前の**インターフェイス**を定義してください。このインターフェイスは、引数なし、戻り値 `String` の抽象メソッド `execute()` を1つだけ持ちます。
2. `TaskA` という名前のクラスを作成し、`Executable` **インターフェイス**を実装してください。`execute()` メソッドでは、「タスクAを実行しました！」という文字列を返却するように実装します。
3. `TaskB` という名前のクラスを作成し、`Executable` **インターフェイス**を実装してください。`execute()` メソッドでは、「タスクBが完了しました。」という文字列を返却するように実装します。
4. `SelectableGuiApp` という名前のクラスを作成し、Java Swingで簡単なGUIアプリケーションを構築してください。
    * `JFrame` を作成し、タイトルを「処理選択デモ」とします。
    * `JPanel` を作成し、フレームに追加します。
    * パネル内に、処理を選択するためのラジオボタンを2つ（例: `JRadioButton "タスクAを実行"`, `JRadioButton "タスクBを実行"`）配置します。これらは `ButtonGroup` でグループ化し、いずれか1つのみ選択できるようにします。
    * 処理を実行するための `JButton`（例: `"実行"`）を配置します。
    * 実行結果を表示するための `JLabel` を配置します。
    * `実行` ボタンに `ActionListener` を追加します。
    * `実行` ボタンが押されたら、選択されているラジオボタンに応じて、対応するクラス (`TaskA` または `TaskB`) のインスタンスを作成し、その `execute()` メソッドを呼び出します。
        * たとえば、「タスクAを実行」ラジオボタンが選択されていれば `TaskA` の `execute()` を呼び出します。
        * 「タスクBを実行」ラジオボタンが選択されていれば `TaskB` の `execute()` を呼び出します。
    * それぞれの `execute()` メソッドから返却された文字列を、GUI上の `JLabel` に表示します。
5. `SelectableGuiApp` の `main` メソッドからGUIを起動し、ラジオボタンで処理を選択し、実行ボタンをクリックして異なる処理が実行され、結果がGUIに表示されることを確認してください。

### ポイント:

* `SelectableGuiApp` の `ActionListener` 内で、`Executable selectedTask;` のようにインターフェイス型の変数を宣言し、ラジオボタンの選択状態に応じて `selectedTask = new TaskA();` や `selectedTask = new TaskB();` のようにインスタンスを代入し、`selectedTask.execute()` のように共通のメソッドを呼び出す箇所を実装することで**ポリモーフィズム**を活用できます。
* GUI作成のためのJava Swingの基本的なクラス（`JFrame`, `JPanel`, `JRadioButton`, `ButtonGroup`, `JButton`, `JLabel`）とイベント処理（`ActionListener`）の使い方は、必要に応じて別途調べてください。

### 解答例

<details><summary>クリックで表示する</summary>
<p>

### `Executable.java`

```java
/**
 * 実行可能な処理の契約を定義するインターフェイス。
 * このインターフェイスを実装するクラスは、具体的な実行処理を持つことになります。
 */
public interface Executable {
    /**
     * 実行可能な処理を行い、結果メッセージを返却します。
     *
     * @return 処理結果を示す文字列
     */
    String execute();
}
```

### `TaskA.java`

```java
/**
 * {@link Executable} インターフェイスを実装するクラス。
 * タスクAの具体的な処理を定義します。
 */
public class TaskA implements Executable {
    /**
     * タスクAの処理を実行し、その結果を説明する文字列を返します。
     *
     * @return タスクAの実行結果メッセージ
     */
    @Override
    public String execute() {
        // コンソールにも実行中であることを示すメッセージを出力（デバッグや確認用）
        System.out.println("コンソール: TaskAを実行中...");
        return "タスクAを実行しました！";
    }
}
```

### `TaskB.java`

```java
/**
 * {@link Executable} インターフェイスを実装するクラス。
 * タスクBの具体的な処理を定義します。
 */
public class TaskB implements Executable {
    /**
     * タスクBの処理を実行し、その結果を説明する文字列を返します。
     *
     * @return タスクBの実行結果メッセージ
     */
    @Override
    public String execute() {
        // コンソールにも実行中であることを示すメッセージを出力（デバッグや確認用）
        System.out.println("コンソール: TaskBを実行中...");
        return "タスクBが完了しました。";
    }
}
```

### `SelectableGuiApp.java`

```java
import javax.swing.*;
import java.awt.*;

/**
 * {@link Executable} インターフェイスを実装したタスクを選択し、実行するためのシンプルなGUIアプリケーション。
 * ラジオボタンで処理を選択し、実行ボタンで結果を表示します。
 */
public class SelectableGuiApp extends JFrame {

    private JLabel resultLabel; // 実行結果を表示するラベル
    private JRadioButton radioTaskA; // TaskA選択用ラジオボタン
    private JRadioButton radioTaskB; // TaskB選択用ラジオボタン
    private ButtonGroup taskButtonGroup; // ラジオボタンをグループ化

    /**
     * {@code SelectableGuiApp} のコンストラクタ。
     * GUIの初期化とコンポーネントの配置を行います。
     */
    public SelectableGuiApp() {
        // 1. フレームの基本設定
        setTitle("処理選択デモ"); // ウィンドウのタイトル
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 閉じるボタンでプログラム終了
        setSize(550, 200); // ウィンドウサイズ
        setLocationRelativeTo(null); // ウィンドウを画面中央に表示

        // 2. メインパネルの作成とレイアウト設定
        JPanel panel = new JPanel();
        panel.setLayout(new FlowLayout(FlowLayout.CENTER, 10, 10)); // コンポーネントを中央揃えで配置

        // 3. ラジオボタンの作成と設定
        radioTaskA = new JRadioButton("タスクAを実行");
        radioTaskA.setActionCommand("TaskA"); // ActionListenerで識別するためのコマンド
        radioTaskA.setSelected(true); // 初期状態でTaskAを選択

        radioTaskB = new JRadioButton("タスクBを実行");
        radioTaskB.setActionCommand("TaskB");

        // 4. ラジオボタンをグループ化 (いずれか一つだけ選択可能にする)
        taskButtonGroup = new ButtonGroup();
        taskButtonGroup.add(radioTaskA);
        taskButtonGroup.add(radioTaskB);

        // 5. 実行ボタンの作成
        JButton executeButton = new JButton("実行");

        // 6. 結果表示ラベルの作成
        resultLabel = new JLabel("ここに結果が表示されます", SwingConstants.CENTER);
        resultLabel.setPreferredSize(new Dimension(300, 30)); // ラベルの推奨サイズを設定

        // 7. 実行ボタンにActionListenerを追加
        executeButton.addActionListener(e -> {
            Executable selectedTask = null; // Executableインターフェイス型の変数を準備
            String selectedActionCommand = taskButtonGroup.getSelection().getActionCommand(); // 選択されているラジオボタンのコマンドを取得

            // 選択されたコマンドに応じて、対応するタスクのインスタンスを生成
            // ここでポリモーフィズムが活用される
            if ("TaskA".equals(selectedActionCommand)) {
                selectedTask = new TaskA();
            } else if ("TaskB".equals(selectedActionCommand)) {
                selectedTask = new TaskB();
            }

            // selectedTask が null でなければ (つまり、何らかのタスクが選択されていれば)
            if (selectedTask != null) {
                String result = selectedTask.execute(); // 選択されたタスクのexecuteメソッドを実行
                resultLabel.setText("結果: " + result); // 結果をラベルに表示
            } else {
                resultLabel.setText("エラー: 処理が選択されていません。");
            }
        });

        // 8. パネルにコンポーネントを追加
        panel.add(new JLabel("実行するタスクを選択:"));
        panel.add(radioTaskA);
        panel.add(radioTaskB);
        panel.add(executeButton);
        panel.add(resultLabel);

        // 9. フレームにパネルを追加
        add(panel);
    }

    /**
     * アプリケーションのメインエントリポイント。
     * GUIをイベントディスパッチスレッドで安全に起動します。
     *
     * @param args コマンドライン引数 (未使用)
     */
    public static void main(String[] args) {
        // SwingのGUI操作はイベントディスパッチスレッド(EDT)で行うことが推奨される
        SwingUtilities.invokeLater(() -> {
            new SelectableGuiApp().setVisible(true); // GUIアプリケーションのインスタンスを作成し、表示
        });
    }
}
```
</p>
</details>