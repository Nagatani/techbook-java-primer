<!-- 
校正チャンク情報
================
元ファイル: chapter02-getting-started.md
チャンク: 3/9
行範囲: 375 - 560
作成日時: 2025-08-02 22:43:26

校正時の注意事項:
- 文章の流れは前後のチャンクを考慮してください
- このヘッダーとフッターは校正対象外です
- 校正が完了したらステータスを「completed」に変更してください
================
-->

#### 演算子の詳細動作

- ①　基本算術演算
    + 加算、減算、乗算は通常の数学演算と同じ。
- ②　整数除算
    + int同士の除算は小数部を切り捨て（10÷3=3）
- ③　剰余演算
    + 割り算の余りを返す（10÷3の余り1）
- ④　後置インクリメント
    + 値を使用してから1増加（yに5を代入後、xを6に）
- ⑤　前置インクリメント
    + 1増加してから値を使用（xを7にしてからzに代入）
- ⑥　比較演算
    + 2つの値を比較して真偽値を返す。
- ⑦　論理演算
    + &&と||は短絡評価（左辺で結果が確定したら右辺を評価しない）
- ⑧　ビット演算
    + 2進数のビット単位で論理演算を実行。

### 演算子の優先順位

Javaの演算子には優先順位があり、式の評価順序を決定します。以下は主要な演算子の優先順位表です（上位ほど優先順位が高い）。

| 演算子 | 説明 | 結合性 |
|--------|------|-------------|
| `()` `[]` `.` | 括弧、配列アクセス、メンバーアクセス | 左→右 |
| `++` `--` (後置) | 後置インクリメント/デクリメント | 左→右 |
| `++` `--` (前置) `+` `-` `!` `~` | 単項演算子 | 右→左 |
| `*` `/` `%` | 乗算、除算、剰余 | 左→右 |
| `+` `-` | 加算、減算 | 左→右 |
| `<<` `>>` `>>>` | シフト演算 | 左→右 |
| `<` `<=` `>` `>=` `instanceof` | 比較演算 | 左→右 |
| `==` `!=` | 等価演算 | 左→右 |
| `&` | ビットAND | 左→右 |
| `^` | ビットXOR | 左→右 |
| <code>\|</code> | ビットOR | 左→右 |
| `&&` | 論理AND | 左→右 |
| <code>\|\|</code> | 論理OR | 左→右 |
| `?:` | 条件（三項）演算子 | 右→左 |
| `=` `+=` `-=` など | 代入演算子 | 右→左 |

#### 優先順位の実例

```java
// 優先順位により結果が変わる例
int a = 2 + 3 * 4;     // 14 (3*4が先、その後+2)
int b = (2 + 3) * 4;   // 20 (括弧内が優先)

// 論理演算の優先順位
boolean result = true || false && false;  // true (&&が||より優先)
// 上記は true || (false && false) と解釈される

// 代入と比較の優先順位
int x = 5;
boolean check = x = 3 > 0;  // コンパイルエラー
boolean check2 = (x = 3) > 0;  // OK: x=3の後、3>0を評価
```

複雑な式では括弧を使用して意図を明確にすることを推奨します。コンパイラの最適化により、明示的な括弧の使用がパフォーマンスに悪影響を与えることはありません。

## 型変換

### 型変換の基本概念と設計思想

Javaの型変換システムは、プログラムの安全性を保証するために厳格に設計されています。C言語では暗黙的に行われていた多くの型変換が、Javaでは明示的なキャストを要求されます。これは一見煩雑に思えますが、予期しないデータ損失やバグを防ぐ重要なしくみです。

### 型変換の分類

型変換には、データの精度を失わない拡大変換（widening conversion）と、精度を失う可能性がある縮小変換（narrowing conversion）があります。

#### 拡大変換の特徴
- データ損失がない安全な変換
- 暗黙的に（自動的に）実行される
- 小さい型から大きい型への変換
- 例`byte → short → int → long → float → double`

#### 縮小変換の特徴
- データ損失の可能性がある
- 明示的なキャストが必要
- 大きい型から小さい型への変換
- プログラマーの責任で実行

### 他言語との比較による理解

#### C言語との違い
```c
// C言語では暗黙的な変換が多い
double pi = 3.14159;
int truncated = pi;  // 警告は出るが、コンパイルは通る
```

C言語では、上記のような危険な変換も警告レベルで許可されますが、Javaではコンパイルエラーになります。


<span class="listing-number">**サンプルコード2-10**</span>

```java
public class TypeConversionExample {
    public static void main(String[] args) {
        // 暗黙的な型変換（拡大変換）
        int i = 100;
        long l = i;        // OK: int → long（32ビット → 64ビット）
        double d = i;      // OK: int → double（整数 → 浮動小数点）
        
        System.out.println("int: " + i);     // 100
        System.out.println("long: " + l);    // 100
        System.out.println("double: " + d);  // 100.0
        
        // 明示的な型変換（縮小変換）
        double pi = 3.14159;
        int truncated = (int) pi;  // 3（小数部分は切り捨て）
        
        // オーバーフローの例
        int largeInt = 130;
        byte smallByte = (byte) largeInt;  // -126（オーバーフロー）
        
        System.out.println("元の値: " + largeInt);
        System.out.println("byte変換後: " + smallByte);
        
        // 文字列との変換
        String str = "123";
        int num = Integer.parseInt(str);     // 文字列→整数
        String str2 = String.valueOf(num);   // 整数→文字列
        
        // 数値解析のエラー処理
        try {
            String invalidStr = "abc";
            int invalid = Integer.parseInt(invalidStr);  // NumberFormatException
        } catch (NumberFormatException e) {
            System.out.println("数値変換エラー: " + e.getMessage());
        }
    }
}
```
実行結果：
```
int: 100
long: 100
double: 100.0
元の値: 130
byte変換後: -126
数値変換エラー: For input string: "abc"
```

### 型変換の実践的な利点

#### 精度を考慮した計算
```java
// 整数同士の除算での落とし穴
int a = 5, b = 2;
double result1 = a / b;         // 2.0（整数除算後に変換）
double result2 = (double)a / b; // 2.5（浮動小数点除算）
```

#### メモリ効率の最適化
```java
// 大量のデータを扱う場合の型選択
byte[] imageData = new byte[1024 * 1024];  // 1MBのバイト配列
int[] inefficient = new int[1024 * 1024];   // 4MBの整数配列（非効率）
```

#### APIとの整合性
```java
// 多くのJava APIは特定の型を要求
Math.sqrt(25);        // double型を要求
Math.round(3.7f);     // float型を受け付ける
Collections.shuffle(list, new Random(42L));  // long型のシード
```

### 型変換のベストプラクティス

1. 必要最小限のキャスト
    + 型変換は最小限に抑え、設計段階でデータの性質に合った型を選択する
2. データ損失の確認
    + 縮小変換を行う前に、値の範囲を確認する
3. 例外処理の実装
    + 文字列から数値への変換では、NumberFormatExceptionをキャッチしてエラーメッセージを表示するなどの例外処理を実装する
4. 定数の型指定
    + リテラルには明示的な型サフィックスを使用（long型には`100L`、float型には`3.14f`、double型には`3.14d`またはサフィックスなし）

## コンソール入出力

### 標準入出力の設計思想

プログラムとユーザーの対話は、多くのアプリケーションにおいて基本的な要素です。Javaでは、標準入出力を扱うためのクラスが`java.lang`パッケージと`java.util`パッケージに用意されています。C言語の`printf()`や`scanf()`に相当する機能を提供しています。



<!-- 
================
チャンク 3/9 の終了
校正ステータス: [ ] 未完了 / [ ] 完了
================
-->
