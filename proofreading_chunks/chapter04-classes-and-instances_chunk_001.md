<!-- 
校正チャンク情報
================
元ファイル: chapter04-classes-and-instances.md
チャンク: 1/11
行範囲: 1 - 168
作成日時: 2025-08-02 23:30:11

校正時の注意事項:
- 文章の流れは前後のチャンクを考慮してください
- このヘッダーとフッターは校正対象外です
- 校正が完了したらステータスを「completed」に変更してください
================
-->

# <b>4章</b> <span>クラスとインスタンス</span> <small>オブジェクトの生成と連携</small>

## 本章の学習目標

### この章で学ぶこと

1. カプセル化の実践
    - アクセス修飾子（public、private、protected）の使い分け
    - getter/setterメソッドによる安全なデータアクセス
    - データ検証とバリデーションの実装
2. コンストラクタの活用
    - デフォルトコンストラクタと引数付きコンストラクタ
    - thisキーワードによるフィールドアクセス
    - コンストラクタのオーバーロード
3. クラス設計のベストプラクティス
    - 単一責任の原則に基づく設計
    - 不変性（イミュータブル）の重要性
    - 責任の明確なメソッド設計
4. パッケージシステム
    - パッケージの概念と命名規則
    - import文の効果的な使い方
    - クラスの組織化とアクセス制御

### この章を始める前に

第3章でクラスとオブジェクトの基本を理解していれば準備完了です。本章では、実践的で安全なクラス設計の技術を身につけます。

## なぜカプセル化が重要なのか

### 銀行口座クラスの復習と発展

第3章では基本的なクラスの作り方を学習しました。本章では、実践的なカプセル化の技術を、銀行口座クラスの段階的な改善を通じて学んでいきます。

まずは、カプセル化を適用していない問題のあるクラスから始めて、段階的に改善していく過程を見ていきましょう。

以下のコードは、カプセル化を適用していない銀行口座クラスの例です。
このコードは一見動作しますが、実際のシステムでは深刻なセキュリティリスクとデータ整合性の問題を引き起こします。各問題点をコメントで示しています。

<span class="listing-number">**サンプルコード4-1**</span>

```java
// 初期バージョン：カプセル化なし（問題のある設計）
public class BankAccountV0 {
    public String accountNumber;
    public double balance;
    
    public BankAccountV0(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }
}

// 使用例
public class ProblemDemo {
    public static void main(String[] args) {
        BankAccountV0 account = new BankAccountV0("123456", 10000);
        
        // 問題1: 直接残高を変更できてしまう
        account.balance = -1000;  // 不正な値の設定が可能
        
        // 問題2: 口座番号を後から変更できてしまう
        account.accountNumber = "999999";  // 口座番号の改ざん
        
        // 問題3: 取引履歴が残らない
        account.balance += 5000;  // 入金の記録がない
    }
}
```

これはカプセル化を適用していない問題のある設計例です。

#### このコードの問題点
- カプセル化の欠如
    + すべてのフィールドがpublicで、外部から自由にアクセス・変更可能
- データの整合性
    + 不正な値（負の残高など）を防ぐ仕組みがない
- 変更の追跡
    + 誰がいつ値を変更したか記録できない
- ビジネスルールの実装場所
    + 入出金のルールをクラス外部で実装する必要がある

これらの問題を解決するために、カプセル化という技術を使います。本章では、このBankAccountクラスを段階的に改善しながら、実践的なカプセル化の技術を身につけていきます。

## カプセル化とアクセス制御

### カプセル化の基本概念

カプセル化は、関連するデータ（フィールド）と処理（メソッド）を1つのクラスにまとめ、外部から直接アクセスできないよう保護する技術です。これにより、オブジェクトの内部状態を安全に管理できます。

### アクセス修飾子の詳細

Javaのアクセス制御は、カプセル化を実現する重要な機能です。Javaは4つのアクセス修飾子を提供しており、これらをパッケージ構造や継承関係に応じて使い分けると、クラスの内部実装を隠蔽しながら必要な機能だけを外部に公開できます。各修飾子は、フィールドとメソッドの可視性を段階的に制御し、オブジェクト指向設計の原則である「必要最小限の公開」を実現します。

#### アクセス修飾子の可視性マトリックス

| 修飾子 | 同じクラス | 同じパッケージ | サブクラス（別パッケージ） | それ以外（別パッケージ） | 説明 |
|--------|-----------|---------------|---------------------------|-------------------------|------|
| `private` | ○ | × | × | × | 同じクラス内からのみアクセス可能 |
| (なし)※ | ○ | ○ | × | × | 同じパッケージ内からのみアクセス可能 |
| `protected` | ○ | ○ | ○ | × | 同じパッケージまたはサブクラスからアクセス可能 |
| `public` | ○ | ○ | ○ | ○ | どこからでもアクセス可能 |

※ 修飾子を記述しない場合（デフォルトアクセス、package-privateとも呼ばれる）

<div class="figure">

![アクセス修飾子の可視性範囲](images/diagrams/figure04-01.png)

</div>

#### アクセス修飾子の使い分け原則

1. `private`を基本とする
    + フィールドは原則として`private`にし、外部からの読み取りが必要ならgetter、変更が必要ならsetterを提供
2. `public`は慎重に
    + 外部APIとして公開が必要なメソッドのみ`public`にする
3. `protected`の活用
    + サブクラスからのアクセスが必要なメソッドやフィールドに使用し、継承を前提とした設計であることを明示
4. パッケージプライベートの戦略的使用
    + 関連する複数のクラスが密に連携する場合（例：データアクセス層の内部処理）に使用

#### 各アクセス修飾子の詳細と使用例

##### `private`の使用例

<span class="listing-number">**サンプルコード4-2**</span>

```java
public class BankAccount {
    private double balance;      // 外部から直接変更不可
    private String accountId;    // 内部管理用ID
    
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;   // 同じクラス内からは可視
            logTransaction();    // プライベートメソッドの呼び出し
        }
    }
    
    private void logTransaction() {  // 内部処理専用メソッド
        // トランザクションログの記録
    }
}

// テスト用のクラス
class BankAccountTest {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        
        // フィールドは直接アクセスできない
        // account.balance = 1000; // コンパイルエラー
        
        // publicメソッドを通じて操作
        account.deposit(5000);
        // getBalanceメソッドは未実装のため、残高は表示できません
        System.out.println("入金処理が完了しました");
        
        // privateメソッドは呼び出せない
        // account.logTransaction(); // コンパイルエラー
    }
}
```

実行結果：
```
入金処理が完了しました
```



<!-- 
================
チャンク 1/11 の終了
校正ステータス: [ ] 未完了 / [ ] 完了
================
-->
