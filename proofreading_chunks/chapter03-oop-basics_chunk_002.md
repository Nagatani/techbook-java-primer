<!-- 
校正チャンク情報
================
元ファイル: chapter03-oop-basics.md
チャンク: 2/15
行範囲: 192 - 374
作成日時: 2025-08-02 22:58:07

校正時の注意事項:
- 文章の流れは前後のチャンクを考慮してください
- このヘッダーとフッターは校正対象外です
- 校正が完了したらステータスを「completed」に変更してください
================
-->

### よりよく継続的な開発を行うために

C言語でも十分なプログラミングは可能ですが、現実のソフトウェア開発では、プログラムの作成は全体の一部にすぎません。
作成されたプログラムは、その後長期にわたる「保守・運用」のフェーズに入り、この期間は開発期間よりもはるかに長く、コストも大きくなるのが一般的です。

このような現実を踏まえると、プログラミング言語には単に動くプログラムを作る以上の要求が求められます。
まず、開発の効率化が重要です。同じ機能を何度も実装するのではなく、既存のコードを再利用し、新たな機能をすばやく追加できる必要があります。

次に、保守性の向上が不可欠です。
要求の変化やバグ修正の際に、変更箇所が明確で、変更の影響範囲が限定されていることが理想です。
そして、品質の向上も欠かせません。バグが少なく、意図が明確で、拡張性の高いコードを書けば、長期的な成功につながります。

これらの要求を満たすための強力なアプローチが、オブジェクト指向プログラミングなのです。

### 大規模で長期的に維持可能なプログラムを作る

「もっと効率よくしたい」という要望から、オブジェクト指向という考え方が登場しました。
より効率よくプログラミングを行い、保守運用を見据えた概念であることを理解してオブジェクト指向を学んでください。

実際、現代のプログラミングでは、オブジェクト指向だけでなく、さまざまなパラダイムを組み合わせて使うことが一般的です。
関数型プログラミング、並行プログラミング、リアクティブプログラミングなども併用されます。
オブジェクト指向は、これらのなかの1つのアプローチに過ぎません。



## オブジェクト指向の基本概念を実際のコードで理解する

理論的な説明の前に、実際のJavaコードを見てオブジェクト指向の基本概念を理解しましょう。

### 手続き型とオブジェクト指向の違い

#### 手続き型の例（C言語風）

手続き型プログラミングでは、データと処理が分離された構造となります。以下の例では、この分離がどのような問題を引き起こすかを示します。

<span class="listing-number">**サンプルコード3-1**</span>

```java
public class ProceduralExample {
    public static void main(String[] args) {
        String studentName = "田中太郎";  // ①
        int studentAge = 20;             // ①
        double studentGpa = 3.5;         // ①
        
        printStudent(studentName, studentAge, studentGpa);  // ②
    }
    
    public static void printStudent(String name, int age, double gpa) {  // ③
        System.out.println("名前: " + name + ", 年齢: " + age + ", GPA: " + gpa);
    }
}
```

実行結果：
```
名前: 田中太郎, 年齢: 20, GPA: 3.5
```

#### 構造的問題の分析

- ①　データの散在
    + 学生に関する情報（名前、年齢、GPA）が独立した変数として存在し、これらが1つの概念（学生）を表すという関係性がコード上で明確でない
- ②　パラメータ渡しの煩雑さ
    + 関連するデータを処理するたびに、すべてのパラメータを個別に渡す必要があり、データの追加や変更時に多くの関数の引数リストを修正する必要がある
- ③　責任の分散
    + 学生データの検証、変更、表示など、学生に関する処理が複数の場所に散らばり、どこで何をしているかが把握しにくい

#### オブジェクト指向の例

オブジェクト指向では、関連するデータと処理を1つのクラスに統合し、概念の一貫性と責任の明確化を実現します。

<span class="listing-number">**サンプルコード3-2**</span>

```java
public class Student {
    private String name;  // ①
    private int age;      // ①
    private double gpa;   // ①
    
    public Student(String name, int age, double gpa) {  // ②
        this.name = name;
        this.age = age;
        this.gpa = gpa;
    }
    
    public void printInfo() {  // ③
        System.out.println("名前: " + name + ", 年齢: " + age + ", GPA: " + gpa);
    }
}

public class ObjectOrientedExample {
    public static void main(String[] args) {
        Student student = new Student("田中太郎", 20, 3.5);  // ④
        student.printInfo();  // ⑤
    }
}
```

実行結果：
```
名前: 田中太郎, 年齢: 20, GPA: 3.5
```

#### オブジェクト指向の利点の実現

- ①　データのカプセル化
    + 学生に関するすべての属性をprivateフィールドとして一箇所に集約し、外部からの直接アクセスを制限する
- ②　初期化の保証
    + コンストラクタにより、オブジェクト生成時に必要なデータがすべて設定されることを保証する
- ③　振る舞いの局所化
    + 学生データの表示処理がStudentクラス内部に定義され、データとその操作の責任が明確になる
- ④　概念の一体性
    + `Student`オブジェクトとして学生という概念を直接的にプログラムで表現される
- ⑤　インターフェイスの簡潔性
    + 外部からは単純にメソッドを呼び出すだけで、内部の複雑さを隠蔽

### オブジェクト指向の3つの基本原則

#### カプセル化

##### データ保護と制御されたアクセスの実現

カプセル化は、オブジェクトの内部データを外部から直接アクセスできないように保護し、入力値の検証やビジネスルールの適用を含むメソッドを通じてのみ操作を許可する仕組みです。

<span class="listing-number">**サンプルコード3-3**</span>

```java
public class BankAccount {
    private double balance;  // ①
    
    public void deposit(double amount) {  // ②
        if (amount > 0) {
            balance += amount;
        }
    }
    
    public double getBalance() {  // ③
        return balance;
    }
}
```

使用例と実行結果：
```java
// BankAccountTest.java
public class BankAccountTest {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        System.out.println("初期残高: " + account.getBalance() + "円");
        
        account.deposit(10000);
        System.out.println("10000円入金後: " + account.getBalance() + "円");
        
        account.deposit(-5000);  // 負の値は無視される
        System.out.println("負の値入金後: " + account.getBalance() + "円");
    }
}
```

実行結果：
```
初期残高: 0.0円
10000円入金後: 10000.0円
負の値入金後: 10000.0円
```

##### カプセル化の効果

- ①　データの隠蔽
    + `private`修飾子により残高データを直接操作できないようにし、不正な値の設定を防止
- ②　制御された変更
    + 入金処理では金額の妥当性を検証してから残高を更新し、負の値の入金を防ぐ
- ③　安全な読み取り
    + 残高の確認は可能だが、直接的な変更はできないため、データの整合性を保証

<div class="figure">

![カプセル化によるデータ保護とアクセス制御](images/diagrams/figure03-02.png)

</div>

#### 継承



<!-- 
================
チャンク 2/15 の終了
校正ステータス: [ ] 未完了 / [ ] 完了
================
-->
