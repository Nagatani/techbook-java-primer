<!-- 
校正チャンク情報
================
元ファイル: chapter03-oop-basics.md
チャンク: 7/12
行範囲: 1390 - 1632
作成日時: 2025-08-02 14:34:01

校正時の注意事項:
- 文章の流れは前後のチャンクを考慮してください
- このヘッダーとフッターは校正対象外です
- 校正が完了したらステータスを「completed」に変更してください
================
-->

##### 手続き型プログラミング（C言語）

```c
// データと処理が分離している
struct Student {
    char name[50];
    int age;
    double gpa;
};

void printStudent(struct Student s) {
    printf("名前: %s, 年齢: %d, GPA: %.2f\n", s.name, s.age, s.gpa);
}
```

#### 手続き型プログラミングの根本的課題

手続き型プログラミングでは、データと処理の分離によって複数の深刻な問題が生じます。まず、データの一貫性管理がきわめて困難になります。Studentデータを変更する関数が複数存在する場合、どの関数がどのタイミングでデータを変更するかを追跡することが困難で、データの整合性を保つためには開発者が常に全体の状況を把握してください。これは大規模なシステムになるほど現実的でなくなります。

次に、変更の影響範囲が広範囲に拡大してしまう問題があります。たとえば、Student構造体に新しいフィールド（たとえば所属学部）を追加する場合、そのデータを使用するすべての関数を見つけ出して修正してください。これは、システムの規模が大きくなるほど見落としやバグの原因となり、保守性を著しく低下させます。

さらに、責任の所在があいまいになることも重要な課題です。データの検証、初期化、出力、業務ロジックなど、学生に関する処理がシステム全体に散らばってしまうため、どの部分がどの機能を担当しているのかが不明確になります。これにより、バグの原因特定や機能追加が困難になり、開発効率が低下します。

#### オブジェクト指向プログラミングによる解決

オブジェクト指向では、関連するデータとそれを操作する処理を1つのクラスにまとめることで、上記の問題を解決します。

##### オブジェクト指向プログラミング（Java）

<span class="listing-number">**サンプルコード3-15**</span>

```java
// データと処理が一体化している
public class Student {
    private String name;
    private int age;
    private double gpa;
    
    // データを操作するメソッドも同じクラス内に定義
    public void printInfo() {
        System.out.println("名前: " + name + ", 年齢: " + age + ", GPA: " + gpa);
    }
}
```

これは手続き型との比較のためのクラス構造の例です。

#### オブジェクト指向プログラミングによる問題解決

オブジェクト指向プログラミングは、手続き型プログラミングの課題を体系的に解決します。もっとも重要な改善点は責任の明確化です。学生に関するすべての操作がStudentクラス内に集約されることで、データの管理責任が明確になり、どこに何の機能があるかが一目瞭然になります。これにより、バグの原因特定や機能追加が劇的に簡単になります。

カプセル化による保護機能も重要な利点です。privateキーワードを使用することで、外部からの不正なデータアクセスを防ぎ、データの整合性を確実に保護できます。これは、手続き型プログラミングでは実現困難だった、データの安全性を保証する仕組みです。

変更の局所化も大きなメリットです。学生に関する処理の変更は、Studentクラス内のみで完結し、システム全体への影響を最小限に抑えるできます。たとえば、成績計算のロジックを変更する場合、Studentクラス内の該当メソッドのみを修正すれば済み、他のクラスに影響を与えません。

さらに、現実世界のモデリングが可能になることで、プログラムの理解しやすさが向上します。「学生」という概念を直接的にプログラムの構造に反映させることで、直感的で理解しやすいコードになり、チーム開発での意思疎通も円滑になります。

### main関数に処理を突っ込むのではなく

自分の作っているプログラムをよく分析して、どんな登場人物（データ）がいるか、それぞれどんな役割があるかで考え、クラスに分割しましょう。

ここでは、小さい子ども（あなたはその子を世話する親とする）の着替えを例に考えてみましょう。
小さい子どもに対して着替えの指示を出す場合、細かくすべてを指示するでしょうか。
たとえば、対象の子どもが上着を着ているか確認し、近づいてボタンを外し、右腕から袖を通して脱がせるなど、毎回すべての手順を指示するのは手間がかかります。

毎回、状態を確認しつつすべての行動を指示出しするのは面倒でありませんか？
子どもには、「あなたは、着替えてください（服を）」というような命令で指示を出せて、結果だけ受け取ることができたらよいですね。


### 全部自分のプログラムでやろうとしない

自分が作ったクラスから、役割を持つほかのオブジェクトに対して指示を出すことで、関心の分離が可能となります。
大事なポイントとして、「処理をほかのオブジェクトにお任せする」ということが挙げられます。

### 処理をお任せすることと、お任せされる側の配慮

オブジェクトに処理をお任せする以上、そのオブジェクトの状態や振る舞いに外から干渉したくない（されたくもない）。

- オブジェクトが持つ状態や、状態に対する変更処理を外部から直接触られると、予期せぬ不具合や、副作用が発生する
    + 意図しない操作をされたくない部分を、外部から操作できないようにする

これを**カプセル化（隠ぺい）**といいます。

カプセル化を施すことで、内部実装の変更による影響を局所化し、バグの混入を防ぎ、APIの安定性を保つできます。

### 設計時に振る舞いの名前や入出力情報だけ決める
昨今のオブジェクト指向言語には、インターフェイスという概念があります。
インターフェイスにはクラスの振る舞いの名前や渡されるべきデータ型、振る舞いによる結果のデータ型だけを定義しておけます。

- インターフェイスは、それ自体をデータ型として使える便利なもの
- オブジェクト指向は、プログラミングだけでなく設計としての側面も強い

### オブジェクト指向言語でつまずやすい継承

難しく考える必要はありません。
同じ状態、同じ振る舞いを持つクラスをそれぞれコピー&ペーストで作ると、管理が煩雑になってしまいます。

「似たデータ、似た処理をもつオブジェクトを、クラスの時点でまとめよう」として使用するのが継承という考え方になります。
単にまとめるための手段だと知っておきましょう。

このような設計では、「従業員クラス」「マネージャークラス」がそれぞれ「人事管理可能」インターフェイスを実装する場合もあります。
これにより、どちらも「人事評価機能」を持つできます。

ただし、実際のシステムでは権限管理やロールベースのアクセス制御など、より洗練されたアプローチが必要です。

### オブジェクト指向は効率よく開発を行うための考え方

大事な観点として、歴史をたどり、システム開発の効率を求めた結果、オブジェクト指向という体系ができたに過ぎません。

これは通過点であり、オブジェクト指向の考え方を学ぶことですべてのことが説明できる気になったりします<span class="footnote">これはプログラマの三大美徳の1つである「傲慢」ですね。</span>が、これですべてを賄えることはありません。
本書では、オブジェクト指向という道具を学びますが、これはただのプログラミングテクニックの1つとして、システムの要求や規模に応じて使い分けられるよう、判断基準と実装方法を身に付けましょう。


> **コラム：システム開発に「銀の弾丸などない」**{.column-section}
> 
> ### 「人月の神話」
> 
> フレッド・ブルックスが1975年に著した「人月の神話」で述べられているように、ソフトウェア開発の複雑性を一挙に解決する「銀の弾丸」は存在しません。
> ここで言う「銀の弾丸」とは、システム開発におけるあらゆる問題を一挙に解決できるような、魔法のような特効薬や万能な解決策を指す比喩表現です。
> 過去の文献ではオブジェクト指向プログラミングも万能の解決策かのように言われることもありますが、例外ではなく、万能の解決策ではありません。
> 
> オブジェクト指向を不適切に適用した場合、返って問題を悪化させることがあります。
> たとえば、100行未満のスクリプトや単機能のコマンドラインツールにオブジェクト指向を無理に取り入れた場合です。
> シンプルな処理が複雑なクラス構造に埋もれてしまい、コードの記述量が数倍に膨れ上がることがあります。
> また、バッチ処理やパイプライン処理のように、単機能の処理が連続して呼び出されるシステムでは問題が生じます。
> オブジェクト指向のオーバーヘッドが大きくなり、手続き型のアプローチのほうがメモリ使用量を抑えられる場合があります。
> さらに、過度な抽象化や継承の乱用は、コードの理解を困難にし、管理しきれない副作用を発生させる可能性があります。
> 
> 重要なのは、オブジェクト指向が有効な場面を見極め、適度に使用することです。
> 一般的に、以下の場合にオブジェクト指向が有効です。
> 
> 1. 複数の開発者が長期間保守するシステム
> 2. ドメインモデルが複雑なビジネスアプリケーション
> 3. 再利用可能なコンポーネントを作る場合
> 
> #### なぜ「銀の弾丸」は存在しないのか？
>
> 少し内容は逸れますが、システム開発の難しさは、本質的に複雑な問題を扱っていることに起因します。
> 「人月の神話」の著者ブルックスは、この困難さを以下の2つに分類しました。
>
> 1. 本質的な困難さ (Essence)
>     - ソフトウェアが解決しようとする問題そのものの複雑さ、仕様の曖昧さ、満たすべき要求の多さなど、避けることのできない根源的な難しさ
> 2. 偶有的な困難さ (Accident)
>     - プログラミング言語の扱いにくさ、開発ツールの未熟さ、非効率な開発プロセスなど、技術や手法によって改善・解決できる副次的な難しさ
> 
> 過去数十年にわたり、プログラミング言語の進化、開発ツールの改善、新しい開発手法（アジャイルなど）の登場により、「偶有的な困難さ」は大幅に改善されてきました。しかし、「本質的な困難さ」は依然として残っています。
> どのような画期的な技術や手法が登場したとしても、開発プロジェクトが直面する以下のような本質的な問題を完全に消し去ることはできません。
> - 要件の複雑さと変化
>     + 顧客の要求は複雑であり、開発の途中で変化することも少なくない
> - コミュニケーションの問題
>     + 関係者間の認識の齟齬や情報伝達の漏れ
> - 設計の難しさ
>     + 将来の変更を見越した、柔軟で堅牢なシステムを設計することの困難さ。
> - 人間の思考の限界
>     + 複雑なシステム全体を一度に正確に把握することの難しさ。
> 
> したがって、特定の1つの技術や方法論を導入すれば、すべての開発プロジェクトが必ず成功するという「銀の弾丸」は存在しないのです。
> 成功のためには、地道なコミュニケーション、慎重な設計、継続的な改善といった日々の努力が不可欠となります。

## クラスとオブジェクト

### クラスの定義

クラスの定義は、オブジェクト指向プログラミングの核心部分です。ここでは、「本」という現実世界の概念をプログラムで表現する方法を学びます。クラス設計では、そのオブジェクトが「何を知っているか（属性）」と「何ができるか（操作）」を明確に定義することが重要です。

以下のBookクラスは、本という概念の本質的な属性と操作を表現した例です。

<span class="listing-number">**サンプルコード3-16**</span>

```java
public class Book {
    // フィールド（属性）
    private String title;
    private String author;
    private int pages;
    private double price;
    
    // コンストラクタ
    public Book(String title, String author, int pages, double price) {
        this.title = title;
        this.author = author;
        this.pages = pages;
        this.price = price;
    }
    
    // メソッド（操作）
    public void displayInfo() {
        System.out.println("タイトル: " + title);
        System.out.println("著者: " + author);
        System.out.println("ページ数: " + pages);
        System.out.println("価格: " + price + "円");
    }
    
    // ゲッターメソッド
    public String getTitle() {
        return title;
    }
    
    public String getAuthor() {
        return author;
    }
    
    // セッターメソッド
    public void setPrice(double price) {
        if (price >= 0) {
            this.price = price;
        }
    }
}
```

使用例と実行結果：
```java
// BookClassTest.java
public class BookClassTest {
    public static void main(String[] args) {
        Book book = new Book("Java入門", "田中太郎", 300, 2800.0);
        
        book.displayInfo();
        System.out.println("---");
        
        // 価格変更
        book.setPrice(2500.0);
        System.out.println("価格変更後:");
        book.displayInfo();
    }
}
```

実行結果：
```
タイトル: Java入門
著者: 田中太郎
ページ数: 300
価格: 2800.0円
---
価格変更後:
タイトル: Java入門
著者: 田中太郎
ページ数: 300
価格: 2500.0円
```



<!-- 
================
チャンク 7/12 の終了
校正ステータス: [ ] 未完了 / [ ] 完了
================
-->
