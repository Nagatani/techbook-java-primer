# 第11章 基本課題

## 🎯 学習目標
- ラムダ式の基本構文と概念の理解
- 関数型インターフェイス（Function、Predicate、Consumer等）の活用
- メソッド参照の使い方（::演算子）
- 従来の匿名クラスからラムダ式への移行
- 関数型プログラミングの基本的な思考法

## 📝 課題一覧

### 課題1: 基本的なラムダ式の活用
**ファイル名**: `BasicLambda.java`, `BasicLambdaTest.java`

基本的なラムダ式を活用した処理を実装し、関数型インターフェイスを理解してください。

**要求仕様**:
- Predicate<T> を使った条件判定
- Function<T, R> を使ったデータ変換
- Consumer<T> を使った処理実行
- Supplier<T> を使った値生成
- Comparator<T> を使ったソート

**実行例**:
```
=== 基本的なラムダ式の活用 ===
数値リスト: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

Predicate（偶数判定）:
偶数: [2, 4, 6, 8, 10]

Function（2乗変換）:
元の値: [1, 2, 3, 4, 5]
2乗後: [1, 4, 9, 16, 25]

Consumer（出力処理）:
値の出力: 1, 2, 3, 4, 5

Supplier（ランダム値生成）:
ランダム値: 42, 17, 89, 33, 56

Comparator（ソート）:
文字列長さソート: ["a", "bb", "ccc", "dddd"]
逆順ソート: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

**評価ポイント**:
- ラムダ式の基本構文理解
- 関数型インターフェイスの適切な使用
- 型推論の活用

---

### 課題2: カスタム関数型インターフェイス設計
**ファイル名**: `CustomFunctionalInterface.java`, `MathOperation.java`, `StringProcessor.java`, `CustomFunctionalTest.java`

独自の関数型インターフェイスを設計し、ラムダ式で実装してください。

**要求仕様**:
- @FunctionalInterface アノテーション使用
- 数学演算用の関数型インターフェイス
- 文字列処理用の関数型インターフェイス
- デフォルトメソッドの活用
- 複数の実装パターン

**実行例**:
```
=== カスタム関数型インターフェイス設計 ===
数学演算テスト:
加算: 10 + 5 = 15
減算: 10 - 5 = 5
乗算: 10 * 5 = 50
除算: 10 / 5 = 2.0

複合演算:
(10 + 5) * 2 = 30
(10 - 5) / 2 = 2.5

文字列処理テスト:
大文字変換: "hello" → "HELLO"
小文字変換: "WORLD" → "world"
逆順変換: "Java" → "avaJ"

複合処理:
"hello world" → 大文字化 → 逆順 → "DLROW OLLEH"

条件付き処理:
長さ5以上の文字列のみ大文字化:
"hi" → "hi" (変換なし)
"hello" → "HELLO" (変換実行)
```

**評価ポイント**:
- 関数型インターフェイスの設計
- @FunctionalInterface の理解
- デフォルトメソッドとの組み合わせ

---

### 課題3: メソッド参照とコンストラクタ参照
**ファイル名**: `MethodReference.java`, `Person.java`, `MethodReferenceTest.java`

メソッド参照とコンストラクタ参照を活用した処理を実装してください。

**要求仕様**:
- 静的メソッド参照（Class::staticMethod）
- インスタンスメソッド参照（instance::method）
- 任意オブジェクトのインスタンスメソッド参照（Class::instanceMethod）
- コンストラクタ参照（Class::new）
- メソッド参照からラムダ式への変換比較

**実行例**:
```
=== メソッド参照とコンストラクタ参照 ===
静的メソッド参照テスト:
数値リスト: [1, 4, 9, 16, 25]
平方根: [1.0, 2.0, 3.0, 4.0, 5.0]

インスタンスメソッド参照テスト:
文字列リスト: ["hello", "world", "java"]
大文字変換: ["HELLO", "WORLD", "JAVA"]

任意オブジェクトのメソッド参照:
文字列長さ: [5, 5, 4]

コンストラクタ参照テスト:
Person生成:
田中太郎（25歳）
佐藤花子（30歳）
鈴木一郎（35歳）

配列コンストラクタ参照:
整数配列: [0, 0, 0, 0, 0]
文字列配列: [null, null, null]

ラムダ式 vs メソッド参照比較:
ラムダ式: x -> Math.sqrt(x)
メソッド参照: Math::sqrt
結果は同じ: [1.0, 2.0, 3.0]
```

**評価ポイント**:
- 4種類のメソッド参照の理解
- コンストラクタ参照の活用
- ラムダ式との使い分け

---

### 課題4: 高階関数とカリー化
**ファイル名**: `HigherOrderFunction.java`, `HigherOrderFunctionTest.java`

高階関数とカリー化を実装し、関数型プログラミングの高度な概念を理解してください。

**要求仕様**:
- 関数を引数として受け取る高階関数
- 関数を戻り値として返す高階関数
- カリー化（部分適用）の実装
- 関数の合成（compose、andThen）
- 遅延評価の実装

**実行例**:
```
=== 高階関数とカリー化 ===
高階関数テスト（関数を引数に取る）:
リスト: [1, 2, 3, 4, 5]
処理1（2倍）: [2, 4, 6, 8, 10]
処理2（2乗）: [1, 4, 9, 16, 25]

高階関数テスト（関数を返す）:
加算器生成:
add5 = createAdder(5)
add5(10) = 15
add5(20) = 25

カリー化テスト:
三項演算: f(x, y, z) = x + y * z
カリー化: f(2)(3)(4) = 2 + 3 * 4 = 14

部分適用:
multiply(2, 3) = 6
multiplyBy2 = multiply(2, _)
multiplyBy2(3) = 6
multiplyBy2(5) = 10

関数合成テスト:
f(x) = x * 2
g(x) = x + 3
compose: g(f(5)) = g(10) = 13
andThen: f(g(5)) = f(8) = 16

遅延評価テスト:
計算定義時: (処理なし)
実行時: 2 * 3 + 5 = 11
```

**評価ポイント**:
- 高階関数の概念理解
- カリー化と部分適用の実装
- 関数合成の活用

## 💡 ヒント

### 課題1のヒント
- ラムダ式: (parameters) -> expression
- 型推論により型は省略可能
- 単一文の場合は{}とreturnを省略可能

### 課題2のヒント
- @FunctionalInterface で単一抽象メソッドを保証
- デフォルトメソッドで共通処理を提供
- andThen() で処理の連鎖を実現

### 課題3のヒント
- 静的メソッド参照: Math::sqrt
- インスタンスメソッド参照: str::toUpperCase
- コンストラクタ参照: ArrayList::new

### 課題4のヒント
- Function<T, Function<U, R>> でカリー化
- Function.compose() で関数合成
- Supplier<T> で遅延評価を実現

## 🔍 ラムダ式と関数型インターフェイスのポイント

1. **ラムダ式**: 匿名関数の簡潔な記法
2. **関数型インターフェイス**: 単一抽象メソッドを持つインターフェイス
3. **メソッド参照**: 既存メソッドのラムダ式代替記法
4. **高階関数**: 関数を引数や戻り値として扱う関数
5. **カリー化**: 複数引数関数を単一引数関数の連鎖に変換
6. **遅延評価**: 必要時まで計算を延期する手法

## ✅ 完了チェックリスト

- [ ] 課題1: 基本的なラムダ式と関数型インターフェイスが使えている
- [ ] 課題2: カスタム関数型インターフェイスが設計できている
- [ ] 課題3: メソッド参照の4パターンが理解できている
- [ ] 課題4: 高階関数とカリー化が実装できている
- [ ] ラムダ式の構文を正しく理解している
- [ ] 関数型プログラミングの基本概念を把握している

**次のステップ**: 基本課題が完了したら、advanced/の発展課題でより高度な関数型プログラミングに挑戦しましょう！