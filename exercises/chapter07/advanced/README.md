# 第7章 応用課題

## 🎯 学習目標
- 配列の高度な操作と活用
- 多次元配列の効果的な利用
- メモリ効率を考慮したデータ構造
- アルゴリズムの実装と最適化
- 大量データの処理技術

## 📝 課題一覧

### 課題1: 画像処理システム
**ファイル名**: `ImageProcessingSystem.java`

2次元配列を使った画像処理システムを作成してください。

**要求仕様**:
- RGB画像データの表現と操作
- 各種フィルター処理の実装
- 画像変換（回転、拡大縮小）
- ヒストグラム分析

**処理機能**:
- ぼかし、シャープ、エッジ検出
- 明度・コントラスト調整
- ノイズ除去
- 色調補正

**実行例**:
```
=== 画像処理システム ===

🖼️ AdvancedImageProcessor v2.0

=== 画像読み込み ===
✓ 画像ファイル: sample.jpg (1920x1080, RGB)
メモリ使用量: 6.2MB
処理時間: 0.15秒

画像情報:
- 解像度: 1920 × 1080 ピクセル
- 色深度: 24bit (RGB各8bit)
- ファイルサイズ: 2.8MB
- 圧縮率: 45%

=== RGB配列構造 ===
配列構成: int[1080][1920][3]
- [y][x][0]: Red (0-255)
- [y][x][1]: Green (0-255)  
- [y][x][2]: Blue (0-255)

メモリレイアウト最適化: 有効
キャッシュ効率: 92%

=== フィルター処理 ===

🌟 ガウシアンぼかし:
カーネルサイズ: 5×5
標準偏差(σ): 1.5

処理前 → 処理後:
シャープネス: 0.85 → 0.23
ノイズレベル: 0.12 → 0.03
処理時間: 0.8秒

⚡ エッジ検出 (Sobel):
水平エッジ検出:
| -1  0  1 |
| -2  0  2 |
| -1  0  1 |

垂直エッジ検出:
| -1 -2 -1 |
|  0  0  0 |
|  1  2  1 |

検出されたエッジ数: 45,678点
最大勾配値: 248
処理時間: 1.2秒

🔆 明度・コントラスト調整:
明度: +20% (0 → 51)
コントラスト: +15% (1.0 → 1.15)

ヒストグラム変化:
- 最小値: 15 → 35
- 最大値: 240 → 255
- 平均値: 128 → 148
- 標準偏差: 65 → 72

=== 画像変換 ===

🔄 90度回転 (時計回り):
元配列: image[1080][1920]
新配列: rotated[1920][1080]

変換マトリックス:
| 0  1  0 |
|-1  0  1080|
| 0  0  1 |

メモリ使用量: 一時的に2倍 (12.4MB)
処理時間: 0.6秒

📏 拡大縮小 (バイリニア補間):
元サイズ: 1920×1080
新サイズ: 3840×2160 (4K変換)

補間計算: 8,294,400回
品質保持率: 94%
処理時間: 3.2秒

=== ヒストグラム分析 ===

📊 色分布統計:
Red チャンネル:
- 最頻値: 142 (14.2%)
- 平均: 135
- 分散: 1,847

Green チャンネル:
- 最頻値: 128 (12.8%)
- 平均: 132
- 分散: 2,156

Blue チャンネル:
- 最頻値: 115 (11.5%)
- 平均: 118
- 分散: 2,389

色温度: 5,400K (やや暖色)
彩度: 65% (標準的)

=== 高度な処理 ===

🎭 顔検出 (Haar-like特徴):
検出されたオブジェクト:
- 顔: 3個 (信頼度: 92%, 87%, 76%)
- 目: 6個 (各顔に2個ずつ)
- 口: 3個

バウンディングボックス:
顔1: (450, 280) - (650, 480)
顔2: (1200, 180) - (1380, 360)
顔3: (800, 650) - (920, 770)

🌈 色空間変換:
RGB → HSV変換:
H(色相): 0-360度
S(彩度): 0-100%
V(明度): 0-100%

処理ピクセル数: 2,073,600
変換時間: 0.4秒

=== パフォーマンス統計 ===

⚡ 処理効率:
- 総処理時間: 6.45秒
- ピクセル処理速度: 321,395 pixels/sec
- メモリ効率: 94%
- CPU使用率: 78% (マルチコア活用)

メモリ使用量推移:
開始時: 6.2MB
ピーク時: 18.7MB (回転処理中)
終了時: 8.1MB (結果保持)

最適化効果:
- SIMD命令活用: +35%速度向上
- キャッシュ最適化: +22%速度向上
- 並列処理: +180%速度向上 (4コア)
```

**評価ポイント**:
- 2次元配列の効果的な活用
- 画像処理アルゴリズムの理解
- メモリ効率の最適化
- パフォーマンスチューニング



### 課題2: 大規模データ分析システム
**ファイル名**: `BigDataAnalyzer.java`

大量のデータを効率的に処理・分析するシステムを作成してください。

**要求仕様**:
- 大容量データセットの処理
- 統計分析とデータマイニング
- リアルタイム分析
- メモリ効率的なデータ構造

**分析機能**:
- 基本統計量の算出
- 相関関係の分析
- 時系列データの処理
- 異常値検出

**実行例**:
```
=== 大規模データ分析システム ===

📊 BigData Analytics Engine v3.0

=== データセット読み込み ===
✓ ファイル: sales_data_2024.csv
データサイズ: 2.1GB (10,000,000レコード)
カラム数: 15個
読み込み時間: 12.3秒

データ構造:
配列型: double[10000000][15]
メモリ使用量: 1.14GB
圧縮率: 54%

カラム情報:
[0] 日付 (timestamp)
[1] 商品ID (integer)
[2] 販売数量 (integer)
[3] 単価 (decimal)
[4] 売上 (decimal)
[5] 地域コード (integer)
[6] 顧客年齢 (integer)
[7] 顧客性別 (0/1)
[8] プロモーション適用 (0/1)
...

=== 基本統計分析 ===

📈 売上データ分析:
総売上: ¥45,678,901,234
平均売上/件: ¥4,568
中央値: ¥3,240
最大売上: ¥89,500 (1件)
最小売上: ¥98 (1件)

分布統計:
- 第1四分位: ¥1,890
- 第3四分位: ¥6,750
- 標準偏差: ¥3,456
- 歪度: 2.34 (右に歪んだ分布)
- 尖度: 8.92 (厚い裾の分布)

📊 商品別売上ランキング:
1位: 商品A (ID:1001) - ¥2,345,678,900 (5.1%)
2位: 商品B (ID:1205) - ¥1,987,543,200 (4.4%)
3位: 商品C (ID:1456) - ¥1,678,432,100 (3.7%)
...
トップ10で全体の38.7%を占有

=== 時系列分析 ===

📅 月次売上推移:
2024年1月: ¥3,456,789,012 (+12.3% YoY)
2024年2月: ¥3,234,567,890 (+8.7% YoY)
2024年3月: ¥4,123,456,789 (+15.6% YoY)
2024年4月: ¥3,890,123,456 (+9.2% YoY)
2024年5月: ¥4,234,567,890 (+18.4% YoY)
2024年6月: ¥4,456,789,123 (+21.7% YoY)

トレンド分析:
- 線形回帰係数: +0.125 (月次成長率)
- R²値: 0.847 (高い相関)
- 季節性指数: 1.15 (年末商戦効果)

移動平均:
- 3ヶ月移動平均: ¥3,938,271,567
- 12ヶ月移動平均: ¥3,804,942,605
- 指数平滑平均: ¥3,892,745,211

=== 相関分析 ===

🔗 変数間相関マトリックス:
          売上   数量   単価   年齢   性別
売上    1.000  0.743  0.892  0.234 -0.045
数量    0.743  1.000  0.156  0.198 -0.078
単価    0.892  0.156  1.000  0.187 -0.012
年齢    0.234  0.198  0.187  1.000  0.034
性別   -0.045 -0.078 -0.012  0.034  1.000

強い相関関係:
✓ 売上 ⟷ 単価 (r=0.892) - 高価格商品が売上を牽引
✓ 売上 ⟷ 数量 (r=0.743) - 数量と売上の正の関係
⚠ 年齢 ⟷ 売上 (r=0.234) - 中程度の関係

=== 異常値検出 ===

🚨 統計的異常値検出:
手法: Modified Z-Score (閾値: 3.5)

検出された異常値:
1. 2024-03-15: 売上¥89,500 (Z-score: 4.2)
   → 分析: 大口法人購入、正常な取引
   
2. 2024-05-22: 売上¥95,600 (Z-score: 4.7)
   → 分析: 特別キャンペーン効果、正常
   
3. 2024-06-03: 売上¥12 (Z-score: -3.8)
   → 分析: 返品処理の記録、要確認

異常値率: 0.03% (3,247件/10,000,000件)

=== クラスター分析 ===

🎯 顧客セグメント分析:
K-means クラスタリング (k=5)

クラスター1 (23.4%): 高価格志向
- 平均年齢: 45歳
- 平均単価: ¥8,950
- 特徴: 品質重視、ブランド志向

クラスター2 (31.2%): 価格重視
- 平均年齢: 32歳
- 平均単価: ¥2,340
- 特徴: コスパ重視、大容量商品好み

クラスター3 (18.7%): 年配層
- 平均年齢: 62歳
- 平均単価: ¥4,560
- 特徴: 定番商品、安定志向

クラスター4 (15.9%): 若年層
- 平均年齢: 24歳
- 平均単価: ¥3,120
- 特徴: トレンド商品、SNS影響大

クラスター5 (10.8%): プレミアム層
- 平均年齢: 51歳
- 平均単価: ¥15,670
- 特徴: 最高品質志向、ステータス重視

=== リアルタイム分析 ===

⚡ ストリーミング分析:
データ流入レート: 1,250件/秒
処理レート: 1,380件/秒 (余裕あり)
遅延時間: 0.12秒 (平均)

現在の状況 (過去1時間):
- 売上: ¥2,345,678 (+8.5% vs 前時間)
- 注文数: 1,456件 (+12.3%)
- 平均単価: ¥1,610 (-2.1%)
- トップ商品: 商品X (578件販売)

アラート:
🔔 商品Yの在庫が危険水準 (残り15個)
🔔 地域Zで売上が急増 (+45% vs 通常)

=== パフォーマンス報告 ===

⚡ 処理性能:
- データ読み込み: 805MB/秒
- 統計計算: 2.1M行/秒
- 相関分析: 1.8M行/秒
- 異常値検出: 3.2M行/秒

メモリ効率:
- 最大使用量: 1.34GB
- GC回数: 23回
- GC合計時間: 0.8秒
- メモリ効率: 91%

並列処理効果:
- CPUコア数: 8個
- 並列化率: 87%
- 速度向上: 6.2倍
- CPU使用率: 94%
```

**評価ポイント**:
- 大容量データの効率的な処理
- 統計分析アルゴリズムの実装
- メモリ使用量の最適化
- リアルタイム処理の実現



### 課題3: 3Dゲームエンジン基盤
**ファイル名**: `GameEngine3D.java`

3次元配列を活用した3Dゲームエンジンの基盤システムを作成してください。

**要求仕様**:
- 3D空間の表現と管理
- 3Dオブジェクトの配置と衝突判定
- ボクセルベースの地形生成
- 物理演算の基礎実装

**エンジン機能**:
- 3D座標系とワールド管理
- レイキャスティング
- 地形生成アルゴリズム
- 3D衝突検出

**実行例**:
```
=== 3Dゲームエンジン基盤 ===

🎮 VoxelCraft Engine v1.0

=== ワールド初期化 ===
✓ ワールド生成: 1024×256×1024 ボクセル
メモリ使用量: 268MB (int[1024][256][1024])
チャンク分割: 64×64×64 (1,024個)

座標系設定:
- X軸: 東(+) ↔ 西(-)
- Y軸: 上(+) ↔ 下(-)  
- Z軸: 南(+) ↔ 北(-)
原点: (512, 128, 512)

ワールド境界:
- 最小: (-512, 0, -512)
- 最大: (512, 255, 512)
- 総体積: 268,435,456 ブロック

=== 地形生成 ===

🏔️ パーリンノイズ地形:
ノイズパラメータ:
- オクターブ数: 6
- 振幅減衰: 0.5
- 周波数倍率: 2.0
- シード値: 12345

高度マップ生成:
最低高度: 32 (海面下)
最高高度: 192 (山頂)
平均高度: 72
地形複雑度: 0.67

バイオーム配置:
🌊 海洋: 15.2% (高度 < 50)
🏖️ 海岸: 8.7% (高度 50-60)
🌾 平原: 35.8% (高度 60-80)
🌲 森林: 28.3% (高度 80-120)
🏔️ 山岳: 12.0% (高度 > 120)

=== ボクセル配置 ===

🧱 ブロック配置システム:
ブロックタイプ: 16種類
- 0: 空気 (透明)
- 1: 石 (灰色)
- 2: 土 (茶色)
- 3: 草 (緑)
- 4: 砂 (黄色)
- 5: 水 (青、半透明)
...

配置統計:
空気: 189,234,567 (70.5%)
石: 45,123,890 (16.8%)
土: 23,456,789 (8.7%)
草: 8,234,567 (3.1%)
その他: 2,385,643 (0.9%)

メモリ最適化:
空気ブロック: 圧縮表現
同一ブロック連続: RLE圧縮
圧縮率: 87% (36MB実使用)

=== 3D衝突判定 ===

🎯 衝突検出システム:
判定方式: AABB (Axis-Aligned Bounding Box)

プレイヤー1:
位置: (100.5, 72.0, 200.3)
サイズ: 0.6×1.8×0.6
速度: (2.1, 0, -1.5) blocks/sec

判定範囲:
Min: (100.2, 72.0, 200.0)
Max: (100.8, 73.8, 200.6)

重複ブロック検索:
検査範囲: 3×4×3 = 36ブロック
実際の重複: 0ブロック
移動可能: ✅

🏃 移動処理:
移動前: (100.5, 72.0, 200.3)
移動量: (0.35, 0, -0.25)
移動後: (100.85, 72.0, 200.05)

重力適用:
落下速度: -9.8 blocks/sec²
地面接触: Y=72 (草ブロック上)
落下停止: ✅

=== レイキャスティング ===

🔦 視線追跡システム:
レイ原点: プレイヤー視点 (100.85, 73.5, 200.05)
レイ方向: (0.707, -0.2, 0.707) [正規化済み]
最大距離: 100ブロック

DDA アルゴリズム:
ステップ数: 87回
判定ブロック数: 87個
ヒット検出: ✅

ヒット情報:
ヒット座標: (161.3, 68.2, 261.7)
ヒットブロック: (161, 68, 261) - 石ブロック
ヒット面: 上面 (+Y)
距離: 86.4ブロック

=== 物理演算 ===

⚛️ 基礎物理システム:
重力: (0, -9.8, 0) m/sec²
空気抵抗: 0.02
摩擦係数: 0.7

オブジェクト1 (投げられたアイテム):
位置: (105.2, 75.8, 198.7)
速度: (3.2, 8.5, -1.8)
加速度: (0, -9.8, 0)

軌道計算:
最高点: Y=79.5 (0.87秒後)
着地点: (112.8, 72.0, 196.1)
飛行時間: 1.74秒
飛行距離: 11.2ブロック

弾性衝突: 反発係数 0.6
バウンス予測: 3回バウンド後停止

=== チャンクローディング ===

🗺️ 動的ローディング:
プレイヤー周辺: 8×8チャンク
描画距離: 512ブロック
ロード済み: 64チャンク
メモリ使用量: 16.2MB

チャンク状態:
読み込み中: 4チャンク
生成済み: 60チャンク  
アンロード対象: 0チャンク

LOD (Level of Detail):
近距離 (0-128m): フル解像度
中距離 (128-256m): 1/2解像度
遠距離 (256-512m): 1/4解像度

=== パフォーマンス監視 ===

⚡ エンジン性能:
フレームレート: 60 FPS (16.67ms/frame)
描画時間: 8.2ms
物理演算: 2.1ms
AI処理: 1.4ms
その他: 5.0ms

メモリ使用量:
ワールドデータ: 36MB (圧縮後)
テクスチャ: 128MB
メッシュデータ: 45MB
総使用量: 209MB

CPU使用率:
描画スレッド: 45%
物理スレッド: 23%
AIスレッド: 12%
メインスレッド: 18%

最適化効果:
- 視錐台カリング: +28% FPS向上
- オクルージョンカリング: +15% FPS向上
- バッチング: +35% 描画性能向上
- 空間分割: +67% 衝突判定高速化
```

**評価ポイント**:
- 3次元配列の効果的な活用
- 3Dアルゴリズムの理解と実装
- メモリ効率とパフォーマンス
- ゲームエンジン設計の基礎

## 💡 実装のヒント

### 課題1のヒント
```java
class ImageProcessor {
    private int[][][] image; // [height][width][rgb]
    
    public void applyGaussianBlur(double sigma) {
        int kernelSize = (int)(6 * sigma) | 1; // 奇数に調整
        double[][] kernel = generateGaussianKernel(kernelSize, sigma);
        
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                for (int c = 0; c < 3; c++) {
                    image[y][x][c] = applyKernel(x, y, c, kernel);
                }
            }
        }
    }
    
    private double[][] generateGaussianKernel(int size, double sigma) {
        double[][] kernel = new double[size][size];
        double sum = 0;
        int center = size / 2;
        
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                double x = i - center;
                double y = j - center;
                kernel[i][j] = Math.exp(-(x*x + y*y) / (2 * sigma * sigma));
                sum += kernel[i][j];
            }
        }
        
        // 正規化
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                kernel[i][j] /= sum;
            }
        }
        return kernel;
    }
}
```

### 課題2のヒント
```java
class BigDataAnalyzer {
    private double[][] data; // [rows][columns]
    
    public CorrelationMatrix calculateCorrelation() {
        int cols = data[0].length;
        double[][] correlation = new double[cols][cols];
        
        // 平均値計算
        double[] means = new double[cols];
        for (int col = 0; col < cols; col++) {
            for (int row = 0; row < data.length; row++) {
                means[col] += data[row][col];
            }
            means[col] /= data.length;
        }
        
        // 相関係数計算
        for (int i = 0; i < cols; i++) {
            for (int j = 0; j < cols; j++) {
                correlation[i][j] = calculatePearsonCorrelation(i, j, means);
            }
        }
        
        return new CorrelationMatrix(correlation);
    }
    
    private double calculatePearsonCorrelation(int col1, int col2, double[] means) {
        double numerator = 0, sum1 = 0, sum2 = 0;
        
        for (int row = 0; row < data.length; row++) {
            double diff1 = data[row][col1] - means[col1];
            double diff2 = data[row][col2] - means[col2];
            numerator += diff1 * diff2;
            sum1 += diff1 * diff1;
            sum2 += diff2 * diff2;
        }
        
        return numerator / Math.sqrt(sum1 * sum2);
    }
}
```

### 課題3のヒント
```java
class VoxelWorld {
    private int[][][] blocks; // [x][y][z]
    private static final int CHUNK_SIZE = 64;
    
    public boolean checkCollision(BoundingBox bbox) {
        int minX = (int)Math.floor(bbox.minX);
        int maxX = (int)Math.ceil(bbox.maxX);
        int minY = (int)Math.floor(bbox.minY);
        int maxY = (int)Math.ceil(bbox.maxY);
        int minZ = (int)Math.floor(bbox.minZ);
        int maxZ = (int)Math.ceil(bbox.maxZ);
        
        for (int x = minX; x <= maxX; x++) {
            for (int y = minY; y <= maxY; y++) {
                for (int z = minZ; z <= maxZ; z++) {
                    if (isValidCoordinate(x, y, z) && 
                        blocks[x][y][z] != 0) { // 0 = 空気
                        return true; // 衝突あり
                    }
                }
            }
        }
        return false; // 衝突なし
    }
    
    public RaycastResult raycast(Vector3 origin, Vector3 direction, double maxDistance) {
        // DDA (Digital Differential Analyzer) アルゴリズム
        double stepX = Math.signum(direction.x);
        double stepY = Math.signum(direction.y);
        double stepZ = Math.signum(direction.z);
        
        double tDeltaX = Math.abs(1.0 / direction.x);
        double tDeltaY = Math.abs(1.0 / direction.y);
        double tDeltaZ = Math.abs(1.0 / direction.z);
        
        int currentX = (int)Math.floor(origin.x);
        int currentY = (int)Math.floor(origin.y);
        int currentZ = (int)Math.floor(origin.z);
        
        double tMaxX = tDeltaX * (stepX > 0 ? 
            (currentX + 1.0 - origin.x) : (origin.x - currentX));
        double tMaxY = tDeltaY * (stepY > 0 ? 
            (currentY + 1.0 - origin.y) : (origin.y - currentY));
        double tMaxZ = tDeltaZ * (stepZ > 0 ? 
            (currentZ + 1.0 - origin.z) : (origin.z - currentZ));
        
        double distance = 0;
        while (distance < maxDistance) {
            if (isValidCoordinate(currentX, currentY, currentZ) &&
                blocks[currentX][currentY][currentZ] != 0) {
                return new RaycastResult(currentX, currentY, currentZ, distance);
            }
            
            if (tMaxX < tMaxY) {
                if (tMaxX < tMaxZ) {
                    currentX += stepX;
                    distance = tMaxX;
                    tMaxX += tDeltaX;
                } else {
                    currentZ += stepZ;
                    distance = tMaxZ;
                    tMaxZ += tDeltaZ;
                }
            } else {
                if (tMaxY < tMaxZ) {
                    currentY += stepY;
                    distance = tMaxY;
                    tMaxY += tDeltaY;
                } else {
                    currentZ += stepZ;
                    distance = tMaxZ;
                    tMaxZ += tDeltaZ;
                }
            }
        }
        
        return null; // ヒットなし
    }
}
```

## 🔍 応用のポイント

1. **配列の効率的活用**: メモリレイアウトとキャッシュ効率を考慮した設計
2. **アルゴリズム実装**: 実用的な画像処理・データ分析・3Dアルゴリズム
3. **パフォーマンス最適化**: 大量データ処理の高速化技術
4. **メモリ管理**: 大容量データの効率的なメモリ使用
5. **並列処理**: マルチコアCPUを活用した高速化

## ✅ 完了チェックリスト

- [ ] 課題1: 画像処理システムが正常に動作する
- [ ] 課題2: 大規模データ分析システムが実装できた
- [ ] 課題3: 3Dゲームエンジン基盤が動作する
- [ ] 配列が効果的に活用されている
- [ ] アルゴリズムが正しく実装されている
- [ ] パフォーマンスが最適化されている

**次のステップ**: 応用課題が完了したら、challenge/のチャレンジ課題に挑戦してみましょう！