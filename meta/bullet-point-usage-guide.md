# 箇条書き使用ガイドライン

## 適切な箇条書きの使用場面

### 1. 比較表・対照表
**例**: ArrayList vs LinkedListの性能比較（第10章）
```markdown
| 操作 | ArrayList | LinkedList |
| :--- | :--- | :--- |
| 要素の取得 | 高速 O(1) | 低速 O(n) |
```
**理由**: 複数の項目を横並びで比較する際は、表形式が最も理解しやすい

### 2. APIリファレンス・メソッド一覧
**例**: Comparatorの便利メソッド（第10章）
- `Comparator.comparing(keyExtractor)`
- `reversed()`
- `thenComparing(other)`

**理由**: APIの機能を素早く参照できる形式として有効

### 3. 分類・カテゴリー一覧
**例**: エラーの種類（第14章）
1. 構文エラー
2. 実行時エラー
3. 論理エラー

**理由**: 明確に区別される項目を列挙する場合に適切

### 4. 手順・ステップ
**例**: Stream処理の流れ
1. ストリームの生成
2. 中間操作
3. 終端操作

**理由**: 順序が重要な処理の流れを示す場合に有効

### 5. 演習の要求仕様
**例**: 課題の実装要件
- Enumの定義
- メソッドの実装
- テストケースの作成

**理由**: 実装すべき項目のチェックリストとして機能

## 不適切な箇条書き（説明文に変換すべき場面）

### 1. 学習目標・前提知識
**変換前**:
- ジェネリクスの理解
- コレクションの使用経験
- ラムダ式の基礎知識

**変換後**:
本章を学習するためには、まずジェネリクスの概念を十分に理解していることが必要です。特に型パラメータの仕組みと、それがもたらす型安全性について...

### 2. 概念の説明
**変換前**:
- Stream APIは宣言的
- 遅延評価を採用
- 並列処理が可能

**変換後**:
Stream APIの重要な特徴の一つが宣言的なプログラミングスタイルです。これは「何を」行うかを記述することに焦点を当て、「どのように」実行するかは...

### 3. 技術的背景
**変換前**:
- 型消去により後方互換性を維持
- コンパイル時に型チェック
- 実行時オーバーヘッドなし

**変換後**:
Javaのジェネリクスは型消去という仕組みを採用しています。これにより、既存のJavaコードとの後方互換性を保ちながら...

## 変換の判断基準

### 箇条書きを維持すべき場合
1. **独立性**: 各項目が独立して理解できる
2. **参照性**: 素早く情報を見つける必要がある
3. **比較性**: 複数の項目を対比する必要がある
4. **簡潔性**: 詳細な説明が不要な項目

### 説明文に変換すべき場合
1. **文脈依存**: 前後の文脈が理解に必要
2. **因果関係**: なぜそうなるかの説明が重要
3. **段階的理解**: 順を追って理解する必要がある
4. **概念説明**: 抽象的な概念の理解が目的

## 現在の変換状況

### 完了した変換
- 第2-15章の学習目標セクション
- 第2-15章の前提知識セクション
- 第4章のカプセル化の説明
- 第10章のStream API導入部
- 第12章のRecord基本原則

### 適切に維持されている箇条書き
- 第10章のコレクション性能比較表
- 第11章の関数型インターフェイス一覧
- 第14章の例外階層図
- 各章の演習課題の要求仕様
- コマンド一覧（CLAUDE.md）

この指針に従うことで、教育的効果を最大化しつつ、参照しやすい技術書を作成できます。