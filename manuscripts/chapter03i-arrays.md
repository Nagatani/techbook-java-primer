# 第3章 オブジェクト指向の考え方 - Part I: 配列

## 3.6 配列：要素を効率的に管理する

### 配列とは？

配列とは、***変数をまとめて管理する***しくみです。
その存在と利用法については、すでにC言語で学習しているものとして、Javaでの書き方について確認しましょう。

#### 配列を使う場面

複数の同じような値を同じような計算などで処理する場合に、配列にまとめて管理すると処理を行いやすいです。

前述のとおり、Javaはオブジェクト指向言語ではありますが、配列もサポートしています。
(C++と同じスタンス）

今でこそ、後の章で紹介されるコレクションAPIを使って配列よりも楽にデータ管理ができます。しかし、処理速度を優先したい場合や、プリミティブ型での要素管理をしたい場合などでは、配列を使うケースがあります。

配列の短所としては、サイズが決まっていること（宣言時またはインスタンス化時に決まる）など、管理がたいへんなケースがあるということです。また、配列内の要素の数が変わるような処理を行う場合、配列は向いていません。

### 配列の宣言

#### 書き方パターン1（推奨）

```java
型[] 配列名;
```

#### 書き方パターン2（C言語と同じ）

```java
型 配列名[];
```

配列の場合、型、配列変数名（識別子）に加え、`[]`を付けます。Javaの場合、配列であることが分かりやすいため、型の後に`[]`をつけることが推奨されています。

```java
// intの配列を宣言する
int[] scores;
```

### 配列の領域確保

宣言しただけでは、配列の要素を格納する領域（どの程度の要素数が必要か）がまだ決まっていません。
以下の書き方で、どの程度の要素数を格納する領域を確保するかを決定します。

```java
配列名 = new 型[要素数];
```

例：
```java
scores = new int[5];
```

配列の宣言と領域の確保を同時に行う場合は以下のように書けます。

```java
int[] scores;		      // 宣言
scores = new int[5];	// 領域を5つ確保する
// ↓ 宣言と同時に領域確保
int[] scores = new int[5];
```

配列の宣言と、領域の確保、値の代入をまとめて行う場合は、`{ }`を使い、リテラルをカンマ区切りで必要数分記入します。

```java
int[] scores = {74, 88, 98, 53, 25};
```

##### 配列の領域数（要素数）を取得

確保された領域の数を取得するには、配列の変数の`length`を参照します。

```java
int[] scores = {74, 88, 98, 53, 25};
System.out.println(scores.length);    // 5と表示
```

for文の条件や、配列の要素の最後にアクセスする場合などに使用できます。

```java
int[] scores = {74, 88, 98, 53, 25};

// 要素の最後にアクセス
System.out.println(scores[scores.length - 1]); //25と表示される

// 各要素を順に表示
for (int i = 0; i < scores.length; i++) {
  System.out.print(scores[i] + ", "); // 74, 88, 98, 53, 25と表示される。
}
```

#### 複数次元の配列(多次元配列)

先ほどまでのは、1次元配列と呼ばれるものです。要素は単一のインデックス（整数値による連番：ゼロからスタート）でアクセスできます。
それに対して、複数の次元を持たせた配列を使うこともできます。

```java
// 教科ごとの点数(1次元)を生徒ごと(2次元)で管理したい
int[][] scoresOfStudents = new int[3][5];
```

必要な次元の数だけ`[]`をつなげます。

##### 多次元配列における各要素へのアクセス

基本は1次元配列と同じです。

```java
// 一人目の点数を代入
scoresOfStudents[0][0] = 100;
scoresOfStudents[0][1] = 70;
scoresOfStudents[0][2] = 50;
scoresOfStudents[0][3] = 98;
scoresOfStudents[0][4] = 45;
// 二人目
scoresOfStudents[1][0] = 70;
scoresOfStudents[1][1] = 70;
scoresOfStudents[1][2] = 45;
scoresOfStudents[1][3] = 68;
scoresOfStudents[1][4] = 70;

// ...以下省略
```

##### 多次元配列もまとめて初期化可能

配列内部の`{}`をカンマで区切ることで、多次元の配列を同時に宣言、初期化、代入ができます。

```java
int[][] scoresOfStudents = {
    {70, 60, 80, 90, 50},
    {81, 45, 32, 78, 100},
    {32, 44, 34, 55, 70},
};
```

##### 多次元配列の領域数を取得

先ほどの多次元配列にて

```java
System.out.println(scoresOfStudents.length);    //3と表示
```

次元ごとの領域数を取得するには、

```java
System.out.println(scoresOfStudents[0].length);    //5と表示
```

### 配列の実践的な使用例

#### 拡張for文（for-each文）

Java 5から導入された拡張for文を使うと、配列の要素を簡潔に反復処理できます：

```java
int[] scores = {74, 88, 98, 53, 25};

// 従来のfor文
for (int i = 0; i < scores.length; i++) {
    System.out.println("点数: " + scores[i]);
}

// 拡張for文（推奨）
for (int score : scores) {
    System.out.println("点数: " + score);
}
```

#### 配列のコピー

配列をコピーする場合は、`System.arraycopy()`メソッドや`Arrays.copyOf()`メソッドを使用します：

```java
int[] original = {1, 2, 3, 4, 5};
int[] copy1 = new int[original.length];

// System.arraycopy()を使用
System.arraycopy(original, 0, copy1, 0, original.length);

// Arrays.copyOf()を使用（より簡潔）
int[] copy2 = Arrays.copyOf(original, original.length);
```

#### 配列のソート

`Arrays.sort()`メソッドを使って配列を簡単にソートできます：

```java
int[] numbers = {5, 2, 8, 1, 9};
Arrays.sort(numbers);
// numbers は {1, 2, 5, 8, 9} になる
```

### 配列使用時の注意点

1. **配列の境界チェック**: 配列の範囲外アクセスは`ArrayIndexOutOfBoundsException`を引き起こします
2. **参照の共有**: 配列は参照型ですので、代入は参照のコピーになります
3. **サイズの固定**: 一度作成した配列のサイズは変更できません

```java
// 範囲外アクセスの例（エラーになる）
int[] arr = new int[5];
// arr[5] = 10;  // エラー！インデックスは0-4まで

// 参照の共有の例
int[] arr1 = {1, 2, 3};
int[] arr2 = arr1;  // 参照のコピー
arr2[0] = 99;
System.out.println(arr1[0]);  // 99と表示される
```

### まとめ

配列は、同じ型の複数の値を効率的に管理するための基本的なデータ構造です。固定サイズという制約はありますが、メモリ効率が良く、高速なアクセスが可能です。より柔軟なデータ構造が必要な場合は、後の章で学習するコレクションフレームワーク（`ArrayList`など）の使用を検討してください。

---

次のパート：[Part J - 章末演習](chapter03j-exercises.md)