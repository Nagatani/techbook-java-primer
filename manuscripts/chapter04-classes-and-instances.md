# 第4章 クラスとインスタンス

## 本章の学習目標

### 前提知識

本章を学習する前に、第3章で学んだオブジェクト指向の基礎概念を完全に理解していることが必須です。特に、クラスが「設計図」であり、オブジェクトがその「実体」であるという関係性、そしてカプセル化によるデータ保護の重要性を理解している必要があります。

また、基本的なクラスの設計と実装の経験を持っていることが望ましいです。これには、複数のクラスを含むプログラムの作成経験や、オブジェクト間の関係性を実装した経験が含まれます。これらの経験があることで、本章で扱うより高度な設計技法をスムーズに理解できます。

### 学習目標

本章では、オブジェクト指向プログラミングの核心となる「クラスとインスタンス」の詳細なメカニズムを学習します。まず、知識理解の面では、クラスとインスタンス（オブジェクト）の関係性を深く理解し、コンストラクタがオブジェクト生成時に果たす役割とその種類を学びます。また、インスタンス変数とインスタンスメソッドがどのように連携してオブジェクトの状態と振る舞いを実現するかを理解します。`this`キーワードの意味と使用法、そしてメソッドオーバーロードの概念も重要な学習ポイントです。

技能習得の面では、クラスの基本構造であるフィールド、メソッド、コンストラクタを実際に実装できるようになることを目指します。特に、適切なコンストラクタの定義方法、`this`キーワードを使った明確なコード記述、メソッドオーバーロードの効果的な活用方法を身につけます。インスタンス変数の適切な初期化方法も、安全なプログラムを書く上で不可欠なスキルです。

さらに、設計能力の観点からは、責任が明確なクラスの設計方法を学びます。適切なカプセル化による情報隠蔽を実現し、ほかの開発者が使いやすいクラスインターフェイスを設計する能力を養います。

最終的には、実世界の概念をクラスとして適切にモデル化し、複数のコンストラクタを持つ柔軟なクラスを作成できます。インスタンス変数とメソッドを適切に組み合わせ、ほかのクラスから利用しやすい、保守性の高いクラスを設計・実装できるようになることが、本章の最終的な到達目標です。



## 章の構成

本章は、以下のパートで構成されています：

### [Part A: カプセル化の基礎](chapter04a-encapsulation-basics.md)
- カプセル化の基本概念
- アクセス修飾子の詳細
- getter/setterメソッドのベストプラクティス
- 実践的なクラス設計例

### [Part B: 章末演習](chapter04b-exercises.md)
- 基礎レベル課題：カプセル化の基本実践
- 応用レベル課題：複数クラスの連携
- 発展レベル課題：設計パターンの適用
- 挑戦レベル課題：実務レベルのシステム設計

## 学習の進め方

1. Part Aで基本概念と実装方法を学習
2. 各パートのサンプルコードを実際に動かして理解を深める
3. Part Bの演習課題に段階的に取り組む
4. 解答例と比較して、より良い設計を学ぶ

## 基本的なクラスとインスタンスの例

本章の詳細な内容はPart Aで扱いますが、ここでは基本的なクラスとインスタンスの関係を簡単な例で確認しておきましょう：

### 銀行口座クラスの基本構造

以下は、銀行口座を表現するシンプルなクラスの例です。このクラスはカプセル化の基本的な原則に従って設計されています：

```java
// BankAccount.java
public class BankAccount {
    // インスタンス変数（プライベートにして直接アクセスを防ぐ）
    private String accountNumber;
    private String ownerName;
    private double balance;
    
    // コンストラクタ（新しい口座を作成）
    public BankAccount(String accountNumber, String ownerName, double initialBalance) {
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.balance = initialBalance;
    }
    
    // 入金メソッド
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println(amount + "円を入金しました。");
        } else {
            System.out.println("入金額は正の値である必要があります。");
        }
    }
    
    // 出金メソッド
    public boolean withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println(amount + "円を出金しました。");
            return true;
        } else {
            System.out.println("出金できません。");
            return false;
        }
    }
    
    // 残高照会（getter）
    public double getBalance() {
        return balance;
    }
    
    // 口座情報の表示
    public void displayInfo() {
        System.out.println("口座番号: " + accountNumber);
        System.out.println("名義人: " + ownerName);
        System.out.println("残高: " + balance + "円");
    }
}

// 使用例
public class BankAccountTest {
    public static void main(String[] args) {
        // インスタンスの作成（新しい口座を開設）
        BankAccount myAccount = new BankAccount("12345", "山田太郎", 10000);
        
        // メソッドを使った操作
        myAccount.displayInfo();
        myAccount.deposit(5000);
        myAccount.withdraw(3000);
        
        // 現在の残高を確認
        System.out.println("現在の残高: " + myAccount.getBalance() + "円");
    }
}
```

**このコードのポイント**：
- **カプセル化**: インスタンス変数はprivateで保護され、publicメソッドを通じてのみアクセス可能
- **コンストラクタ**: オブジェクト生成時に必要な初期化を行う
- **インスタンスメソッド**: オブジェクトの状態を操作する振る舞いを定義
- **バリデーション**: メソッド内で適切な値の検証を行い、不正な操作を防ぐ

本章を通じて、オブジェクト指向プログラミングの核心である「データと処理の適切な組み合わせ」を実践的に身につけていきましょう。



<!-- Merged from chapter04a-encapsulation-basics.md -->


## 本章の学習目標

### 前提知識
**必須前提**：
- 第3章のオブジェクト指向基礎概念の完全な理解
- 基本的なクラス設計と実装の経験
- カプセル化の実践的な理解

**設計経験前提**：
- 複数のクラスを含むプログラムの作成経験
- オブジェクト間の関係性の実装経験

### 学習目標
**知識理解目標**：
- クラスとインスタンス（オブジェクト）の関係性
- コンストラクタの役割と種類
- インスタンス変数とインスタンスメソッドの概念
- thisキーワードの意味と使用法
- メソッドオーバーロードの概念

**技能習得目標**：
- クラスの基本構造（フィールド、メソッド、コンストラクタ）の実装
- 適切なコンストラクタの定義
- thisキーワードを使った明確なコード記述
- メソッドオーバーロードの効果的な活用
- インスタンス変数の適切な初期化

**設計能力目標**：
- 責任が明確なクラスの設計
- 適切なカプセル化による情報隠蔽
- 使いやすいクラスインターフェイスの設計

**到達レベルの指標**：
- 実世界の概念をクラスとして適切に設計・実装できる
- 複数のコンストラクタを持つクラスが作成できる
- インスタンス変数とメソッドを適切に組み合わせたクラスが実装できる
- 他のクラスから利用しやすいクラスが設計できる



## 始めに：クラス設計の実践とカプセル化

前章では、オブジェクト指向プログラミングの基本概念について学習しました。本章では、実践的なクラス設計とカプセル化の技術について詳細に学習します。

クラス設計は、単なるコードの書き方ではありません。データと処理を適切に組み合わせ、保守性と拡張性の高いソフトウェアを構築するための重要な技術です。

## カプセル化とアクセス制御

### カプセル化の基本概念

カプセル化は、関連するデータ（フィールド）と処理（メソッド）を1つのクラスにまとめ、外部から直接アクセスできないよう保護する技術です。これにより、オブジェクトの内部状態を安全に管理できます。

### アクセス修飾子の詳細

Javaのアクセス制御は、カプセル化を実現する上で最も重要な機能の1つです。Javaは4つのアクセス修飾子を提供しており、これらを適切に使い分けることで、クラスの内部実装を隠蔽しながら必要な機能だけを外部に公開できます。各修飾子は、フィールドとメソッドの可視性を段階的に制御し、オブジェクト指向設計の原則である「必要最小限の公開」を実現します。

#### アクセス修飾子の可視性マトリックス

| 修飾子 | 同じクラス | 同じパッケージ | サブクラス（別パッケージ） | それ以外（別パッケージ） | 説明 |
|--------|-----------|---------------|---------------------------|-------------------------|------|
| `private` | ○ | × | × | × | 同じクラス内からのみアクセス可能 |
| (なし)※ | ○ | ○ | × | × | 同じパッケージ内からのみアクセス可能 |
| `protected` | ○ | ○ | ○ | × | 同じパッケージまたはサブクラスからアクセス可能 |
| `public` | ○ | ○ | ○ | ○ | どこからでもアクセス可能 |

※ 修飾子を記述しない場合（デフォルトアクセス、package-privateとも呼ばれる）

#### アクセス修飾子の使い分け原則

1. **`private`を基本とする**: フィールドは原則として`private`にし、必要に応じてgetter/setterを提供
2. **`public`は慎重に**: 外部APIとして公開する必要があるメソッドのみ`public`にする
3. **`protected`の活用**: 継承関係で使用する場合に限定し、設計意図を明確にする
4. **パッケージプライベートの戦略的使用**: 同一パッケージ内での協調動作が必要な場合に使用

#### 各アクセス修飾子の詳細と使用例

**`private`の使用例**：
```java
public class BankAccount {
    private double balance;      // 外部から直接変更不可
    private String accountId;    // 内部管理用ID
    
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;   // 同じクラス内からは可視
            logTransaction();    // プライベートメソッドの呼び出し
        }
    }
    
    private void logTransaction() {  // 内部処理専用メソッド
        // トランザクションログの記録
    }
}
```

**パッケージプライベート（デフォルト）の使用例**：
```java
package com.example.internal;

public class DataProcessor {
    String processId;     // 同じパッケージ内からアクセス可能
    
    void processInternal() {  // パッケージ内協調用メソッド
        // 内部処理
    }
}

// 同じパッケージ内の別クラス
class ProcessorHelper {
    void assist(DataProcessor processor) {
        processor.processId = "PROC-001";     // OK: 同じパッケージ
        processor.processInternal();           // OK: 同じパッケージ
    }
}
```

**`protected`の使用例**：
```java
package com.example.base;

public class Vehicle {
    protected String engineType;     // サブクラスからアクセス可能
    protected int maxSpeed;
    
    protected void startEngine() {   // サブクラスで利用可能
        System.out.println("Engine started: " + engineType);
    }
}

// 別パッケージのサブクラス
package com.example.cars;
import com.example.base.Vehicle;

public class Car extends Vehicle {
    public void initialize() {
        engineType = "V6";          // OK: protected継承
        maxSpeed = 200;             // OK: protected継承
        startEngine();              // OK: protectedメソッド
    }
}
```

**`public`の使用例**：
```java
public class MathUtils {
    public static final double PI = 3.14159;  // 公開定数
    
    public static int add(int a, int b) {     // 公開ユーティリティメソッド
        return a + b;
    }
    
    public boolean isPositive(int number) {   // 公開インスタンスメソッド
        return number > 0;
    }
}
```

### getter/setterメソッドのベストプラクティス

getter/setterメソッド（アクセサメソッドとも呼ばれます）は、カプセル化の実装において中心的な役割を果たします。単にフィールドの値を取得・設定するだけでなく、データの整合性を保証し、将来の変更に対する柔軟性を提供します。以下の例では、プライベートフィールドへの安全なアクセスを提供する標準的なパターンを示します：

```java
public class Product {
    private String name;
    private double price;
    
    // getter：値を取得
    public String getName() {
        return name;
    }
    
    public double getPrice() {
        return price;
    }
    
    // setter：データ検証付きで値を設定
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("商品名は必須です");
        }
        this.name = name;
    }
    
    public void setPrice(double price) {
        if (price < 0) {
            throw new IllegalArgumentException("価格は負の値にできません");
        }
        this.price = price;
    }
}
```

### データ検証の重要性

オブジェクト指向プログラミングにおいて、オブジェクトの状態を常に有効に保つことは極めて重要です。setterメソッドは単なる値の代入ではなく、オブジェクトの不変条件（invariant）を守るゲートキーパーとしての役割を担います。適切なデータ検証を実装することで、バグの早期発見と予防が可能になり、システム全体の信頼性が向上します。以下の例では、実務でよく使用される検証パターンを示します：

```java
public class Employee {
    private String name;
    private int age;
    private double salary;
    
    public void setAge(int age) {
        if (age < 18 || age > 100) {
            throw new IllegalArgumentException("年齢は18歳以上100歳以下で入力してください");
        }
        this.age = age;
    }
    
    public void setSalary(double salary) {
        if (salary < 0) {
            throw new IllegalArgumentException("給与は負の値にできません");
        }
        this.salary = salary;
    }
}
```

## 設計原則とソフトウェアアーキテクチャ

オブジェクト指向設計では、SOLID原則と呼ばれる5つの基本原則があります。中でも単一責任原則（クラスは1つの責任のみを持つべき）と開放閉鎖原則（拡張に開かれ、修正に閉じているべき）は特に重要です。

カプセル化は単にデータを隠す技術ではなく、変更の影響を局所化し、再利用性とテスト容易性を高める重要な設計技術です。

**SOLID原則の詳細、情報隠蔽の深い意味、契約による設計については、付録B.05「ソフトウェア設計原則」を参照してください。**

## 実践的なクラス設計例

### 銀行口座クラスの設計

カプセル化とアクセス制御を活用した実践的な例：

```java
public class BankAccount {
    // プライベートフィールド：外部から直接変更不可
    private String accountNumber;
    private String accountHolder;
    private double balance;
    private boolean isActive;
    
    // コンストラクタ：初期化時のデータ検証
    public BankAccount(String accountNumber, String accountHolder, double initialBalance) {
        setAccountNumber(accountNumber);
        setAccountHolder(accountHolder);
        setBalance(initialBalance);
        this.isActive = true;
    }
    
    // パブリックメソッド：外部インターフェイス
    public void deposit(double amount) {
        validateAccount();
        if (amount <= 0) {
            throw new IllegalArgumentException("入金額は正の値である必要があります");
        }
        balance += amount;
    }
    
    public void withdraw(double amount) {
        validateAccount();
        if (amount <= 0) {
            throw new IllegalArgumentException("出金額は正の値である必要があります");
        }
        if (balance < amount) {
            throw new IllegalArgumentException("残高不足です");
        }
        balance -= amount;
    }
    
    // プライベートメソッド：内部ロジック
    private void validateAccount() {
        if (!isActive) {
            throw new IllegalStateException("この口座は無効です");
        }
    }
    
    // getter/setterメソッド
    public String getAccountNumber() {
        return accountNumber;
    }
    
    private void setAccountNumber(String accountNumber) {
        if (accountNumber == null || !accountNumber.matches("\\d{10}")) {
            throw new IllegalArgumentException("口座番号は10桁の数字である必要があります");
        }
        this.accountNumber = accountNumber;
    }
    
    public double getBalance() {
        validateAccount();
        return balance;
    }
    
    private void setBalance(double balance) {
        if (balance < 0) {
            throw new IllegalArgumentException("残高は負の値にできません");
        }
        this.balance = balance;
    }
}
```

### クラス設計のベストプラクティス

優れたクラス設計は、ソフトウェアの品質を決定づける重要な要素です。オブジェクト指向設計の長年の実践から生まれたベストプラクティスは、保守性、拡張性、信頼性の高いソフトウェアを構築するための指針となります。

最も基本的な原則は**単一責任の原則**です。1つのクラスは1つの明確な責任のみを持つべきであり、これにより変更の理由が限定され、クラスの理解と保守が容易になります。次に重要なのは**データの隠蔽**で、クラスの内部状態をprivateで保護し、必要な操作のみをパブリックメソッドとして公開します。これにより、実装の詳細を変更してもクライアントコードに影響を与えません。

**入力検証**も欠かせない要素です。すべての外部入力は、setterメソッドやコンストラクタで厳密に検証し、不正なデータがオブジェクトの状態を破壊することを防ぎます。また、**意味のある名前**を使用することで、コードの可読性と保守性が大幅に向上します。クラス名は名詞、メソッド名は動詞で始まるという慣習に従い、その役割を明確に表現する名前を選びます。

最後に、**不変条件の維持**は、オブジェクトの整合性を保証する上で極めて重要です。オブジェクトの生成から破棄まで、常に満たされるべき条件（不変条件）を明確に定義し、すべての操作でこれを維持するよう設計します。

これらの原則に従うことで、保守性が高く、バグの少ないJavaプログラムを作成できます。

## パッケージシステムとクラスの組織化

### パッケージの概念と必要性

Javaにおけるパッケージは、関連するクラスやインターフェースをグループ化するための仕組みです。大規模なプロジェクトでは何百、何千ものクラスが存在することがあり、適切な組織化なしには管理が困難になります。パッケージは以下の重要な役割を果たします：

1. **名前空間の提供**: 異なるパッケージに同じ名前のクラスを作成可能
2. **アクセス制御**: パッケージレベルでのアクセス制限を実現
3. **論理的な構造化**: 機能や責任に基づいてクラスを整理
4. **クラスの再利用**: パッケージ単位での配布と利用

### パッケージの命名規則

Javaの言語仕様では、パッケージ名の衝突を避けるため、インターネットドメイン名を逆順にした命名規則が推奨されています：

```java
// ドメイン名: example.com
// パッケージ名: com.example.プロジェクト名.モジュール名
package com.example.myapp.service;

// ドメイン名: ac.jp（教育機関）
// パッケージ名: jp.ac.大学名.プロジェクト名
package jp.ac.university.research;
```

**命名規則のポイント**：
- すべて小文字を使用
- ドメイン名を逆順に記述
- 意味のある階層構造を作成
- Javaの予約語は使用しない

### パッケージとディレクトリ構造

パッケージ名はファイルシステムのディレクトリ構造と対応している必要があります：

```
src/
└── com/
    └── example/
        └── myapp/
            ├── model/
            │   ├── User.java
            │   └── Product.java
            ├── service/
            │   ├── UserService.java
            │   └── ProductService.java
            └── util/
                └── DateUtils.java
```

### import文の使い方

パッケージに含まれるクラスを使用する際は、完全限定名かimport文を使用します：

```java
// 完全限定名での使用
java.util.List<String> names = new java.util.ArrayList<>();

// import文を使用した場合
import java.util.List;
import java.util.ArrayList;

List<String> names = new ArrayList<>();
```

**import文の種類**：

1. **単一型インポート**：
```java
import java.util.Scanner;  // Scannerクラスのみインポート
```

2. **オンデマンドインポート**：
```java
import java.util.*;  // java.utilパッケージのすべてのクラスをインポート
```

3. **静的インポート**：
```java
import static java.lang.Math.PI;
import static java.lang.Math.sqrt;

double circumference = 2 * PI * radius;  // Math.PI と書く必要がない
double result = sqrt(16);                 // Math.sqrt と書く必要がない
```

### import文の注意点

異なるパッケージに同名のクラスが存在する場合、明示的な指定が必要です：

```java
import java.util.*;
import java.awt.*;

public class Example {
    // コンパイルエラー: List はどちらのパッケージか不明
    // List myList;  
    
    // 解決策1: 完全限定名を使用
    java.util.List<String> utilList;
    java.awt.List awtList;
    
    // 解決策2: 片方のみimport
    // import java.util.List;
    // List<String> utilList;  // java.util.List
    // java.awt.List awtList;  // 完全限定名
}
```

### パッケージ構成のベストプラクティス

効果的なパッケージ構成は、プロジェクトの保守性と拡張性を大きく向上させます：

```java
com.example.myapp/
├── model/          // ドメインモデル（エンティティ）
├── service/        // ビジネスロジック
├── repository/     // データアクセス層
├── controller/     // UIコントローラ
├── util/          // ユーティリティクラス
└── exception/     // カスタム例外
```

**設計原則**：
- 機能的凝集性: 関連する機能を同じパッケージに
- 循環依存の回避: パッケージ間の依存関係を一方向に
- 適切な粒度: 大きすぎず小さすぎないパッケージサイズ
- 明確な責任: 各パッケージの役割を明確に定義

これらの原則に従うことで、保守性が高く、バグの少ないJavaプログラムを作成できます。次の章では、これらのクラスを組み合わせて、より複雑なオブジェクト指向設計を学習していきます。

本章を通じて、Javaという言語の持つ型システムの力強さと精密さを理解し、現代のソフトウェア開発者として必要な基礎的な素養を身につけていきましょう。



次のパート：[Part B - コンストラクタとthisキーワード](chapter04b-constructors-this.md)




<!-- Merged from chapter04b-exercises.md -->


## 章末演習

本章で学んだカプセル化、アクセス制御、クラス設計の概念を段階的に実践し、実用的なクラス設計能力を身につけましょう。各レベルは前のレベルの習得を前提として設計されています。

### 演習の目標

本章の演習を通じて、カプセル化とアクセス制御の実践的な技術を身につけます。まず、カプセル化の適切な実装方法を学び、プライベートフィールドとパブリックメソッドを使ってオブジェクトの内部状態を保護する技術を習得します。次に、Javaの4つのアクセス修飾子を正しく使い分け、クラスのインターフェイスを適切に設計する能力を養います。getter/setterパターンの実践では、単純なアクセサメソッドの実装だけでなく、データの妥当性検証や副作用の管理なども含めた実装方法を学びます。さらに、入力検証とデータ整合性の確保を通じて、堅牢なクラス設計の基礎を固めます。最後に、複数クラス間の連携設計を通じて、実際のアプリケーション開発に必要な設計スキルを身につけます。

### 演習課題の難易度レベル

#### 基礎レベル（Basic）

基礎レベルの課題は、カプセル化とアクセス制御の基本概念を確実に理解することを目的としています。各課題の所要時間は25-40分程度を想定しており、第3章で学んだクラス設計の基本を理解していることが前提となります。

評価においては、privateフィールドとpublicメソッドの適切な使い分けができているかを重視します。具体的には、オブジェクトの内部状態を表すフィールドは必ずprivateとし、外部からのアクセスは適切に設計されたpublicメソッドを通じて行うことが求められます。また、基本的な入力検証の実装も評価のポイントとなります。setterメソッドやコンストラクタでは、引数として受け取った値が妥当かどうかを検証し、不正な値の場合は適切な例外をスローする必要があります。getter/setterの正しい実装も重要で、単に値を取得・設定するだけでなく、必要に応じて防御的コピーや追加の処理を含めることが求められます。最終的に、これらの技術を組み合わせてデータの整合性を保つ設計ができることが、基礎レベルの到達目標となります。

#### 応用レベル（Applied）

応用レベルでは、より実践的なクラス設計と複数クラス間の連携を学びます。基礎レベルで習得した技術を前提として、実際のアプリケーション開発で必要となる複雑な設計課題に取り組みます。各課題の所要時間は40-60分程度を想定しており、基礎レベルの課題を完了していることが前提条件となります。

このレベルでは、複数のクラスを適切に連携させた設計が重要な評価ポイントとなります。単一のクラスの設計だけでなく、クラス間の責任分担を明確にし、適切な依存関係を構築する能力が求められます。ビジネスロジックの適切な配置も重要で、どのクラスにどのような処理を持たせるかを適切に判断し、凝集度の高い設計を実現する必要があります。また、より高度な入力検証とエラーハンドリングも評価対象となります。複数のクラスが連携する中で、エラーの伝播と処理を適切に設計し、システム全体の堅牢性を確保することが求められます。最後に、保守性を考慮した設計も重要な評価基準です。将来の変更や拡張を見据えて、変更に強い設計を実現することが応用レベルの目標となります。

#### 発展レベル（Advanced）

発展レベルでは、設計原則にもとづいた高品質なクラス設計を学びます。単に動作するコードを書くだけでなく、ソフトウェア工学の原則に従った、プロフェッショナルレベルの設計を目指します。各課題の所要時間は60-80分程度を想定しており、応用レベルを完了し、より深い設計原則に興味を持っていることが前提となります。

このレベルの評価では、SOLID原則を意識した設計ができているかが重要なポイントとなります。単一責任原則、開放閉鎖原則、リスコフの置換原則、インターフェイス分離原則、依存関係逆転原則といった基本原則を理解し、実際のコードに適用する能力が求められます。また、適切なデザインパターンの適用も評価対象となります。GoFデザインパターンなどの確立されたパターンを理解し、適切な場面で活用できることが期待されます。拡張性と保守性を考慮した設計も重要で、将来の機能追加や変更に対して柔軟に対応できる設計を実現する必要があります。さらに、パフォーマンスを意識した実装も評価のポイントとなり、効率的なアルゴリズムやデータ構造の選択、不要なオブジェクト生成の回避など、実行効率を考慮したコーディングが求められます。

#### 挑戦レベル（Challenge）

挑戦レベルは、実務レベルの複雑なシステム設計に取り組む最高難度の課題です。このレベルでは、実際の企業システム開発で求められる高度な設計技術と実装能力が必要となります。各課題の所要時間は80分以上を想定しており、発展レベルを完了し、より深い設計への強い関心を持っていることが前提となります。

評価においては、複雑なドメインモデルの設計能力が最も重要視されます。現実世界の複雑なビジネスルールや制約を、適切にオブジェクトモデルとして表現し、エンティティ、値オブジェクト、集約などのドメイン駆動設計の概念を活用した設計が求められます。アーキテクチャパターンの適用も重要な評価ポイントで、レイヤドアーキテクチャ、ヘキサゴナルアーキテクチャ、Clean Architectureなどの確立されたパターンを理解し、適切に適用する能力が必要です。また、テスタビリティを考慮した設計も不可欠で、依存性注入、モックオブジェクトの活用、テスト容易な設計の実現が求められます。最後に、ドキュメント化されたコードも重要な評価基準となります。Javadocコメント、設計意図の説明、使用例の提供など、ほかの開発者が理解しやすいドキュメントを含むコードを作成することが、挑戦レベルの到達目標となります。

### 演習課題の詳細

演習課題の完全な解答例とテストファイルは `exercises/chapter04/` ディレクトリにあります。
以下では各課題の問題内容、要求仕様、実装ヒントを示します。

## 基礎レベル課題（必須）

### 課題1: 書籍管理クラス（Book.java）

**学習目標：** カプセル化、入力検証、getter/setter

**問題説明：**
書籍の情報を管理するBookクラスを作成し、適切なカプセル化と入力検証を実装してください。

**技術的背景：カプセル化の実務的重要性**

現実のシステム開発において、不適切なデータアクセスは深刻な問題を引き起こします。実際に発生した事例として：

- **電子商取引システムでの価格操作**：publicフィールドを使用していたため、外部から商品価格を直接変更され、0円で販売される事故が発生
- **図書館システムでのデータ不整合**：ISBNの形式チェックを行わなかったため、重複登録や検索不能な書籍データが大量に発生
- **在庫管理システムでの在庫数異常**：負の在庫数を許可してしまい、実在庫との乖離が発生

これらの問題を防ぐため、カプセル化により以下を実現します：
- **データの妥当性保証**：setter内で検証を行うことで、常に正しい状態を維持
- **変更の局所化**：内部実装を変更しても、外部インターフェイスは変わらない
- **デバッグの容易性**：データ変更箇所をsetterに限定でき、問題の追跡が容易

**要求仕様：**

書籍管理クラスでは、以下の要求を満たす実装が必要です。まず、5つのプライベートフィールドを定義します：書籍のタイトルを表す`title`（String型）、著者名を表す`author`（String型）、国際標準図書番号を表す`isbn`（String型）、価格を表す`price`（double型）、そして在庫数を表す`stock`（int型）です。これらのフィールドはすべてprivateとして宣言し、外部から直接アクセスできないようにします。

次に、全フィールドを初期化するコンストラクタを実装します。このコンストラクタでは、各引数に対して適切な検証を行い、不正な値が設定されることを防ぎます。また、すべてのフィールドに対してgetter/setterメソッドを実装し、外部からの安全なアクセスを提供します。さらに、書籍情報を整理して表示する`displayInfo()`メソッドを実装し、ユーザーが書籍の情報を見やすい形式で確認できるようにします。

入力検証については、以下の制約を実装する必要があります：価格は必ず正の値でなければならず、在庫数は0以上の整数である必要があります。また、ISBNは正確に13桁の数字文字列でなければなりません。これらの検証は、コンストラクタとsetterメソッドの両方で実施し、不正な値が設定された場合は適切な例外をスローします。

**実行例：**
```
=== 書籍管理システム ===
ISBN: 9784797386295
タイトル: Java入門
著者: 山田太郎
価格: 3200円
在庫: 15冊

在庫更新: 15 → 12
価格更新: 3200円 → 2800円
更新後の書籍情報:
ISBN: 9784797386295
タイトル: Java入門
著者: 山田太郎
価格: 2800円
在庫: 12冊
```

**実装ヒント：**
```java
public class Book {
    private String title;
    private String author;
    private String isbn;
    private double price;
    private int stock;
    
    public Book(String title, String author, String isbn, double price, int stock) {
        setTitle(title);
        setAuthor(author);
        setIsbn(isbn);
        setPrice(price);
        setStock(stock);
    }
    
    // ISBNの検証付きsetter
    public void setIsbn(String isbn) {
        if (isbn == null || isbn.replaceAll("[^0-9]", "").length() != 13) {
            throw new IllegalArgumentException("ISBNは13桁の数字である必要があります");
        }
        this.isbn = isbn;
    }
    
    // 価格の検証付きsetter
    public void setPrice(double price) {
        if (price <= 0) {
            throw new IllegalArgumentException("価格は正の値である必要があります");
        }
        this.price = price;
    }
    
    // 在庫の検証付きsetter
    public void setStock(int stock) {
        if (stock < 0) {
            throw new IllegalArgumentException("在庫は0以上である必要があります");
        }
        this.stock = stock;
    }
    
    public void displayInfo() {
        System.out.println("ISBN: " + isbn);
        System.out.println("タイトル: " + title);
        System.out.println("著者: " + author);
        System.out.println("価格: " + (int)price + "円");
        System.out.println("在庫: " + stock + "冊");
    }
}
```

**評価基準：**
- [ ] 適切なカプセル化（privateフィールド）
- [ ] コンストラクタでの初期化と検証
- [ ] 全フィールドのgetter/setter実装
- [ ] 入力検証の適切な実装
- [ ] 情報表示メソッドの実装



### 課題2: 製品管理クラス（Product.java）

**学習目標：** より複雑なビジネスロジック、カテゴリ管理

**問題説明：**
製品の情報を管理するProductクラスを作成し、価格計算と在庫管理のロジックを実装してください。

**技術的背景：ビジネスロジックのカプセル化**

実際の業務システムでは、価格計算や在庫管理には複雑なビジネスルールが存在します：

- **動的な価格設定**：時間帯割り引き、会員ランク割り引き、数量割り引きなどの複数の要因
- **税制の複雑性**：軽減税率（食品8%）と標準税率（10%）の混在
- **在庫管理の制約**：予約在庫、安全在庫、発注点管理などの考慮

これらのロジックを適切にカプセル化することで：
- **ビジネスルールの一元管理**：税率変更などの際に修正箇所を限定
- **計算ミスの防止**：複雑な計算式を一ヵ所に集約し、テスト可能に
- **拡張性の確保**：新しい割り引きルールの追加が容易

この演習では、実際のECサイトや小売システムで必要となる価格計算と在庫管理の基本パターンを学習します。

**要求仕様：**
1. フィールド：`productId`、`name`、`category`、`basePrice`、`discountRate`、`stock`
2. 割り引き適用後の価格計算メソッド
3. 在庫管理メソッド（追加、削除、確認）
4. カテゴリごとの税率適用（食品：8%、そのほか：10%）
5. 商品情報の詳細表示

**実装のポイント：**
- カテゴリはenum型で管理すると良い
- 価格計算は税率と割り引き率の両方を考慮
- 在庫操作時の検証を忘れずに



## 応用レベル課題

### 課題3: 従業員管理システム（Employee.java, Department.java）

**学習目標：** 複数クラスの連携、集約関係の実装

**問題説明：**
従業員と部署の関係を表現する2つのクラスを作成し、組織構造を管理するシステムを実装してください。

**技術的背景：クラス間の関係設計**

実際の業務システムでは、複数のエンティティ（実体）が相互に関連しながら動作します。従業員管理システムは、その典型的な例です：

- **集約関係の重要性**：部署は複数の従業員を「含む」（HAS-A関係）
- **双方向関連の課題**：従業員が部署を知り、部署も従業員を知る設計は循環参照を引き起こす
- **責任の分離**：給与計算は従業員の責任か、部署の責任か？

適切なクラス間の関係設計により：
- **データの一貫性**：従業員の追加・削除時に部署の状態も正しく更新
- **メモリ効率**：循環参照を避けることでガベージコレクションが正常に動作
- **保守性の向上**：責任が明確なため、変更の影響範囲を限定可能

この演習では、人事システムや組織管理システムで必要となる基本的な設計パターンを学習します。

**要求仕様：**
1. Employeeクラス：従業員情報（ID、名前、給与、入社日）
2. Departmentクラス：部署情報（部署名、従業員リスト、予算）
3. 部署への従業員の追加・削除機能
4. 部署の給与総額計算
5. 予算超過チェック機能

**設計の注意点：**
- 循環参照を避ける設計
- 責任の適切な分離
- nullチェックとエラーハンドリング



### 課題4: 予約管理システム（Reservation.java, Room.java, Guest.java）

**学習目標：** 3つ以上のクラス連携、日付処理、状態管理

**問題説明：**
ホテルの予約管理システムを実装してください。部屋、ゲスト、予約の3つのエンティティを管理します。

**技術的背景：状態管理と時系列データの扱い**

予約システムは、多くの業界（ホテル、航空、レストラン、医療など）で必要とされる基本的なシステムです。その実装には特有の課題があります：

- **時間軸での制約**：同じ部屋に同時刻の重複予約を防ぐ必要
- **状態遷移の管理**：予約→確定→チェックイン→チェックアウト→キャンセルなどの状態変化
- **料金の動的計算**：シーズン、曜日、予約タイミングによる変動料金

これらの課題に対処するための設計原則：
- **不変オブジェクトの活用**：日付や予約情報を不変にすることで、意図しない変更を防止
- **ビジネスルールの集約**：予約可能性チェックを一ヵ所に集約し、一貫性を保証
- **状態パターンの適用**：予約状態ごとに可能な操作を制限し、不正な状態遷移を防止

この演習では、実際の予約システムで必要となる基本的な機能と設計パターンを学習します。

**要求仕様：**
1. 各クラスの基本機能実装
2. 予約の重複チェック
3. 料金計算（シーズン料金対応）
4. 予約状態の管理（予約済み、チェックイン、チェックアウト）



## 発展レベル課題

### 課題5: 在庫管理システム with デザインパターン

**学習目標：** Observerパターン、Strategyパターンの適用

**問題説明：**
在庫の変動を監視し、自動発注を行うシステムを実装してください。

**設計要件：**
- Observer：在庫変動の通知システム
- Strategy：発注戦略の切り替え（定量発注、定期発注）
- 発注履歴の管理



## 挑戦レベル課題

### 課題6: 図書館管理システム

**学習目標：** 実務レベルの複雑なドメインモデル設計

**問題説明：**
図書館の蔵書管理、貸出管理、利用者管理を統合したシステムを設計・実装してください。

**要求機能：**
1. 蔵書検索（タイトル、著者、ISBN）
2. 貸出・返却処理
3. 延滞管理と罰金計算
4. 予約機能
5. 利用者の貸出履歴管理

**設計の考慮点：**
- トランザクション的な処理の実装
- データの整合性保証
- 拡張性を考慮した設計
- エラーハンドリングの充実



### 演習を通じて身につくスキル

1. **設計力**: 要求から適切なクラス構造を導き出す能力
2. **実装力**: 設計を正確にコードに落とし込む能力
3. **品質意識**: バグの少ない堅牢なコードを書く習慣
4. **保守性**: 将来の変更に強い設計を行う視点

各課題は段階的に難易度が上がるよう設計されています。基礎レベルから始めて、確実にスキルを積み上げていくことをお勧めします。解答例を参照する前に、まず自分で設計・実装を試みることが重要です。



