# 第16章 マルチスレッドプログラミング

## 本章の学習目標

### 前提知識
**必須前提**：
- 第13章までの実用的なJavaアプリケーション開発能力
- 同期処理と非同期処理の概念的理解
- パフォーマンスとスケーラビリティへの関心

**システム理解前提**：
- OSのプロセスとスレッドの基本概念
- CPUとメモリアーキテクチャの基本理解

### 学習目標
**知識理解目標**：
- マルチスレッドプログラミングの必要性と利点
- 並行処理の課題（競合状態、デッドロック）と対策
- java.util.concurrentパッケージの設計思想
- スレッドプールとExecutorServiceの概念

**技能習得目標**：
- スレッドの生成と管理
- 同期化メカニズム（synchronized、Lock、Atomic変数）の使用
- ExecutorServiceを使った効率的なタスク管理
- 並行コレクションの活用

**並行プログラミング能力目標**：
- 安全で効率的な並行処理プログラムの設計・実装
- 性能向上を目的とした並列化の実装
- デッドロック等の問題の回避と解決

**到達レベルの指標**：
- 基本的な並行処理プログラムが安全に実装できる
- ExecutorServiceを使った実用的な非同期処理が実装できる
- 並行処理特有の問題を理解し、適切な対策が取れる
- マルチコア環境での性能向上を実現するプログラムが作成できる

---

## 章末演習

本章で学んだマルチスレッドプログラミングの概念を活用して、実践的な練習課題に取り組みましょう。

### 🎯 演習の目標
- マルチスレッドプログラミングの基本概念
- ThreadクラスとRunnableインターフェイスの使い分け
- 同期処理（synchronized、Lock）の理解と実装
- java.util.concurrentパッケージの活用
- スレッドプールとExecutorServiceの使用
- 非同期プログラミング（CompletableFuture）による効率的な並行処理

### 演習課題の難易度レベル

#### 🟢 基礎レベル（Basic）
- **目的**: マルチスレッドの基本概念と基本的な同期処理の理解
- **所要時間**: 35-50分/課題
- **前提**: 本章の内容を理解していること
- **評価基準**: 
  - スレッド作成方法の理解
  - 並行実行の概念理解
  - スレッドライフサイクルの理解
  - 基本的な同期処理の実装

---

## 🟢 基礎レベル課題（必須）

### 課題1: 基本的なスレッド操作

**学習目標：** スレッド作成方法の理解、並行実行の概念理解、スレッドライフサイクルの理解

**問題説明：**
基本的なスレッド生成と操作を実装し、マルチスレッドの動作を理解してください。

**要求仕様：**
- Threadクラスの継承によるスレッド作成
- Runnableインターフェイスの実装によるスレッド作成
- スレッドの開始、停止、待機
- スレッド間の実行順序の確認
- スレッドの優先度設定

**実行例：**
```
=== 基本的なスレッド操作 ===
メインスレッド開始: main

Thread継承方式:
WorkerThread-1 開始
WorkerThread-1: タスク 1 実行中...
WorkerThread-1: タスク 2 実行中...
WorkerThread-1: タスク 3 実行中...
WorkerThread-1 完了

Runnable実装方式:
Thread-pool-1-thread-1: カウンタ 1
Thread-pool-1-thread-2: カウンタ 1
Thread-pool-1-thread-3: カウンタ 1
Thread-pool-1-thread-1: カウンタ 2
Thread-pool-1-thread-2: カウンタ 2
Thread-pool-1-thread-3: カウンタ 2

複数スレッド並行実行:
スレッドA: 処理 1/5
スレッドB: 処理 1/5
スレッドC: 処理 1/5
スレッドA: 処理 2/5
スレッドB: 処理 2/5
スレッドC: 処理 2/5
...

スレッド情報:
スレッドA: ID=12, 優先度=5, 状態=RUNNABLE
スレッドB: ID=13, 優先度=7, 状態=RUNNABLE
スレッドC: ID=14, 優先度=3, 状態=RUNNABLE

実行時間測定:
シングルスレッド: 5,000ms
マルチスレッド（3スレッド）: 1,750ms
性能向上: 2.86倍

全スレッド完了
メインスレッド終了
```

**評価ポイント：**
- スレッド作成方法の理解
- 並行実行の概念理解
- スレッドライフサイクルの理解

**実装ヒント：**
- Thread.start() でスレッド開始（run() 直接呼び出しは×）
- Thread.join() で他スレッドの完了待機
- Thread.sleep() で一時停止

---

### 課題2: 同期処理とデータ競合対策

**学習目標：** 排他制御の適切な実装、パフォーマンスを考慮した同期設計、デッドロック回避策の理解

**問題説明：**
同期処理を実装し、データ競合を防ぐ方法を理解してください。

**要求仕様：**
- synchronized キーワードによる排他制御
- Lock インターフェイスを使った明示的なロック
- volatile キーワードの使用
- スレッドセーフなデータ構造の実装
- デッドロック回避策

**実行例：**
```
=== 同期処理とデータ競合対策 ===
データ競合テスト:
非同期カウンタ:
期待値: 10,000
実際の値: 8,743
データ競合が発生しました！

同期カウンタ:
期待値: 10,000
実際の値: 10,000
データ整合性が保たれました

銀行口座の並行操作:
初期残高: 100,000円

並行取引（10スレッド×100回取引）:
スレッド1: 取引開始
スレッド2: 取引開始
...
スレッド1: 1,000円入金 → 残高: 101,000円
スレッド2: 500円出金 → 残高: 100,500円
スレッド3: 2,000円入金 → 残高: 102,500円
...

最終残高: 150,000円
取引回数: 1,000回
成功取引: 950回
失敗取引: 50回（残高不足）

Lockを使った高度な同期:
ReadWriteLock テスト:
読み取りスレッド×5: 並行実行可能
書き込みスレッド×2: 排他実行
読み取り時間: 100ms
書き込み時間: 500ms

デッドロック回避テスト:
Account A → Account B 振込: 成功
Account B → Account A 振込: 成功
ロック順序制御により デッドロック回避

volatile変数テスト:
フラグ変更前: false
フラグ変更後: true（全スレッドで即座に反映）
```

**評価ポイント：**
- 排他制御の適切な実装
- パフォーマンスを考慮した同期設計
- デッドロック回避策の理解

**実装ヒント：**
- synchronized メソッド: public synchronized void method()
- synchronized ブロック: synchronized(object) { ... }
- ReentrantLock で明示的ロック制御

---

### 課題3: 並行コレクションとExecutor

**学習目標：** 並行コレクションの適切な選択、ExecutorService の効果的な活用、非同期処理パターンの実装

**問題説明：**
並行処理専用のコレクションとExecutorServiceを活用してください。

**要求仕様：**
- ConcurrentHashMap、CopyOnWriteArrayList等の使用
- ExecutorServiceによるスレッドプール管理
- Future と Callable による結果取得
- CompletableFuture による非同期処理
- 並行処理パターンの実装

**実行例：**
```
=== 並行コレクションとExecutor ===
ConcurrentHashMap テスト:
初期データ: {user1=100, user2=200, user3=300}

並行更新（10スレッド）:
スレッド1: user1 に 10 追加
スレッド2: user2 に 20 追加
スレッド3: user3 に 30 追加
...

最終結果: {user1=150, user2=250, user3=350}
データ整合性: 保証

CopyOnWriteArrayList テスト:
読み取り専用操作（高速）
書き込み時のコピー作成
並行読み取り: 10スレッド同時実行
読み取り時間: 1ms（ロックなし）

ExecutorService テスト:
スレッドプール作成: 5スレッド
タスク投入: 20個

タスク実行中:
Thread-1: タスク1 実行（1秒）
Thread-2: タスク2 実行（2秒）
Thread-3: タスク3 実行（1秒）
Thread-4: タスク4 実行（3秒）
Thread-5: タスク5 実行（1秒）

進行状況: 5/20 完了
進行状況: 10/20 完了
進行状況: 15/20 完了
進行状況: 20/20 完了

実行結果:
全タスク完了時間: 8秒
平均タスク時間: 1.6秒

Future による結果取得:
非同期計算開始: 複雑な数学計算
他の処理継続中...
計算結果取得: 42（計算時間: 3秒）

CompletableFuture チェーン:
step1: データ取得 → [1, 2, 3, 4, 5]
step2: 変換処理 → [2, 4, 6, 8, 10]
step3: 集計処理 → 30
最終結果: 30

スレッドプール統計:
アクティブスレッド: 0
完了タスク数: 20
キューサイズ: 0
プール状態: 正常終了
```

**評価ポイント：**
- 並行コレクションの適切な選択
- ExecutorService の効果的な活用
- 非同期処理パターンの実装

**実装ヒント：**
- Executors.newFixedThreadPool(n) でスレッドプール
- Future<T> で非同期結果取得
- CompletableFuture.supplyAsync() で非同期実行

---

### 課題4: 生産者・消費者パターン

**学習目標：** 生産者・消費者パターンの理解、適切な同期プリミティブの選択、スループット最適化の考慮

**問題説明：**
生産者・消費者パターンを実装し、スレッド間通信を理解してください。

**要求仕様：**
- BlockingQueue を使った生産者・消費者パターン
- wait/notify を使った低レベル同期
- セマフォによるリソース制限
- スレッド間のデータ受け渡し
- 処理能力のバランス調整

**実行例：**
```
=== 生産者・消費者パターン ===
BlockingQueue による実装:
キューサイズ: 10
生産者: 2スレッド
消費者: 3スレッド

生産開始:
Producer-1: アイテム1 生成 → キュー[1]
Producer-2: アイテム2 生成 → キュー[1,2]
Producer-1: アイテム3 生成 → キュー[1,2,3]
...

消費開始:
Consumer-1: アイテム1 消費 ← キュー[2,3,4]
Consumer-2: アイテム2 消費 ← キュー[3,4,5]
Consumer-3: アイテム3 消費 ← キュー[4,5,6]
...

統計情報:
生産アイテム数: 1,000個
消費アイテム数: 1,000個
平均キューサイズ: 5.2個
生産速度: 100個/秒
消費速度: 120個/秒

wait/notify による実装:
共有バッファ（サイズ: 5）
Producer: データ生成中...
Buffer: [data1] - notify消費者
Consumer: data1 消費 - notify生産者
Buffer: [data2] - notify消費者
Consumer: data2 消費 - notify生産者

セマフォによるリソース制限:
利用可能リソース: 3個
Thread-1: リソース取得（残り2個）
Thread-2: リソース取得（残り1個）
Thread-3: リソース取得（残り0個）
Thread-4: 待機中...
Thread-1: リソース解放（残り1個）
Thread-4: リソース取得（残り0個）

スループット測定:
生産者1：消費者1 → 50個/秒
生産者1：消費者2 → 75個/秒
生産者2：消費者2 → 90個/秒
生産者2：消費者3 → 95個/秒
最適構成: 生産者2：消費者3

パフォーマンス比較:
ArrayBlockingQueue: 95個/秒
LinkedBlockingQueue: 87個/秒
SynchronousQueue: 120個/秒（直接受け渡し）
```

**評価ポイント：**
- 生産者・消費者パターンの理解
- 適切な同期プリミティブの選択
- スループット最適化の考慮

**実装ヒント：**
- ArrayBlockingQueue で固定サイズキュー
- put() でブロッキング挿入、take() でブロッキング取得
- Semaphore でリソース数制限

---

## 💡 実装のヒント

### マルチスレッドのポイント

1. **スレッド作成**: Thread継承 vs Runnable実装
2. **同期制御**: synchronized vs Lock インターフェイス
3. **並行コレクション**: スレッドセーフなデータ構造
4. **ExecutorService**: スレッドプールによる効率的管理
5. **スレッド間通信**: BlockingQueue、wait/notify
6. **パフォーマンス**: 適切な並行度とオーバーヘッド考慮

### よくある落とし穴
- run()メソッドの直接呼び出し（start()を使う）
- 同期処理の範囲が広すぎる・狭すぎる
- デッドロックの発生（ロック順序に注意）
- リソースリーク（ExecutorServiceのshutdown忘れ）

### 設計のベストプラクティス
- 可能な限りimmutableオブジェクトを使用
- 共有状態を最小限に抑制
- 並行コレクションの積極的活用
- 適切な粒度での同期処理設計

---

## 🔗 実装環境

演習課題の詳細な実装テンプレート、テストコード、解答例は以下のディレクトリを参照してください：

```
exercises/chapter16/
├── basic/          # 基礎レベル課題
│   ├── README.md   # 詳細な課題説明
│   ├── BasicThreading.java
│   ├── SynchronizedCounter.java
│   ├── ConcurrentCollections.java
│   └── ProducerConsumer.java
├── advanced/       # 応用レベル課題
├── challenge/      # 発展レベル課題
└── solutions/      # 解答例（実装完了後に参照）
```

---

## ✅ 完了確認チェックリスト

### 基礎レベル
- [ ] 基本的なスレッド操作ができている
- [ ] 同期処理とデータ競合対策が実装できている
- [ ] 並行コレクションとExecutorが活用できている
- [ ] 生産者・消費者パターンが実装できている

### 技術要素
- [ ] スレッドセーフなプログラムが書けている
- [ ] 適切な並行処理設計ができている
- [ ] パフォーマンスを考慮した実装ができている
- [ ] デッドロック等の問題を回避できている

### 応用レベル
- [ ] 高度な並行処理パターンを実装できている
- [ ] パフォーマンス測定と最適化ができている
- [ ] 実用的な並行アプリケーションが構築できている
- [ ] 並行処理のトラブルシューティングができている

**次のステップ**: 基本課題が完了したら、advanced/の発展課題でより高度な並行プログラミングに挑戦しましょう！

## 20.1 マルチスレッドプログラミングの基礎

スレッドとは、プログラム内での処理の流れを表す実行単位です。通常、1つのプログラムは1つのスレッド（メインスレッド）で実行されます。

**マルチスレッド**とは、1つのプログラム内で複数のスレッドを同時に実行し、処理を並行して進める技術です。

### なぜマルチスレッドが必要か

現代のコンピュータは、複数のコアを持つCPU（マルチコアプロセッサ）を搭載するのが一般的です。マルチスレッドプログラミングは、この複数のコアを効率的に活用し、アプリケーションのパフォーマンスを向上させるための重要な技術です。

-   **パフォーマンスの向上**: 時間のかかる処理を複数のスレッドに分割し、同時に実行することで、全体の処理時間を短縮できます。
-   **応答性の維持**: GUIアプリケーションなどで、時間のかかる処理をバックグラウンドのスレッドに任せることで、ユーザーインターフェイスが固まるのを防ぎます。
-   **リソースの有効活用**: サーバアプリケーションなどでは、複数のクライアントからのリクエストを同時に処理することで、計算リソースを有効に活用できます。

## 20.2 スレッドの作成と実行

Javaでスレッドを作成するには、主に`Runnable`インターフェイスを実装する方法が推奨されます。

### `Runnable`インターフェイスの実装（推奨）

`Runnable`は、スレッドが実行するタスク（処理内容）を定義するための関数型インターフェイスです。`run()`メソッドを1つだけ持ちます。

```java
// Runnableを実装したクラス
class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println("タスク実行中: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread thread = new Thread(task);
        thread.start(); // スレッドを開始

        // ラムダ式を使えばさらに簡潔
        new Thread(() -> {
            System.out.println("ラムダ式でのタスク実行: " + Thread.currentThread().getName());
        }).start();
    }
}
```

`Runnable`を利用する方法は、Javaがクラスの多重継承をサポートしないという制約を受けず、また「タスク（何をするか）」と「スレッド（どう実行するか）」を分離できるため、より柔軟な設計が可能です。

## 20.3 共有リソースと同期制御

複数のスレッドが、同じデータ（オブジェクトや変数）に同時にアクセスすると、予期せぬ問題が発生することがあります。これを**競合状態 (Race Condition)** と呼びます。

### `synchronized`による排他制御

この問題を解決するために、Javaは`synchronized`キーワードによる**排他制御**のしくみを提供します。`synchronized`で保護されたコードブロックは、一度に1つのスレッドしか実行できないことが保証されます。

```java
class SynchronizedCounter {
    private int count = 0;

    // このメソッドはsynchronizedによりスレッドセーフになる
    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}
```

`synchronized`は非常に強力ですが、ロックの範囲が広すぎるとパフォーマンスの低下を招いたり、複数のロックが絡み合うと**デッドロック**（スレッドがお互いを待ち続けて処理が進まなくなる状態）を引き起こしたりする危険性もあります。

## 20.4 Executorフレームワークによる高度なスレッド管理

スレッドを直接生成・管理するのは複雑で、エラーも発生しやすいため、現代のJavaプログラミングでは**Executorフレームワーク**を使用するのが一般的です。これは、スレッドの生成・管理を抽象化し、**スレッドプール**を利用して効率的にタスクを実行するためのしくみです。

### `ExecutorService`とスレッドプール

`ExecutorService`は、タスクの投入とスレッドプールの管理を行うためのインターフェイスです。スレッドプールは、あらかじめ作成された再利用可能なスレッドの集まりです。

-   **パフォーマンス向上**: スレッドの生成・破棄コストを削減できます。
-   **リソース管理**: 作成されるスレッド数を制限し、システムの安定性を高めます。

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorExample {
    public static void main(String[] args) {
        // 3つのスレッドを持つスレッドプールを作成
        ExecutorService executor = Executors.newFixedThreadPool(3);

        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("Task " + taskId + " is being executed by " + Thread.currentThread().getName());
            });
        }

        // ExecutorServiceをシャットダウン
        executor.shutdown();
    }
}
```

### `Future`による非同期処理の結果取得

計算結果などの戻り値が必要なタスクには、`Callable<V>`インターフェイスを使います。`submit()`メソッドで`Callable`を投入すると、非同期処理の結果を表す`Future<V>`オブジェクトが返されます。

```java
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Callable<Integer> task = () -> {
            System.out.println("Calculating sum...");
            Thread.sleep(2000); // 時間のかかる計算を模倣
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
            }
            return sum;
        };

        Future<Integer> future = executor.submit(task);
        System.out.println("他の処理を実行中です...");

        // future.get()でタスクの完了を待ち、結果を取得
        Integer result = future.get();
        System.out.println("計算結果: " + result);

        executor.shutdown();
    }
}
```

## まとめ

-   **マルチスレッド**は、複数の処理を並行して実行し、アプリケーションのパフォーマンスや応答性を向上させる技術です。
-   タスクの定義には、柔軟性の高い`Runnable`インターフェイス（特にラムダ式）の使用が推奨されます。
-   複数のスレッドが共有リソースにアクセスする際は、`synchronized`などによる**同期制御**が必要です。
-   **Executorフレームワーク**とスレッドプールを利用することで、スレッド管理を安全かつ効率的に行うことができます。

マルチスレッドプログラミングは、現代のアプリケーション開発において不可欠なスキルの1つです。