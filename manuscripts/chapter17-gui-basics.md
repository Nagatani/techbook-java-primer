# 第17章 GUIプログラミングの基礎

## 本章の学習目標

### 前提知識
**必須前提**：
- 第11章までの総合的なJavaプログラミング能力
- イベント処理の基本概念
- オブジェクト指向設計の実践経験

**ユーザーインターフェイス前提**：
- GUIアプリケーションの使用経験
- ユーザビリティに対する基本的な理解

### 学習目標
**知識理解目標**：
- GUIプログラミングの基本概念と課題
- イベント駆動プログラミングモデルの理解
- Swingフレームワークのアーキテクチャ
- レイアウトマネージャーの種類と特徴

**技能習得目標**：
- 基本的なGUIコンポーネントの使用
- イベントリスナの実装
- レイアウトマネージャーを使った柔軟な画面設計
- 基本的なユーザーインタラクションの実装

**アプリケーション設計能力目標**：
- MVCパターンを意識したGUI設計
- ユーザビリティを考慮したインターフェイス設計
- 保守性の高いGUIアプリケーションの設計

**到達レベルの指標**：
- 基本的な機能を持つGUIアプリケーションが独力で開発できる
- ユーザーの操作に適切に応答するイベント処理が実装できる
- 画面レイアウトとコンポーネント配置を適切に設計できる
- ファイルI/Oと連携したGUIアプリケーションが作成できる

---

## 章末演習

本章で学んだGUIプログラミングの基礎概念を活用して、実践的な練習課題に取り組みましょう。

### 🎯 演習の目標
- SwingによるGUIアプリケーションの基本構築
- 基本コンポーネント（JButton、JLabel、JTextField等）の使用
- レイアウトマネージャーの理解と適用
- イベント処理の実装
- ウィンドウとダイアログの操作
- メニューシステムの構築

### 演習課題の難易度レベル

#### 🟢 基礎レベル（Basic）
- **目的**: Swing GUIの基本コンポーネントとレイアウトの理解
- **所要時間**: 40-60分/課題
- **前提**: 本章の内容を理解していること
- **評価基準**: 
  - 基本コンポーネントの適切な使用
  - レイアウトマネージャーの効果的な活用
  - イベント処理の基本的な実装
  - ユーザビリティの考慮

---

## 🟢 基礎レベル課題（必須）

### 課題1: 電卓アプリケーション

**学習目標：** GridLayoutの効果的な使用、計算ロジックの正確な実装、ユーザビリティの考慮

**問題説明：**
四則演算ができる電卓GUIアプリケーションを作成してください。

**要求仕様：**
- 数字ボタン（0-9）と演算子ボタン（+、-、×、÷）
- 結果表示用のJTextField
- GridLayoutによるボタン配置
- 計算ロジックの実装
- エラーハンドリング（ゼロ除算等）

**実行例：**
```
=== 電卓アプリケーション ===
ウィンドウ表示: "Calculator"
サイズ: 300x400ピクセル

電卓レイアウト:
┌─────────────────────────────────┐
│ [123.45________________]    │ (結果表示)
├─────────────────────────────────┤
│ [C] [±] [%] [÷]             │
├─────────────────────────────────┤
│ [7] [8] [9] [×]             │
├─────────────────────────────────┤
│ [4] [5] [6] [-]             │
├─────────────────────────────────┤
│ [1] [2] [3] [+]             │
├─────────────────────────────────┤
│ [0] [.] [=]                 │
└─────────────────────────────────┘

計算テスト:
操作: 1 + 2 =
表示: 1 → 1 + → 1 + 2 → 1 + 2 = 3

操作: 10 ÷ 3 =
表示: 10 ÷ 3 = 3.333333

エラーハンドリング:
操作: 10 ÷ 0 =
表示: "エラー: ゼロ除算"
[C]ボタンでリセット
```

**評価ポイント：**
- GridLayoutの効果的な使用
- 計算ロジックの正確な実装
- ユーザビリティの考慮

**実装ヒント：**
- GridLayout(4, 4) で4×4のボタン配置
- Double型で計算精度を保つ
- try-catchでNumberFormatException処理

---

### 課題2: シンプルメモ帳

**学習目標：** メニューシステムの実装、ファイルI/Oとの連携、キーボードショートカットの実装

**問題説明：**
基本的なテキストエディタGUIアプリケーションを作成してください。

**要求仕様：**
- JTextAreaによるテキスト編集エリア
- JScrollPaneによるスクロール機能
- メニューバー（ファイル、編集、ヘルプ）
- ファイルの開く・保存機能
- 変更検知とタイトルバー表示

**実行例：**
```
=== シンプルメモ帳 ===
ウィンドウ表示: "SimpleNotepad"
サイズ: 800x600ピクセル

メニュー構成:
ファイル(F)
├── 新規作成 (Ctrl+N)
├── 開く (Ctrl+O)
├── 保存 (Ctrl+S)
├── 名前を付けて保存
├── ──────────
└── 終了 (Alt+F4)

編集(E)
├── 切り取り (Ctrl+X)
├── コピー (Ctrl+C)
├── 貼り付け (Ctrl+V)
├── ──────────
└── すべて選択 (Ctrl+A)

ヘルプ(H)
└── バージョン情報

エディタ画面:
┌─────────────────────────────────┐
│ [メニューバー]              │
├─────────────────────────────────┤
│ ┌─スクロール可能テキストエリア─┐ │
│ │ Hello, World!           │ │
│ │ Java Swing Text Editor  │ │
│ │ 複数行のテキスト編集が    │ │
│ │ 可能です。              │ │
│ │ ■                      │ │ (カーソル)
│ └───────────────────────────────┘ │
└─────────────────────────────────┘

ファイル操作テスト:
1. [新規作成]: 空のドキュメント
2. テキスト入力: "Hello, World!"
3. [保存]: sample.txt として保存
4. [開く]: sample.txt を読み込み
```

**評価ポイント：**
- メニューシステムの実装
- ファイルI/Oとの連携
- キーボードショートカットの実装

**実装ヒント：**
- JScrollPaneで自動スクロール
- JFileChooserでファイル選択ダイアログ
- KeyStrokeでキーボードショートカット

---

### 課題3: レイアウトデモ

**学習目標：** 各レイアウトマネージャーの特徴理解、JTabbedPaneの効果的な使用、レイアウトの動的変更実装

**問題説明：**
異なるレイアウトマネージャーの動作を比較できるデモアプリケーションを作成してください。

**要求仕様：**
- 複数のレイアウトマネージャーを試せるタブ画面
- BorderLayout、FlowLayout、GridLayout、BoxLayout、CardLayout、GridBagLayoutのデモ
- レイアウトの動的切り替え機能
- ウィンドウサイズ変更時の動作確認

**実行例：**
```
=== レイアウトマネージャーデモ ===
ウィンドウ表示: "Layout Manager Demo"
サイズ: 700x500ピクセル

タブ構成:
- BorderLayout: 5方向配置デモ
- FlowLayout: 左・中央・右配置デモ
- GridLayout: 行列数可変デモ
- BoxLayout: 水平・垂直配置デモ
- CardLayout: カード切り替えデモ
- GridBagLayout: 複雑な配置デモ
- Dynamic Layout: 動的レイアウト変更

各タブでの学習内容:
1. BorderLayout: North、South、East、West、Center配置
2. FlowLayout: LEFT、CENTER、RIGHT整列
3. GridLayout: 行列グリッド配置
4. BoxLayout: X_AXIS、Y_AXIS配置
5. CardLayout: カード切り替え操作
6. GridBagLayout: 制約を使った複雑配置
```

**評価ポイント：**
- 各レイアウトマネージャーの特徴理解
- JTabbedPaneの効果的な使用
- レイアウトの動的変更実装

**実装ヒント：**
- JTabbedPaneでタブ切り替え
- GridBagConstraintsで制約設定
- revalidate()、repaint() で再描画

---

### 課題4: カラーピッカー

**学習目標：** JSliderの効果的な使用、ColorクラスのRGB/HSB変換理解、リアルタイム更新の実装

**問題説明：**
色を選択・調整できるカラーピッカーアプリケーションを作成してください。

**要求仕様：**
- RGB値を個別に調整できるスライダー
- HSB値を個別に調整できるスライダー
- 色のプレビューエリア
- 16進数カラーコード表示
- 色履歴の保存・呼び出し機能
- プリセットカラー選択

**実行例：**
```
=== カラーピッカー ===
ウィンドウ表示: "Color Picker"
サイズ: 800x600ピクセル

コンポーネント構成:
┌─────────────────────────────────┐
│ RGB スライダー              │
│ Red: [====o========] 128    │
│ Green: [====o======] 128    │
│ Blue: [====o=======] 128    │
├─────────────────────────────────┤
│ HSB スライダー              │
│ Hue: [=====o=======] 180    │
│ Saturation: [==o===] 50     │
│ Brightness: [==o===] 50     │
├─────────────────────────────────┤
│ ┌─プレビュー─┐ 16進数: #808080│
│ │           │ 色名: Gray     │
│ │   Gray    │ [Color Chooser]│
│ │           │                │
│ └───────────┘                │
├─────────────────────────────────┤
│ プリセットカラー            │
│ [■][■][■][■][■][■][■][■]│
│ [■][■][■][■][■][■][■][■]│
├─────────────────────────────────┤
│ 補色・類似色                │
│ 補色: [■] 類似色: [■][■][■]│
├─────────────────────────────────┤
│ 色履歴リスト                │
│ RGB(128, 128, 128)          │
│ RGB(255, 0, 0)              │
│ RGB(0, 255, 0)              │
└─────────────────────────────────┘

操作テスト:
1. RGBスライダー調整 → 色変更
2. HSBスライダー調整 → 色変更
3. 16進数入力 → #FF0000 → 赤色
4. プリセットクリック → 既定色選択
5. Color Chooser → 高度な色選択
```

**評価ポイント：**
- JSliderの効果的な使用
- ColorクラスのRGB/HSB変換理解
- リアルタイム更新の実装

**実装ヒント：**
- Color.RGBtoHSB（） とColor.HSBtoRGB() を使用
- JSliderの値変更リスナでリアルタイム更新
- ArrayListで色履歴を管理

---

## 💡 実装のヒント

### GUI基礎のポイント

1. **コンポーネント階層**: Container → Componentの関係
2. **レイアウトマネージャー**: BorderLayout、GridLayout、FlowLayout等
3. **イベント処理**: ActionListener、ChangeListener等
4. **スレッド**: Event Dispatch Thread（EDT）での実行
5. **Look & Feel**: プラットフォーム固有の外観
6. **ダイアログ**: JOptionPane、JFileChooser等

### よくある落とし穴
- EDT以外からのGUI操作（SwingUtilities.invokeLater使用）
- レイアウトマネージャーの不適切な選択
- イベントリスナのメモリリーク
- 適切なサイズ設定とリサイズ対応

### 設計のベストプラクティス
- MVCパターンでGUIとロジックを分離
- 再使用可能なコンポーネント設計
- ユーザーエクスペリエンスを意識したデザイン
- アクセシビリティとキーボード操作の考慮

---

## 🔗 実装環境

演習課題の詳細な実装テンプレート、テストコード、解答例は以下のディレクトリを参照してください：

```
exercises/chapter17/
├── basic/          # 基礎レベル課題
│   ├── README.md   # 詳細な課題説明
│   ├── Calculator.java
│   ├── SimpleNotepad.java
│   ├── LayoutDemo.java
│   └── ColorPicker.java
├── advanced/       # 応用レベル課題
├── challenge/      # 発展レベル課題
└── solutions/      # 解答例（実装完了後に参照）
```

---

## ✅ 完了確認チェックリスト

### 基礎レベル
- [ ] 電卓で基本的な計算機能が実装できている
- [ ] メモ帳でファイル操作とメニューシステムができている
- [ ] レイアウトデモで各レイアウトマネージャーの特徴を理解している
- [ ] カラーピッカーでスライダーと色変換ができている

### 技術要素
- [ ] Swingの基本コンポーネントを理解している
- [ ] イベント処理のしくみを把握している
- [ ] レイアウトマネージャーを適切に使い分けできている
- [ ] ユーザビリティを考慮した設計ができている

### 応用レベル
- [ ] 複雑なGUIアプリケーションが構築できている
- [ ] カスタムコンポーネントの作成ができている
- [ ] パフォーマンスを考慮したGUI設計ができている
- [ ] クロスプラットフォーム対応のGUIが作成できている

**次のステップ**: 基本課題が完了したら、advanced/の発展課題でより複雑なGUIアプリケーション開発に挑戦しましょう！

## 11.1 GUIプログラミングの世界へ

これまでの学習では、コンソール（黒い画面）に文字を出力し、キーボードから入力する**CUI（Character User Interface）** を中心に扱ってきました。CUIは効率的な操作が可能ですが、直感的とは言えません。

本章からは、ウィンドウやボタン、テキストボックスなどをマウスで操作する**GUI（Graphical User Interface）** アプリケーションの開発を学びます。GUIは、その視覚的な分かりやすさから、現代のあらゆるアプリケーションの標準となっています。

### イベント駆動プログラミングとは？

CUIプログラムの多くは、処理の順番をプログラマが記述する「手続き型」でした。しかし、GUIアプリケーションでは、ユーザーがいつ、どのボタンを押すか予測できません。

そこで、「**ユーザーの操作（イベント）** をきっかけに、**特定の処理（リスナ）** が動く」という**イベント駆動（Event-Driven）** というモデルが採用されています。これは、「**何かが起きたら、これを実行する**」というルールの集合でプログラムを構築する考え方です。

### JavaのGUIライブラリ

Javaには、GUIを実現するためのライブラリがいくつか存在します。

- **AWT (Abstract Window Toolkit)**: Java初期からあるライブラリ。OSネイティブの部品を使うため動作は軽快ですが、OSによる見た目の差異が大きいという特徴があります。
- **Swing**: AWTを拡張し、Java自身が部品を描画するライブラリ。OSに依存しない統一された見た目（Look & Feel）を提供でき、長年の実績があり安定しています。本書ではこのSwingを中心に学習します。
- **JavaFX**: Swingの後継として開発された、よりモダンで表現力豊かなライブラリ。現在では標準ライブラリから外れ、オープンソースプロジェクトとして開発が継続されています。

## 11.2 Swingによる画面作成の第一歩

### `JFrame`: すべての土台となるウィンドウ

Swingアプリケーションは、`JFrame`クラスのインスタンス、つまり「ウィンドウ」から始まります。

```java
import javax.swing.JFrame;

public class MyFirstFrame {
    public static void main(String[] args) {
        // 1. JFrameクラスのインスタンスを作成（これがウィンドウの実体）
        JFrame frame = new JFrame();

        // 2. ウィンドウのタイトルを設定
        frame.setTitle("はじめてのSwing");

        // 3. ウィンドウのサイズをピクセル単位で設定
        frame.setSize(400, 300);

        // 4. 閉じるボタン（×）の動作を設定（プログラムを終了する）
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // 5. ウィンドウを画面中央に表示
        frame.setLocationRelativeTo(null);

        // 6. ウィンドウを画面に表示（これが無いと表示されない）
        frame.setVisible(true);
    }
}
```

このコードを実行すると、400x300ピクセルの空のウィンドウが画面中央に表示されます。

### `JPanel`: コンポーネントをまとめる透明なパネル

`JFrame`という土台の上に、さまざまな部品（コンポーネント）を配置して画面を構築していきます。しかし、直接`JFrame`に部品を置くのではなく、`JPanel`という「透明なパネル」の上に部品をグループ化して配置し、その`JPanel`を`JFrame`に配置するのが一般的です。これにより、複雑なレイアウトを整理しやすくなります。

## 11.3 画面を構成する基本コンポーネント

`JPanel`の上に配置する、代表的な画面部品を見ていきましょう。

| クラス名 | 説明 | 主な用途 |
| :--- | :--- | :--- |
| `JLabel` | 編集不可のテキストや画像を表示 | ラベル、見出し、説明文 |
| `JButton` | クリック可能なボタン | アクションの実行トリガ |
| `JTextField` | 1行のテキスト入力フィールド | ユーザー名、検索語の入力 |
| `JTextArea` | 複数行のテキスト入力・表示エリア | 長文の入力、ログの表示 |
| `JCheckBox` | オン／オフを選択できるチェックボックス | 設定の有効/無効、複数選択 |
| `JRadioButton` | 複数から1つだけ選ぶラジオボタン | 性別、配送方法の選択 |

### コンポーネントの配置とレイアウト管理

コンポーネントをどこに配置するかを決めるのが**レイアウトマネージャ**の役割です。ウィンドウサイズが変わってもレイアウトが崩れないように、ルールに従って自動で再配置してくれます。

- **`FlowLayout`**: 部品を左から右へ、行が埋まると次の行へと流れるように配置します。(`JPanel`のデフォルト）
- **`BorderLayout`**: 画面を「上下左右中央（North/South/East/West/Center)」の5領域に分割します。（`JFrame`のデフォルト）
- **`GridLayout`**: 画面を格子状（マス目）に分割し、全部品を同じサイズで配置します。

#### レイアウトの組み合わせによる画面構築

`JPanel`を入れ子にすることで、これらのレイアウトを組み合わせて複雑な画面を構築できます。

```java
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

public class ComplexLayoutExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("複雑なレイアウト");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(400, 300);

        // --- 上部パネル (FlowLayout) ---
        JPanel topPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        topPanel.add(new JTextField(25));
        topPanel.add(new JButton("検索"));
        
        // --- 中央のテキストエリア ---
        JTextArea centerTextArea = new JTextArea();
        
        // --- 下部パネル (FlowLayout) ---
        JPanel bottomPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        bottomPanel.add(new JButton("OK"));
        bottomPanel.add(new JButton("キャンセル"));

        // --- フレームに各パーツを配置 (BorderLayout) ---
        frame.add(topPanel, BorderLayout.NORTH);
        frame.add(new JScrollPane(centerTextArea), BorderLayout.CENTER); // スクロール可能にする
        frame.add(bottomPanel, BorderLayout.SOUTH);

        frame.setLocationRelativeTo(null);
        frame.setVisible(true);
    }
}
```

## まとめ

本章では、GUIアプリケーションの「静的」な側面、つまり画面の骨格と見た目を構築する方法を学びました。`JFrame`を土台とし、`JPanel`とレイアウトマネージャーを駆使してコンポーネントを配置することで、複雑な画面も整理して作成できることを理解しました。

次章では、これらの画面に「動的」な命を吹き込むイベント処理について学び、ユーザーの操作に応答するインタラクティブなアプリケーションを作成していきます。
