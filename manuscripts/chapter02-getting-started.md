# 第2章 Javaをはじめよう

## 📝 章末演習

本章で学んだクラスとオブジェクトの基本概念を活用して、実践的な練習課題に取り組みましょう。

### 🎯 演習の目標
- クラスとオブジェクトの基本概念の理解
- インスタンス変数とメソッドの実装
- オブジェクトの生成と操作
- カプセル化の基本的な実践

### 📁 課題の場所
演習課題は `exercises/chapter02/` ディレクトリに用意されています：

```
exercises/chapter02/
├── basic/          # 基本課題（必須）
│   ├── README.md   # 課題の詳細説明
│   ├── Person.java # 課題1: Personクラス
│   ├── PersonTest.java
│   ├── Book.java   # 課題2: Bookクラス
│   ├── BookTest.java
│   ├── Circle.java # 課題3: Circleクラス
│   ├── CircleTest.java
│   ├── Car.java    # 課題4: Carクラス
│   └── CarTest.java
├── advanced/       # 発展課題（推奨）
└── challenge/      # 挑戦課題（上級者向け）
```

### 🚀 推奨する学習の進め方

1. **基本課題**から順番に取り組む
2. 各課題のREADME.mdで詳細を確認
3. TODOコメントを参考に実装
4. 実行例と同じ出力になることを確認
5. 理解できたら次の課題へ進む

基本課題が完了したら、`advanced/`の発展課題でより複雑なクラス設計に挑戦してみましょう！

## 📋 本章の学習目標

### 前提知識
**必須前提**：
- 第0章の完全な理解と実践
- Java開発環境の構築完了
- C言語での変数、条件分岐、ループの経験

**望ましい前提**：
- プログラミング言語の比較経験
- コンピュータアーキテクチャの基本理解

### 学習目標
**知識理解目標**：
- Java言語仕様の基本的な理解
- JVM（Java仮想マシン）の役割としくみ
- プラットフォーム独立性の意味と利点
- Javaのメモリ管理（ガベージコレクション）の基本概念

**技能習得目標**：
- Java基本データ型の適切な使用
- 変数宣言と初期化の正確な記述
- 制御構造（if-else、for、while）のJava記法での実装
- メソッドの定義、呼び出し、戻り値の処理
- 配列の宣言、初期化、操作

**実践的な活用目標**：
- 基本的な数値計算プログラムの作成
- 文字列処理を含む実用的な小プログラムの開発
- エラーメッセージの理解と基本的なデバッグ

**到達レベルの指標**：
- 手続き型スタイルでの基本的なJavaプログラムが独力��作成できる
- C言語とJavaの文法的違いを説明できる
- 基本的なコンパイルエラーを理解し修正できる
- 簡単なアルゴリズム（ソート、検索）をJavaで実装できる

---

## 始めに：プログラミング言語の進化とJavaの革新

プログラミングの世界に足を踏み入れる皆さんにとって、最初に学ぶプログラミング言語の選択は、その後の技術的な成長に大きな影響を与える重要な決断です。本章では、現代のソフトウェア開発において最も重要で影響力のあるプログラミング言語の1つである「Java」について、その歴史的背景、技術的特徴、そして現代における意義を詳細に学習します。

Javaは単なるプログラミング言語ではありません。1990年代から現在に至るまで、ソフトウェア開発の方法論を根本的に変革し、インターネット時代の到来とともに世界中のシステム開発の標準となった、革命的な技術プラットフォームです。

### プログラミング言語の歴史的進化とJavaの位置付け

コンピュータプログラミングの歴史は、より高度な抽象化と、より強力な表現力を求める絶え間ない進歩の歴史でもあります。1940年代の機械語から始まり、1950年代のアセンブリ言語、1960年代のFORTRANやCOBOL、1970年代のC言語、1980年代のC++へと、プログラミング言語は段階的に進化してきました。

この進化の過程で、プログラマたちは常に同じ課題に直面していました。「プログラムの複雑性をいかに管理するか」「異なるコンピュータ環境での互換性をいかに確保するか」「開発効率と実行効率をいかに両立させるか」という根本的な問題です。

1990年代初頭、インターネットの商用利用が始まり、世界中のコンピュータが相互接続される時代が到来しました。この時代の変化は、従来のプログラミング言語では対応困難な新たな課題を提起こしました。異なるOS、異なるハードウェアアーキテクチャ、異なるネットワーク環境で動作する必要があるソフトウェアの需要が急激に高まったのです。

### Javaの誕生：Sun Microsystemsの革新的ビジョン

1991年、Sun Microsystemsの技術者ジェームズ・ゴスリン（James Gosling）率いるチームは、当初「Oak」と呼ばれる新しいプログラミング言語の開発を開始しました。最初の目標は、家電製品や組込みステム用の言語でしたが、インターネットの急速な普及により、プロジェクトの方向性は大きく転換されました。

1995年、「Java」として正式にリリースされたこの言語は、従来のプログラミング言語が抱えていた根本的な問題を解決する革新的なアプローチを採用していました。その核心となるのが「Write Once, Run Anywhere（一度書けば、どこでも実行できる）」という哲学です。

この哲学を実現するために、Javaは従来の言語とは根本的に異なる実行モデルを採用しました。プログラムは、特定のハードウェアやOSに依存する機械語ではなく、「バイトコード」と呼ばれる中間表現にコンパイルされます。このバイトコードは、「Java仮想マシン（JVM: Java Virtual Machine）」と呼ばれる実行環境上で動作します。

### Java仮想マシン：ソフトウェア実行の新しいパラダイム

Java仮想マシンの概念は、コンピュータサイエンスにおける画期的な革新でした。従来、プログラムは物理的なハードウェア上で直接実行されていましたが、JVMは「仮想的なハードウェア」を提供し、そのうえでプログラムを実行するしくみを確立しました。

このしくみにより、以下の革命的な利点が実現されました：

**プラットフォーム独立性の実現**：同じJavaプログラムが、Windows、macOS、Linux、UNIXなど、JVMが動作するあらゆる環境で変更なく実行できるようになりました。企業システムの開発において、特定のOSへの依存から解放されることの意味は計りしれません。

**メモリ管理の自動化**：JVMは「ガベージコレクション」と呼ばれる自動メモリ管理機能を提供します。プログラマは、メモリの確保と解放を手動で管理する必要がなくなり、メモリリークやダングリングポインタなどの深刻なバグから解放されました。

**実行時最適化**：JVMは「Just-In-Time（JIT）コンパイル」と呼ばれる技術により、プログラムの実行中に動的に最適化を行います。これにより、解釈実行の柔軟性と、コンパイル実行の性能を両立できます。

**セキュリティの強化**：JVMは「サンドボックス」と呼ばれる安全な実行環境を提供し、悪意のあるコードがシステムに損害を与えることを防ぎます。インターネット経由でダウンロードされるプログラム（アプレット）の安全性を確保するため、この機能は特に重要でした。

### オブジェクト指向パラダイムの普及とJavaの貢献

Javaのもう1つの重要な特徴は、オブジェクト指向プログラミングを言語の中核に据えたことです。オブジェクト指向の概念自体は1960年代のSimula言語に始まり、1980年代のC++で実用化されていましたが、Javaはこの概念をより純粋で理解しやすい形で実装しました。

Javaにおけるオブジェクト指向の特徴は以下のとおりです：

**純粋なオブジェクト指向設計**：Javaでは、基本データ型を除くすべてがオブジェクトです。これにより、一貫したプログラミングモデルが実現され、初学者にとって理解しやすい構造となっています。

**単一継承による設計の簡潔性**：C++の多重継承による複雑性を避け、単一継承とインターフェイスの組み合わせにより、シンプルかつ強力な継承モデルを提供しています。

**パッケージシステムによる名前空間管理**：大規模なソフトウェア開発において重要な名前の衝突を防ぐため、パッケージという概念を導入し、階層的な名前空間管理を実現しています。

### 企業システム開発におけるJavaの影響

1990年代後半から2000年代にかけて、Javaは企業システム開発の分野で爆発的に普及しました。この普及の背景には、以下の要因がありました：

**エンタープライズJavaの登場**：Java 2 Enterprise Edition（J2EE、後のJava EE）の導入により、大規模な企業システム開発に必要な技術（データベース接続、トランザクション管理、セキュリティ、分散処理など）が標準化されました。

**アプリケーションサーバの発展**：IBM WebSphere、BEA WebLogic、オープンソースのTomcatなど、Java EEに対応したアプリケーションサーバが登場し、企業システムのプラットフォームとして定着しました。

**開発ツールの充実**：Eclipse、NetBeans、IntelliJ IDEAなどの高機能な統合開発環境（IDE）が登場し、Java開発の生産性が大幅に向上しました。

**豊富なフレームワーク**：Spring Framework、Hibernate、Apache Strutsなど、企業システム開発を支援する多数のフレームワークが開発され、開発効率と品質の向上に貢献しました。

### オープンソース化とコミュニティの形成

2006年、Sun MicrosystemsはJavaのソースコードをオープンソース化し、OpenJDKプロジェクトを開始しました。この決定は、Javaの発展において極めて重要な転換点となりました。

オープンソース化により、以下の重要な変化が生まれました：

**技術革新の加速**：世界中の開発者がJavaの改良に参加できるようになり、技術革新のスピードが大幅に向上しました。

**多様な実装の登場**：Oracle JDK以外にも、OpenJDK、Amazon Corretto、Red Hat OpenJDK、Eclipse Temurinなど、さまざまな組織による実装が登場し、ユーザーは用途に応じて選択できるようになりました。

**長期サポートの充実**：企業ユーザーのニーズに応えるため、長期サポート版（LTS）が提供されるようになり、安定したシステム運用が可能になりました。

### 現代におけるJavaの位置付けと将来性

現在、Javaは以下の分野で圧倒的な地位を占めています：

**エンタープライズシステム**：大企業のもと幹システム、金融システム、政府システムなど、信頼性と安定性が重要なシステムでJavaが広く使用されています。

**Webアプリケーション**：Spring Boot、Micronautなどのフレームワークにより、現代的なWebアプリケーション開発が効率的に行えます。

**マイクロサービスアーキテクチャ**：Docker、Kubernetesなどのコンテナ技術と組み合わせ、スケーラブルな分散システムの構築に活用されています。

**ビッグデータ処理**：Apache Hadoop、Apache Spark、Apache Kafkaなど、多くのビッグデータ処理フレームワークがJavaで実装されています。

**Android開発**：モバイルアプリケーション開発の分野でも、Javaは重要な役割を果たしています（現在はKotlinも併用）。

### 本章で学習する内容の意義

本章では、これらの歴史的背景と技術的意義を踏まえて、Javaプログラミングの基礎を学習していきます。単にプログラムの書き方を覚えるのではなく、以下の点を重視して学習を進めます：

**プラットフォーム独立性の理解**：JVMのしくみを理解し、なぜJavaが「どこでも動く」のかを学習します。

**開発環境の適切な構築**：複数のJDK実装から適切なものを選択し、効率的な開発環境を構築する方法を習得します。

**現代的な開発手法の基礎**：バージョン管理、依存関係管理、統合開発環境の活用など、現代のソフトウェア開発に必要な基本的なスキルを身につけます。

**将来への拡張性**：基礎をしっかりと理解することで、フレームワークやライブラリの学習、より高度な技術への発展の基盤を築きます。

Javaを学習することは、単一のプログラミング言語を習得することを超えて、現代のソフトウェア開発における基本的な概念と技術を理解することにつながります。オブジェクト指向、プラットフォーム独立性、自動メモリ管理、強い型付けなど、Javaで学ぶ概念は、ほかの多くのプログラミング言語や技術の理解にも直結します。

本章を通じて、Javaという言語の持つ力強さと柔軟性を理解し、現代のソフトウェア開発者として必要な基礎的な素養を身につけていきましょう。

## 1.1 Javaの特徴

Javaは以下のような特徴を持つプログラミング言語です：

- **プラットフォーム独立性**：「Write Once, Run Anywhere」
- **オブジェクト指向**：クラスベースのオブジェクト指向言語
- **ガベージコレクション**：自動メモリ管理
- **強い型付け**：コンパイル時の型チェック
- **豊富なライブラリ**：標準ライブラリとサードパーティライブラリ

## 1.2 開発環境の準備
### JDK(JavaSDK)

プログラミング言語Javaの開発環境をJava Software Development Kitと呼び、JavaSDKやJDKなどと略されます。  
Javaでの開発は、複数あるJDKのどれかをインストールすることから始まります。

Javaでの開発にお勧めのIDEである、IntelliJ IDEAからもJDKをインストールできるようになっています。  
ですが、本書では、本書の内容以外でもJDKを使った開発ができるように、一括でバージョン管理が可能なソフトウェアを使用して必要なバージョンのJDKをインストールします。

### JDKの種類

JDKに挟まざまな提供元があり、インストールするJDKの種類が異なることによって講義を円滑に進められない場合もあります。
そのため、本書で使用するJDKはこの内容で指定しているものを必ずインストールするようにしてください。

#### JDKの種類が混乱するほど増えている理由

JDKと一言で言っても、開発元であるOracle以外にもいくつかの企業や団体がJDKとしてリリースしているものがあり、その配布元ごとにさまざまなバージョンのものがあります。

まず、JavaはOSSです。  
（単純にソフトウェアとしての側面のほかに、エコシステムとしての側面もあります）

Javaの商標は、開発元であるOracleが保持しています。ですので、本来はJava™のような書き方をするのが正しいのかもしれません。

JDKの種類が多い理由として、OSSである点が第一に挙げられます。商標自体はOracleが保持していますが、JDK自体のソースコードの取得は開かれているので、それをビルドしてリリースする企業やコミュニティの数だけ、JDKの種類が増えます。
JDKの基本的な機能がその種類ごとで大きく異なってしまうということはあまり考えにくいのですが、状況によっては選んだJDKによって動作が異なることもあり得ます。
Javaでの開発を始める前に、開発を行う企業やコミュニティで使用されているJDKを確認して、それに合わせるように心がけましょう。

### 開発環境のインストールを行います

本書で使用するJavaのバージョンは、OpenJDKと呼ばれるオープン版のJDKを使用し、以下の開発バージョンを使います。

- `OpenJDK 21.0.6 (Microsoft)`

※本書執筆時点のLTS版（長期サポート対応バージョン）の中で最も新しいものを使用しています。

## 1.3 SDKMANを使用したバージョン管理

JDKのインストールの前に、JDKやJavaの開発ライブラリのバージョン別インストールをサポートしてくれるバージョン管理ツールをインストールします。
SDKMAN自体についてや各環境に合わせたインストール方法など、詳しくは以下のリンク先をみてください。

- [SDKMAN!](https://sdkman.io/)

### SDKMANのインストール

1. ターミナルを起動する
    - macOSのターミナルソフトウェアが起動すればよいです。 ターミナルソフトウェアが分からなければ、以下の操作で起動するウィンドウを使います。
    - `[⌘] + [space]`で `Spotlight` から `terminal` を起動
2. 以下のコマンドを実行してダウンロードする（`$`は入力しません）
    - $ `curl -s "https://get.sdkman.io" | bash`
3. 以下のコマンドを実行して初期設定を行う
    - $ `source "$HOME/.sdkman/bin/sdkman-init.sh"`
4. 以下のコマンドで正しくインストールされたかを確認する
    - $ `sdk version`
    - ```SDKMAN!```<br>```script: 5.19.0```<br>```native: 0.7.4 (macos aarch64)```のようなバージョン情報が出力されていればOKです。
5. 使用しているターミナルソフトウェアに合わせて環境変数を設定

macOSのターミナルソフトウェアとして、zshを使用している場合は以下のコマンドを使用します（`$`は入力しません）

```zsh
$ echo 'export JAVA_HOME=$HOME/.sdkman/candidates/java/current' >> ~/.zprofile
$ echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.zprofile
$ source ~/.zprofile
```

これらの環境変数の設定は、ほかのJavaを参照するアプリケーションのために設定しておきます。

#### 再履修者向け: SDKMANのアップグレード

すでにSDKMANをインストール済みの場合は、以下のコマンドでセルフアップグレードを行ってください。

```bash
$ sdk selfupdate force
```

### SDKMANを使用したJDKインストール

1. ターミナルを起動
2. $ `sdk list java` で現在インストール可能なJavaを一覧表示できます（開かれたテキストはvi形式です。次の行はエンターキー、次のページはスペースキー、閉じる場合は`:q`と入力します）
3. $ `sdk install java 21.0.6-ms` でJDKがインストールされます。
4. $ `java -version` でインストールされたJDKのバージョンが正しいか確認します。

以下のようにバージョン情報が出力されていればOKです。

```
openjdk 21.0.6 2025-01-21 LTS
OpenJDK Runtime Environment Microsoft-10800196 (build 21.0.6+7-LTS)
OpenJDK 64-Bit Server VM Microsoft-10800196 (build 21.0.6+7-LTS, mixed mode, sharing)
```

これでJDKの用意は完了です。

## 1.4 複数バージョンのJDKをインストールした場合

SDKMANをインストールして、SDKMAN経由でJDKをインストールした場合は、SDKMANが使用するバージョンをコントロールしてくれるため、設定ファイルを細々と書き換える必要はありません。

SDKMANでJDKのバージョンを切り替えたい場合は、以下のように行います。

```bash
sdk list java                  # インストール可能なバージョンとインストール済みのバージョンを確認
sdk use java 21.0.6-ms         # 現在のターミナルで使用するバージョンを設定
sdk default java 21.0.6-ms     # 標準で使用するバージョンを設定
```

## 1.5 統合開発環境（IDE）

本書では以下のIDEを推奨します：
- **IntelliJ IDEA**（Community Editionで十分）
- **Visual Studio Code**（Java開発の拡張機能が必須です）

IDEの利用に関しては、IntelliJ IDEA Community Editionがお勧めです。

本書で取り上げる操作説明などは、IntelliJ IDEA Community Editionを基本とします。

## 1.6 Hello Worldプログラム

Javaの開発環境構築やIDEのインストールが完了したところだと思います。  
まずは、JDKのみを使用し、IDEを使わずにJavaのプログラムを作成する方法を知りましょう。

本章の内容に限り、ターミナル上でプログラムを書きます。  
では、macOSに標準搭載されている簡易なテキストエディタである `nano` を使って簡単なプログラムを書いてみましょう。

### 作業スペースの作成

ターミナルを開き、以下のコマンドを入力しましょう。

```bash
$ cd                       # ホームディレクトリに移動
$ mkdir java-practice      # programming-practiceというディレクトリを作成する
$ cd java-practice         # oop1に移動する
```

### 画面に「Hello, World!!」を表示するプログラム

テキストエディタは何でも良いのですが、ファイル名「```HelloWorld.java```」として、ファイルを新規作成しましょう。
本書では、標準搭載されているテキストエディタnanoを使用する方法を書きます。

作業スペースを作成した続きで以下のコマンドを使用します。

```bash
$ nano HelloWorld.java
```

以下のコードを書きます。

### HelloWorld.java

このプログラムは、Javaプログラミングの最初の一歩となる、伝統的な「Hello World」プログラムです。このシンプルなプログラムを通じて、Javaプログラムの基本的な構造と、テキスト出力の方法を学習します。

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!!");
    }
}
```

**このコードで学習できる重要な概念：**

- **クラス定義（`public class HelloWorld`）**：Javaのすべてのプログラムはクラス内に記述されます。クラス名は必ずファイル名と一致させる必要があります。
- **メインメソッド（`public static void main(String[] args)`）**：プログラムの実行開始点となる特別なメソッドです。JVMはこのメソッドからプログラムの実行を開始します。
- **標準出力（`System.out.println`）**：コンソールに文字列を出力し、自動的に改行するメソッドです。これがJavaにおける最も基本的な出力方法です。

コードを書き終えたら、ファイルを保存しておきます。

nanoでの保存は、`[control] + [x]`の後、変更を保存するか聞かれるので`[y]`、ファイル名はそのまま`[return]`でOKです。

### C言語版

C言語でのHello Worldプログラムと比較することで、Javaの特徴をより深く理解できます。以下はC言語での同等のプログラムです：

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

### Java版

同じ機能をJavaで実装すると以下のようになります：

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

### 主な違いと設計思想の比較

この比較から、Java言語の重要な設計原則が見えてきます：

- **クラスベースの設計**：Javaはすべてのコードがクラス内に記述される純粋なオブジェクト指向言語です。これにより、コードの組織化と再利用性が向上します。
- **プラットフォーム独立性**：C言語の`#include <stdio.h>`のようなOS固有のヘッダファイルは不要で、Javaの標準ライブラリ（`System.out`）が抽象化を提供します。
- **メモリ管理の自動化**：C言語の`return 0`による明示的な終了処理は不要で、JVMが自動的にメモリ管理を行います。
- **型安全性の強化**：`main`メソッドのシグネチャが厳密に定義されており、コンパイル時に多くのエラーを検出できます。
- **実行モデルの違い**：C言語は機械語にコンパイルされますが、Javaはバイトコードにコンパイルされ、JVM上での実行により「Write Once, Run Anywhere」を実現します。

このような違いにより、Javaはより安全で保守性の高いプログラムの作成を支援しています。

## 1.7 コンパイルと実行

1. 以下のコマンドで、指定されたJavaファイルをコンパイルする
    - $ `javac HelloWorld.java`
2. コンパイルが成功すると、メッセージは何も表示されません
    - コンパイルに失敗する場合、ソースコードのどこに間違いがあるかがメッセージで表示されます。
    - コンパイル後にいくつかメッセージが表示されて、.classファイルなどが生成されていない、更新されていない場合はJavaファイルのコードを見直して、間違いがないか確認しましょう（エラーメッセージ内に間違っている箇所のヒントが書かれています。それを読みましょう）
3. ワークスペースのディレクトリをFinder等で見ると、「HelloWorld.class」と言ったクラスファイルが生成されている
    - .classファイルが、コンパイルされたJavaの実行ファイルです。
4. 以下のコマンドでプログラムを実行する
    - $ `java HelloWorld`

正しく実行できた場合、ターミナル上には、以下のような出力がされます。

```bash
Hello, World!!
```

ターミナルを使用したJavaプログラムのコンパイルと実行は、統合開発環境を使用する開発に入る前まで、以上の手順を用います。

### 覚えておこう！ コンパイルと実行

IDEを使用し始めると、コンパイルしてから実行という作業が、単に実行だけになります（IDEがコードを書いている裏で自動的にコンパイルしてくれている）

```bash
$ javac Javaファイル名
$ java 実行するクラス名
```

## 1.8 基本的な入出力

Javaプログラムでのプログラムへのデータの受け渡し方法は、さまざまな方法があります。
今回は、プログラムの実行後、キーボードからの入力を待ち受け、Enterキー押下で後続の処理が行われる方法を学びます。

### 標準入力

ユーザーとのインタラクティブなやりとりを実現するため、キーボードからの入力を受け付けるプログラムを作成します。このプログラムは、Java標準ライブラリの`Scanner`クラスを使用して、コンソールからのテキスト入力を処理する方法を学習できます。

ファイル名「```StandardInput.java```」

```java
import java.util.Scanner;  // このライブラリをStandardInputクラスで使う宣言

public class StandardInput {
    public static void main(String[] args) {
        // 標準入力をScannerで取得する
        Scanner in = new Scanner(System.in);
        // nextLine()メソッドは、キーボードからReturnキーの入力があるまで待ち、入力された1行を返す
        String inputLine = in.nextLine();
        // ↑inputLineという変数には、入力された文字列データが設定されています

        // 入力された文字列データをそのまま出力
        System.out.println(inputLine);
    }
}
```

**このコードで学習できる重要な概念：**

- **パッケージのインポート（`import java.util.Scanner`）**：Java標準ライブラリから必要なクラスを使用可能にします。これにより、ほかの開発者が作成した便利な機能を再利用できます。
- **Scannerクラスの活用**：`System.in`（標準入力ストリーム）をラップして、さまざまな形式でのデータ入力を可能にします。C言語の`scanf`に相当しますが、より安全で使いやすい設計です。
- **ブロッキング処理**：`nextLine()`メソッドはユーザーの入力を待機し、Enterキーが押されるまでプログラムの実行が一時停止します。このしくみにより、ユーザーのペースに合わせたプログラム実行が可能になります。
- **文字列の取得と表示**：入力された文字列を変数に格納し、あとで利用する基本的なパターンを学習できます。

### 標準入力から受けた文字列から数値変換を行う

実用的なプログラムでは、ユーザーから数値を入力してもらい、計算処理を行うことが頻繁にあります。しかし、コンソールからの入力はすべて文字列として扱われるため、数値として使用するには型変換が必要です。このプログラムでは、文字列から整数への変換と基本的な算術演算を学習します。

ファイル名「```ParseInt.java```」

```java
import java.util.Scanner;  // このライブラリをParseIntクラスで使う宣言

public class ParseInt {
    public static void main(String[] args) {
        // 標準入力をScannerで取得する
        Scanner in = new Scanner(System.in);
        // nextLine()メソッドは、キーボードからReturnキーの入力があるまで待ち、入力された1行を返す
        String inputLine = in.nextLine();
        // ↑inputLineという変数には、入力された文字列データが格納されます

        // 変数numに文字列データを整数値に変換して格納
        int num = Integer.parseInt(inputLine);
        // 整数変換された文字列データに10を足した結果を変数ansに格納
        int ans = num + 10;

        // 変数ansを出力
        System.out.println(ans);
    }
}
```

**このコードで学習できる重要な概念：**

- **型変換の必要性**：Javaは強い型付け言語のため、文字列と数値は明確に区別されます。計算を行うには適切な型への変換が必須です。
- **Integer.parseInt()メソッド**：文字列を整数に変換するJava標準の方法です。このメソッドは文字列の内容を解析し、有効な整数表現の場合にのみ変換を行います。
- **算術演算**：整数に変換された値は、通常の数値として四則演算が可能になります。C言語と同様の演算子が使用できます。
- **変数の型宣言**：`String inputLine`、`int num`、`int ans`のように、Javaでは変数の型を明示的に宣言する必要があります。これにより、コンパイル時に型の不整合を検出できます。

#### 入力文字列が整数値に変換できない場合

Javaの型安全性の特徴を理解するため、意図的に無効な入力を試してみましょう。試しに`aa`という文字列を入力してみます。

**実行時例外（Runtime Exception）の発生：**
```
Exception in thread "main" java.lang.NumberFormatException: For input string: "aa"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ParseInt.main(ParseInt.java:14)
```

この結果は、Javaの重要な特徴である「型安全性」と「例外処理システム」を示しています。現時点ではこのエラーが発生することが正常な動作です。

**例外処理システムが示すJavaの設計思想：**

このプログラムは整数値に変換可能な文字列の入力を前提として設計されています。「整数値に変換できない文字列が入力されることは想定外」であるため、エラーが出力される動作が正常です。

この`NumberFormatException`例外は、以下の重要な概念を示しています：

- **型安全性の実装**：C言語では不正な型変換によってプログラムクラッシュを引き起こす可能性がありますが、Javaでは例外として制御可能な形でエラーを報告します。
- **早期エラー検出**：問題のあるデータを使用して計算が進行する前に、データの妥当性を検証し、適切な時点でエラーを発生させます。
- **デバッグ支援**：スタックトレースにより、エラーが発生した正確な場所とその経路が明確に示されます。

このようなエラーを回避するには、入力値の事前検証や例外処理（try-catch文）などの制御が必要になります。これらの高度な技術については、後の章で詳しく解説します。現時点では、Javaが提供する安全性機能の1つとして理解しておきましょう。

もう少し詳しく解説をすると、`Integer.parseInt("")`という処理は、引数で渡された文字を符号付き10進数の整数型として構文解析します。
この時、内部的には`Integer.parseInt("", 10)`の処理内容と同じことをしています。  
Oracleの公式ドキュメントによると、以下の条件で`java.lang.NumberFormatException`という例外が発生します。と解説がされています。

- 1番目の引数がnullであるか、長さゼロの文字列。
- radixがCharacter.MIN_RADIXよりも小さいか、Character.MAX_RADIXよりも大きい。
- 文字列の中に、指定された基数による桁には使えない文字がある。ただし、文字列の長さが1よりも大きい場合は、1番目の文字がマイナス記号'-'（'\u002D'）またはプラス記号'+' ('\u002B')であってもかまわない。
- 文字列によって表される値が、int型の値ではない。

参考： [Integer (Java SE 21 & JDK 21)](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/lang/Integer.html#parseInt(java.lang.String,int))

### 画面に文字列を出力する方法

Javaでは、画面に文字列を出力する方法として、いくつかの方法があります。出力方法の選択は、プログラムの要求に応じて使い分けることが重要です。

#### 1.`System.out.println`

**事前説明：**
`System.out.println`は、Javaにおける最も基本的で頻繁に使用される出力メソッドです。デバッグ情報の表示、ユーザーへのメッセージ表示、プログラムの実行結果出力など、さまざまな場面で活用されます。自動改行機能により、整理された見やすい出力を簡単に実現できます。

この出力方法は、指定された文字列（String型の変数や式でもOK）を改行コードを末尾につけて出力する方法です。

```java
System.out.println("Hello, World!!");
```

これをC言語でたとえるなら、以下のようになるはずです。

```c
printf("%s\n" , "Hello, World!!");
```

`\n`が自動的に追加されるイメージで良いでしょう。

**学習できる重要な概念：**
- **静的メソッド呼び出し**：`System.out.println`は静的メソッドであり、オブジェクトの生成なしに直接呼び出せます。
- **自動改行機能**：C言語の`printf`と異なり、明示的な改行文字の指定が不要です。
- **型の柔軟性**：文字列以外にも数値、真偽値などさまざまな型のデータを自動的に文字列に変換して出力できます。

#### 2. `System.out.print`

**事前説明：**
改行を含まない出力が必要な場合に使用します。複数の値を同一行に連続して出力したい場合や、入力プロンプトの表示など、改行が不要な場面で重要な役割を果たします。

これは、`System.out.println`で改行コードを末尾に追加しないバージョンです。

**学習できる重要な概念：**
- **出力制御の精密性**：改行の有無を明示的にコントロールできることで、より柔軟な出力フォーマットが実現できます。
- **ユーザーインターフェイス設計**：プロンプトメッセージなど、ユーザーとのインタラクションを意識した出力に不可欠です。

#### 3. `System.out.printf`

**事前説明：**
C言語の`printf`関数に慣れ親しんだ開発者や、複雑なフォーマット指定が必要な場合に有効です。数値の桁数制御、小数点以下の桁数指定、文字列の幅指定など、高度な出力フォーマット制御が可能になります。

C言語ライクに書きたい場合は、printfを使用してください。
C言語のprintfと同じような書き方で出力が可能です。

**学習できる重要な概念：**
- **フォーマット文字列の活用**：`%d`、`%f`、`%s`などの書式指定子により、データの表示形式を細かく制御できます。
- **言語間の互換性**：C言語の知識を活用しつつ、Javaの型安全性の恩恵を受けられます。
- **プロフェッショナルな出力**：レポート生成や数値データの整理された表示に適しています。

##### サンプルソース

**事前説明：**
このプログラムは、Javaの3つの主要な出力メソッドの違いと特徴を実践的に学習するためのサンプルです。各メソッドの出力結果を比較することで、適切な使い分けの判断基準を身につけることができます。

ファイル名「`StandardOutput.java`」

```java
public class StandardOutput {
    public static void main(String[] args) {
        System.out.println("標準出力は、「System.out.printlnメソッド」を使用します。");
        System.out.println("「System.out.println」は末尾に改行コードも併せて出力します。");
        System.out.println(); // 引数なしで改行のみ出力されます。
        System.out.print("「System.out.print」を使うと、末尾に改行は出力されません。");
        System.out.print("改行は\\nで出力できます。\n");
        System.out.print("\n");
        String message = "C言語のprintf関数のように出力したい場合は、「System.out.printf」を使います。";
        System.out.printf("%s\n", message);
        System.out.printf("整数値: %d, 実数値: %f\n", 10, 3.142592654d);
    }
}
```

**このコードで学習できる重要な概念：**

- **出力メソッドの使い分け**：各メソッドの特性を理解し、目的に応じた適切な選択ができます。
- **文字列リテラル内でのエスケープ処理**：`\\n`のように、特殊文字を文字列内で表現する方法を学習できます。
- **変数を利用した出力**：`String message`変数を使用することで、データの再利用と可読性の向上を実現しています。
- **書式指定子の活用**：`%s`（文字列）、`%d`（整数）、`%f`（浮動小数点数）の基本的な使用方法を学習できます。
- **型安全性の恩恵**：Javaの型システムにより、書式指定子と実際のデータ型の不整合をコンパイル時に検出できます。

**C言語との比較ポイント：**
- C言語では`printf`のみですべての出力を行いますが、Javaでは用途に応じて3つのメソッドを使い分けることで、より明確で保守しやすいコードが書けます。
- Javaの`printf`は、C言語の知識を活用しつつ、より安全な型チェック機能を提供します。


## 1.9 データ型

**事前説明：**
Javaのデータ型システムは、プログラムの安全性と保守性を大幅に向上させる重要な特徴です。C言語と比較しながら学習することで、Javaの型安全性がもたらす利点と、オブジェクト指向言語としての特性を理解できます。

### 基本データ型の比較

| C言語 | Java | 説明 |
|-------|------|------|
| int | int | 32ビット整数 |
| long | long | 64ビット整数 |
| float | float | 32ビット浮動小数点数 |
| double | double | 64ビット浮動小数点数 |
| char | char | 16ビットUnicode文字 |
| - | boolean | 真偽値（true/false） |

**学習できる重要な概念：**

- **プラットフォーム独立性**：Javaの基本データ型は、実行環境に関係なく常に同じサイズを持ちます。これにより「Write Once, Run Anywhere」が実現されます。
- **Unicode対応**：`char`型が16ビットのUnicode文字を扱えるため、国際化対応のプログラムが容易に作成できます。
- **真偽値型の存在**：C言語では整数で真偽を表現しますが、Javaでは`boolean`型により明確な真偽値表現が可能です。
- **型安全性の強化**：各データ型の役割が明確に分離されており、不正な型変換をコンパイル時に検出できます。

### 文字列の扱い

**事前説明：**
文字列処理は、現代のプログラミングにおいて極めて重要な要素です。Javaの`String`クラスは、C言語の文字配列よりもはるかに強力で安全な文字列処理機能を提供します。

```java
// C言語風（推奨されない）
char[] chars = {'H', 'e', 'l', 'l', 'o'};

// Java推奨
String message = "Hello, World!";
String name = "Java";
String greeting = message + " " + name;  // 文字列連結
```

**このコードで学習できる重要な概念：**

- **オブジェクトとしての文字列**：Javaでは文字列は`String`オブジェクトとして扱われ、豊富なメソッドが利用できます。
- **文字列連結の簡潔性**：`+`演算子による直感的な文字列連結が可能で、C言語の`strcat`関数よりもはるかに簡単です。
- **メモリ管理の自動化**：文字列の作成、変更、削除はJVMが自動的に管理するため、メモリリークの心配がありません。
- **不変性（Immutability）**：Javaの`String`オブジェクトは不変であり、文字列操作によって新しいオブジェクトが作成されます。これによりマルチスレッド環境での安全性が保証されます。
- **文字列プール**：同じ内容の文字列リテラルは、JVMの文字列プールで効率的に管理されます。

## 1.10 変数と定数

**事前説明：**
変数と定数の適切な使い分けは、保守しやすく理解しやすいプログラムを作成するための基本です。Javaの変数宣言システムは、型安全性を提供し、プログラムの実行時エラーを大幅に削減します。また、`final`修飾子による定数の定義は、プログラムの意図を明確に表現し、予期しない値の変更を防ぎます。

```java
// 変数宣言
int number = 10;
double price = 99.99;
boolean isActive = true;

// 定数（final修飾子）
final int MAX_VALUE = 100;
final String COMPANY_NAME = "TechBook";
```

**このコードで学習できる重要な概念：**

- **明示的な型宣言**：各変数の型を明確に宣言することで、コンパイル時の型チェックが可能になり、実行時エラーを防げます。
- **適切な命名規則**：変数名は`camelCase`、定数名は`UPPER_SNAKE_CASE`というJavaの標準的な命名規則を学習できます。
- **final修飾子の意味**：`final`キーワードにより値の変更を禁止し、プログラムの意図を明確に表現できます。
- **データ型の選択基準**：整数には`int`、浮動小数点数には`double`、真偽値には`boolean`という適切な型選択の重要性を理解できます。
- **初期化の重要性**：変数宣言と同時に適切な初期値を設定することで、未初期化変数によるバグを防げます。

**C言語との比較ポイント：**
- C言語の`const`キーワードに対応するのがJavaの`final`修飾子です。
- Javaでは変数の型宣言が必須であり、C言語のような暗黙的な型変換は制限されています。
- 真偽値を専用の`boolean`型で扱うことで、C言語の`0`/`非0`による真偽表現よりも明確になります。

## 1.11 演算子

**事前説明：**
Javaの演算子システムは、C言語の優れた設計を継承しつつ、オブジェクト指向と型安全性の観点から改良が加えられています。特に文字列連結における`+`演算子のオーバーロードは、Javaの利便性を大幅に向上させる重要な機能です。また、論理演算子の短絡評価（ショートサーキット評価）などの高度な概念も含まれています。

Javaの演算子はC言語とほぼ同じですが、いくつかの違いがあります：

```java
// 算術演算子（C言語と同じ）
int a = 10, b = 3;
int sum = a + b;        // 13
int diff = a - b;       // 7
int product = a * b;    // 30
int quotient = a / b;   // 3
int remainder = a % b;  // 1

// 文字列連結（Javaの特徴）
String result = "合計: " + sum;

// 比較演算子
boolean isEqual = (a == b);     // false
boolean isNotEqual = (a != b);  // true

// 論理演算子
boolean result1 = (a > 5) && (b < 10);  // true
boolean result2 = (a < 5) || (b > 10);  // false
```

**このコードで学習できる重要な概念：**

- **演算子の優先順位**：C言語と同じ優先順位ルールにより、複雑な式も予測可能な順序で評価されます。
- **文字列連結の自動型変換**：`"合計: " + sum`のように、数値が自動的に文字列に変換される便利機能を学習できます。
- **短絡評価（Short-circuit evaluation）**：`&&`や`||`演算子では、左辺の結果によって右辺の評価が省略される効率的な評価方法を理解できます。
- **型安全な比較**：比較演算子の結果は必ず`boolean`型となり、C言語のような整数との混同を避けられます。
- **整数除算の特性**：`10 / 3 = 3`のように、整数どうしの除算では小数点以下が切り捨てられることを理解できます。

**Javaの演算子の特別な機能：**

- **文字列連結演算子**：`+`演算子が文字列に対して使用された場合、連結処理が自動的に実行されます。
- **instanceof演算子**：オブジェクトの型を実行時に確認する、オブジェクト指向言語ならではの演算子です。
- **三項演算子**：`条件 ? 真の場合 : 偽の場合`という簡潔な条件分岐が可能です。

**C言語との重要な違い：**
- ポインタ演算子（`*`、`&`）は存在しません。Javaではオブジェクト参照により安全なメモリアクセスを実現しています。
- `sizeof`演算子はありません。配列のサイズは`.length`プロパティで取得します。

## 1.12 制御構造

**事前説明：**
制御構造は、プログラムの流れ（フロー）を制御する基本的なしくみです。条件分岐と繰り返し処理により、プログラムに複雑な判断力と処理能力を与えることができます。Javaの制御構造は、C言語の優れた設計を継承しつつ、より安全で表現力豊かな機能を提供しています。

### 条件分岐

**事前説明：**
条件分岐は、プログラムが状況に応じて異なる処理を選択するしくみです。成績判定、ユーザー入力の検証、システム状態の確認など、実用的なプログラムには不可欠な機能です。

```java
// if文（C言語と同じ）
int score = 85;
if (score >= 90) {
    System.out.println("優");
} else if (score >= 80) {
    System.out.println("良");
} else if (score >= 70) {
    System.out.println("可");
} else {
    System.out.println("不可");
}

// switch文（Java 12以降の新記法も利用可能）
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**このコードで学習できる重要な概念：**

- **多段階条件分岐**：`else if`の連鎖により、複数の条件を順次評価できます。これは成績判定のような段階的評価に最適です。
- **論理的な条件設計**：条件を`score >= 90`から順番に書くことで、重複しない明確な判定ロジックを実現しています。
- **switch式の活用**：Java 12以降の新しいswitch式では、より簡潔で関数型プログラミングに近い記述が可能です。
- **複数ケースの同時処理**：`case 10, 9 ->`のように、複数の値に対して同じ処理を適用できます。
- **型安全な分岐**：条件式は必ず`boolean`型である必要があり、C言語のような整数による条件分岐は許可されません。

**新旧switch文の比較による学習ポイント：**

従来のswitch文：
```java
String grade;
switch (score / 10) {
    case 10:
    case 9:
        grade = "優";
        break;
    case 8:
        grade = "良";
        break;
    case 7:
        grade = "可";
        break;
    default:
        grade = "不可";
        break;
}
```

新しいswitch式：
```java
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**学習できる進化のポイント：**
- **fall-through問題の解決**：新しいswitch式では`break`文が不要で、意図しないfall-throughバグを防げます。
- **式としての利用**：switch文が値を返すことができるようになり、変数への代入が直接可能です。
- **簡潔な記述**：`->`記法により、コードがより読みやすく保守しやすくなります。

### 繰り返し処理

**事前説明：**
繰り返し処理（ループ）は、同じ処理を効率的に何度も実行するためのしくみです。配列の全要素を処理する、計算を指定回数繰り返す、条件が満たされるまで処理を続けるなど、プログラミングの基本的なパターンを実現します。Javaでは、用途に応じて3つの主要なループ構文を提供しています。

```java
// for文
for (int i = 0; i < 10; i++) {
    System.out.println("i = " + i);
}

// 拡張for文（foreach）
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// while文
int count = 0;
while (count < 5) {
    System.out.println("count = " + count);
    count++;
}
```

**このコードで学習できる重要な概念：**

- **for文の3つの要素**：初期化(`int i = 0`）、条件（`i < 10`）、更新（`i++`)の明確な分離により、ループの動作が理解しや少なっています。
- **拡張for文の利便性**：配列やコレクションの全要素を処理する際に、インデックス管理が不要で安全です。Java 5で導入されたこの機能により、配列操作のバグが大幅に減少しました。
- **while文の柔軟性**：条件が複雑な場合や、ループ回数が事前に決まらない場合に適しています。
- **ループ変数のスコープ**：for文内で宣言された変数`i`は、ループ内でのみ有効です。これにより名前空間の汚染を防げます。
- **配列との連携**：拡張for文では、配列の要素に直接アクセスでき、境界値エラー（IndexOutOfBoundsException）を防げます。

**各ループの使い分けの指針：**

- **for文**：繰り返し回数が明確で、カウンタ変数が必要な場合
- **拡張for文**：配列やコレクションの全要素を順次処理する場合
- **while文**：複雑な条件や、繰り返し回数が動的に決まる場合

**C言語との比較における重要なポイント：**
- 拡張for文はC言語にはない、Javaの重要な改良点です。
- ループ変数のスコープがより厳密に管理されています。
- 配列アクセスの安全性が大幅に向上しています。

## 1.13 配列

**事前説明：**
配列は、同じ型の複数のデータを効率的に管理するための基本的なデータ構造です。学生の成績管理、商品の在庫管理、数値計算など、プログラミングの多くの場面で配列が活用されます。Javaの配列は、C言語の配列の利便性を継承しつつ、境界チェックや自動初期化により安全性を大幅に向上させています。

```java
// 配列の宣言と初期化
int[] numbers = {1, 2, 3, 4, 5};

// または
int[] scores = new int[10];  // 10要素の配列
scores[0] = 100;
scores[1] = 95;

// 配列の長さ
System.out.println("配列の長さ: " + numbers.length);

// 多次元配列
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

**このコードで学習できる重要な概念：**

- **配列初期化の2つの方法**：リテラル初期化(`{1, 2, 3, 4, 5}`)と`new`キーワードによる動的作成の使い分けを理解できます。
- **オブジェクトとしての配列**：Javaの配列はオブジェクトであり、`length`プロパティなどの便利な機能を持っています。
- **境界チェックの自動実行**：配列の範囲外アクセスは`ArrayIndexOutOfBoundsException`として検出され、セグメンテナンスーション違反のような深刻な問題を防げます。
- **自動初期化**：`new int[10]`で作成された配列の要素は自動的に0で初期化されます。これによりガベージ値による予期しない動作を防げます。
- **多次元配列の構造**：2次元配列は「配列の配列」として実装され、行列やテーブル形式のデータを直感的に表現できます。

**配列操作の実用例：**

```java
// 配列の全要素を処理する安全な方法
int[] data = {10, 20, 30, 40, 50};

// インデックスを使用した従来の方法
for (int i = 0; i < data.length; i++) {
    System.out.println("data[" + i + "] = " + data[i]);
}

// 拡張for文を使用した推奨方法
for (int value : data) {
    System.out.println("値: " + value);
}
```

**C言語との重要な違い：**

- **lengthプロパティ**：C言語では配列のサイズを別途管理する必要がありますが、Javaでは`array.length`で常に正確なサイズを取得できます。
- **境界チェック**：C言語では配列の範囲外アクセスがシステムクラッシュを引き起こす可能性がありますが、Javaでは例外として安全に処理されます。
- **メモリ管理**：配列のメモリ確保と解放はJVMが自動的に行うため、メモリリークやダングリングポインタの心配がありません。
- **初期化の保証**：Java配列の要素は必ず適切なデフォルト値で初期化されます（数値型は0、真偽値型はfalse、オブジェクト型はnull）。

## 1.14 メソッド（関数）

**事前説明：**
メソッド（関数）は、特定の処理をまとめて名前を付け、必要な時に呼び出して使用するしくみです。コードの再利用性を高め、プログラムの構造を整理し、保守性を向上させる重要な概念です。Javaのメソッドは、C言語の関数の概念を発展させ、オブジェクト指向プログラミングの基礎となる機能を提供しています。

```java
public class Calculator {
    // メソッドの定義
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double divide(double a, double b) {
        if (b == 0) {
            System.out.println("ゼロ除算エラー");
            return 0;
        }
        return a / b;
    }
    
    public static void main(String[] args) {
        int result = add(10, 5);
        System.out.println("結果: " + result);
        
        double divResult = divide(10.0, 3.0);
        System.out.println("除算結果: " + divResult);
    }
}
```

**このコードで学習できる重要な概念：**

- **メソッドシグネチャの構成**：`public static int add(int a, int b)`の各要素（アクセス修飾子、static修飾子、戻り値の型、メソッド名、パラメータ）の意味と役割を理解できます。
- **型安全なパラメータ渡し**：引数の型が明確に定義されており、コンパイル時に型の不整合を検出できます。
- **戻り値の型宣言**：メソッドが返す値の型を明示することで、呼び出し側で適切な変数で結果を受け取れます。
- **エラーハンドリングの実装**：ゼロ除算チェックにより、実行時エラーを防ぐ防御的プログラミングの手法を学習できます。
- **静的メソッドの特徴**：`static`修飾子により、オブジェクトの生成なしにメソッドを呼び出せる便利性を理解できます。

**メソッド設計の重要な原則：**

- **単一責任の原則**：`add`メソッドは加算のみ、`divide`メソッドは除算のみを担当し、1つのメソッドが1つの明確な役割を持っています。
- **再利用性の実現**：一度定義したメソッドは、プログラム内の任意の場所から何度でも呼びだすことができます。
- **デバッグの容易性**：問題が発生した場合、特定のメソッド内に原因を特定しやすくなります。
- **可読性の向上**：メソッド名により処理内容が明確になり、プログラムの意図が理解しやすくなります。

**高度なメソッド活用例：**

```java
// メソッドオーバーロードの例
public static int add(int a, int b) {
    return a + b;
}

public static double add(double a, double b) {
    return a + b;
}

public static int add(int a, int b, int c) {
    return a + b + c;
}
```

**C言語との比較における学習ポイント：**

- **クラス内での定義**：Javaのメソッドは必ずクラス内に定義される必要があり、グローバル関数は存在しません。
- **アクセス制御**：`public`、`private`などの修飾子により、メソッドの可視性を細かく制御できます。
- **オーバーロード機能**：同じ名前で異なるパラメータを持つメソッドを複数定義でき、利便性が向上します。
- **例外処理システム**：エラー処理がより構造化され、安全なプログラムの作成を支援します。

**Java基本文法の総合的な理解：プログラミングパラダイムの変革**

本章で学習した各要素は、独立したテクニックではなく、現代のソフトウェア開発における包括的な設計哲学の一部です。出力メソッドから始まり、データ型、変数、演算子、制御構造、配列、メソッドまで、すべてがJavaの「安全性」「保守性」「可読性」という3つの核心原則にもとづいて設計されています。

**学習した内容の相互関係と実践への応用：**

- **型安全性の一貫した実装**：`System.out.println`による自動型変換、明示的な変数宣言、メソッドのシグネチャ、配列の境界チェックなど、すべての機能が型の整合性を保証しています。
- **オブジェクト指向への基盤構築**：staticメソッド、クラス内でのメソッド定義、String型の活用など、本章で学んだ要素はすべて次章以降のオブジェクト指向学習への準備となっています。
- **C言語からの進化の理解**：単なる機能追加ではなく、ソフトウェア開発の課題（メモリ管理、プラットフォーム依存性、保守性）を根本的に解決するための設計思想の変革を体験できました。

**現代的なプログラミング手法への接続：**

今回学習した基本文法は、フレームワーク開発、Webアプリケーション構築、マイクロサービスアーキテクチャ、クラウドネイティブ開発など、現代のあらゆるJava開発の基盤となります。型安全性、例外処理、適切なメソッド設計などの概念は、企業での実際の開発において直接活用される重要なスキルです。

## 🏋️ 実践演習課題

本章で学習した内容を定着させるため、段階的な演習課題に取り組みましょう。各課題は、実用的な場面を想定して設計されています。

### 基礎演習 1-1：データ型と変数
**目標**：Java基本データ型の理解と活用

**課題内容**：
学生情報管理の基礎プログラムを作成してください。
- 学生ID（整数）
- 学生名（文字列）
- 身長（小数点）
- 在学中フラグ（真偽値）

**実装要件**：
- 各データ型の変数を適切に宣言・初期化する
- 標準入力から値を受け取り、変数に格納する
- すべての情報を整理して出力する

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切なデータ型の選択 |
| 変数の命名規則の遵守 |
| 入力・出力処理の正確な実装 |

### 応用演習 1-2：制御構造の活用
**目標**：条件分岐と繰り返し処理の実践

**課題内容**：
学生の成績判定プログラムを作成してください。
- 5科目の点数を入力として受け取る
- 各科目の合格/不合格を判定（60点以上で合格）
- 平均点を計算する
- 総合判定（全科目合格で卒業認定）を出力する

**実装要件**：
- 繰り返し処理で5科目の点数を効率的に入力
- 条件分岐で合格判定を実装
- 論理演算子を使用して総合判定を実装

**評価ポイント**：

| 評価項��� |
| :--- |
| 適切な条件分岐の使用 |
| 繰り返し処理による効率的な実装 |
| 論理演算子の適切な使用 |

### 実践演習 1-3：配列を使った数値処理
**目標**：配列とアルゴリズムの基本的な組み合わせ

**課題内容**：
数値データ分析プログラムを作成してください。
- 10個の数値を配列に格納
- 最大値、最小値、平均値を計算
- 数値を昇順にソート
- 特定の値の検索機能

**実装要件**：
- 配列の適切な初期化と操作
- ソートアルゴリズムの実装（バブルソートなど）
- 線形検索アルゴリズムの実装

**評価ポイント**：

| 評価項目 |
| :--- |
| 配列操作の正確な実装 |
| アルゴリズムの論理的な構成 |
| エラー処理の考慮 |

**拡張課題**：
- ユーザーが配列サイズを指定できるようにする
- 統計情報（中央値、標準偏差）の計算を追加

### 発展演習 1-4：総合プログラム
**目標**：第1章の全要素を統合した実用的なプログラム

**課題内容**：
簡易家計簿プログラムを作成してください。
- 支出項目と金額の入力
- カテゴリ別集計（食費、交通費、娯楽費など）
- 月間予算との比較
- 支出レポートの表示

**実装要件**：
- 複数のメソッドに機能を分割
- 配列または多次元配列でデータ管理
- メニュー形式のユーザーインターフェイス
- 基本的な入力検証

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切なメソッド設計 |
| データ構造の効率的な活用 |
| ユーザビリティの考慮 |
| コードの可読性と保守性 |

### セルフチェック課題

各演習完了後、以下の項目で自己評価を行ってください：

**技能確認チェック**

| チェック項目 |
| :--- |
| エラーなしでコンパイル・実行できる |
| 意図した動作が正確に実行される |
| C言語との違いを説明できる |
| コードに適切なコメントが記述されている |

**理解度確認チェック**

| チェック項目 |
| :--- |
| 使用したJava文法要素の役割を説明できる |
| 他の問題に応用できる自信がある |
| より良い実装方法を考えることができる |

### 🎯 発展的な学習課題

さらなるスキル向上を目指す方は、以下の課題にも挑戦してみてください：

1. **アルゴリズム実装課題**：
   - クイックソート、マージソートの実装
   - 二分探索アルゴリズムの実装
   - 数学的計算（階乗、フィボナッチ数列）

2. **文字列処理課題**：
   - 文字列の逆順変換
   - 単語カウント機能
   - 簡単な暗号化・復号

3. **データ構造課題**：
   - 2次元配列を使った表計算
   - ゲーム盤（オセロ、三目並べ）の実装
   - 簡単な画像処理（ASCIIアート）

## クラスとオブジェクトの基本

章末の練習課題に取り組む前に、Javaプログラミングの核心であるクラスとオブジェクトの基本的な概念と構文を理解しておきましょう。

### クラスの基本構造

Javaでは、すべてのコードは**クラス**という単位で記述します。クラスは「設計図」であり、オブジェクトはその設計図から作られる「実体」です。

#### 基本的なクラスの定義

```java
public class Person {
    // フィールド（インスタンス変数）
    private String name;
    private int age;
    
    // コンストラクタ
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // メソッド（振る舞い）
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void introduce() {
        System.out.println("こんにちは、" + name + "です。" + age + "歳です。");
    }
}
```

### クラスの構成要素

#### 1. フィールド（インスタンス変数）

オブジェクトが持つデータを格納する変数です：

```java
private String name;    // 文字列を格納
private int age;        // 整数を格納
private double height;  // 小数を格納
```

**重要なポイント**：
- `private`を使ってカプセル化（外部からの直接アクセスを防ぐ）
- 各オブジェクトが独自の値を持つ

#### 2. コンストラクタ

オブジェクトを作成する際に呼び出される特別なメソッドです：

```java
public Person(String name, int age) {
    this.name = name;  // パラメータの値をフィールドに設定
    this.age = age;
}
```

**重要なポイント**：
- クラス名と同じ名前
- 戻り値の型を書かない
- `this`キーワードでフィールドを明示的に指定

#### 3. メソッド

オブジェクトの振る舞いを定義します：

```java
// 値を返すメソッド
public String getName() {
    return name;
}

// 処理を実行するメソッド
public void introduce() {
    System.out.println("こんにちは、" + name + "です。");
}
```

### オブジェクトの作成と使用

#### オブジェクトの作成

```java
public class Main {
    public static void main(String[] args) {
        // newキーワードでオブジェクトを作成
        Person person1 = new Person("田中太郎", 25);
        Person person2 = new Person("佐藤花子", 30);
        
        // メソッドを呼び出す
        person1.introduce();  // "こんにちは、田中太郎です。25歳です。"
        person2.introduce();  // "こんにちは、佐藤花子です。30歳です。"
        
        // getterメソッドで値を取得
        String name = person1.getName();
        int age = person1.getAge();
        System.out.println(name + "は" + age + "歳です。");
    }
}
```

### オブジェクト指向の基本概念

#### カプセル化

データ（フィールド）を`private`にして、`public`メソッドを通じてのみアクセスできるようにする：

```java
public class BankAccount {
    private int balance;  // 残高は外部から直接変更できない
    
    public void deposit(int amount) {
        if (amount > 0) {
            balance += amount;  // 正の値のみ受け付ける
        }
    }
    
    public int getBalance() {
        return balance;
    }
}
```

#### オブジェクト同士の連携

```java
public class Library {
    private String name;
    
    public void lendBook(Person person, String bookTitle) {
        System.out.println(person.getName() + "さんに「" + 
                         bookTitle + "」を貸し出しました。");
    }
}
```

### よく使用されるパターン

#### toString()メソッド

オブジェクトの文字列表現を定義：

```java
public class Person {
    // ... 他のコード ...
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}
```

#### equals()とhashCode()

オブジェクトの同値性を定義：

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Person person = (Person) obj;
    return age == person.age && Objects.equals(name, person.name);
}

@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

### 練習課題で使用する重要な概念

1. **オブジェクトの状態管理**：フィールドを使ってオブジェクトの状態を保持
2. **メソッドによる操作**：状態を変更したり、計算を行ったりするメソッド
3. **オブジェクト間の関係**：異なるオブジェクト同士が連携する設計
4. **データの妥当性**：setterメソッドでの入力値検証

---

これらの基本概念を理解することで、章末の練習課題により効果的に取り組むことができます。

## まとめ

本章では、C言語との比較を通じてJavaの基本文法を学習しました。重要なのは、単に文法を暗記することではなく、Javaが提供する「安全性」「保守性」「可読性」という設計思想を理解することです。

**次章への準備：**
- 基本文法の習得により、Java言語の基礎的な表現力を身につけました
- 型安全性、例外処理、メソッド設計などの概念により、品質の高いコードを書くための基盤を構築しました  
- クラスとメソッドの概念に触れることで、オブジェクト指向プログラミングへの準備が整いました

次章では、Javaの最大の特徴であるオブジェクト指向プログラミングについて学習します。本章で学んだ基本文法の知識をベースに、より高度で実用的なプログラミング技法を習得していきましょう。