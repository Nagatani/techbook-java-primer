# 第2章 Java基本文法

## 本章の学習目標

### 前提知識
**必須前提**：
- 第1章のJava開発環境構築完了
- Hello Worldプログラムの作成・実行経験
- C言語での基本的なプログラミング経験（変数、条件分岐、ループ）

**望ましい前提**：
- テキストエディタまたはIDEの基本操作
- コマンドライン操作の基礎知識

### 学習目標
**知識理解目標**：
- Java言語仕様の基本的な理解
- JVM（Java仮想マシン）の役割としくみ
- プラットフォーム独立性の意味と利点
- Javaのメモリ管理（ガベージコレクション）の基本概念

**技能習得目標**：
- Java基本データ型の適切な使用
- 変数宣言と初期化の正確な記述
- 制御構造（if-else、for、while）のJava記法での実装
- メソッドの定義、呼び出し、戻り値の処理
- 配列の宣言、初期化、操作

**実践的な活用目標**：
- 基本的な数値計算プログラムの作成
- 文字列処理を含む実用的な小プログラムの開発
- エラーメッセージの理解と基本的なデバッグ

**到達レベルの指標**：
- 手続き型スタイルでの基本的なJavaプログラムが独力で作成できる
- C言語とJavaの文法的違いを説明できる
- 基本的なコンパイルエラーを理解し修正できる
- 簡単なアルゴリズム（ソート、検索）をJavaで実装できる

---

## 始めに：Javaという言語の特徴

本章では、プログラミング言語Javaの基本文法を学習します。Javaは1995年にSun Microsystems（現Oracle）によって発表され、現在も世界中で広く使用されている主要なプログラミング言語の1つです。

### Javaの誕生と基本思想

Javaは「Write Once, Run Anywhere（一度書けば、どこでも動く）」という革新的な思想のもとに設計されました。これは、Java仮想マシン（JVM）という実行環境上でプログラムを動作させることで実現されています。C言語のように特定のハードウェアやOSに依存せず、JVMさえあればWindows、macOS、Linuxなど、どの環境でも同じプログラムが動作します。

### Java仮想マシン（JVM）の主要な特徴

JVMは以下の重要な機能を提供します：

- **プラットフォーム独立性**：バイトコードと呼ばれる中間言語に変換することで、OS依存性を排除
- **自動メモリ管理**：ガベージコレクションによりメモリの確保・解放を自動化し、メモリリークを防止
- **セキュリティ**：サンドボックス環境により、悪意のあるコードから保護
- **実行時最適化**：JITコンパイルにより、実行中にプログラムを最適化

### なぜJavaを学ぶのか

Javaは以下の分野で幅広く活用されています：

- **企業システム開発**：銀行、保険、政府機関などの大規模システム
- **Webアプリケーション**：Spring Bootなどのフレームワークを使った開発
- **Androidアプリケーション開発**：モバイルアプリケーションの開発
- **ビッグデータ処理**：Apache Hadoop、Apache Sparkなどの基盤技術

本章では、このような実践的な開発に必要なJavaの基本文法を、C言語との比較を交えながら体系的に学習していきます。

**より詳しい歴史や技術的背景について**：Javaの詳細な歴史、企業システムでの採用事例、オープンソース化の経緯などについては、巻末の「Deep Dive：Javaエコシステムの詳細」を参照してください。

## 2.1 Javaの特徴

Javaは以下のような特徴を持つプログラミング言語です：

- **プラットフォーム独立性**：「Write Once, Run Anywhere」
- **オブジェクト指向**：クラスベースのオブジェクト指向言語
- **ガベージコレクション**：自動メモリ管理
- **強い型付け**：コンパイル時の型チェック
- **豊富なライブラリ**：標準ライブラリとサードパーティライブラリ

## Deep Dive: メモリ管理とガベージコレクション

> **対象読者**: C言語のメモリ管理（malloc/free）を理解している読者向け  
> **前提知識**: ポインタ、ヒープ領域、メモリリークの概念  
> **学習時間**: 約10分

### C言語の手動メモリ管理の課題

C言語では、プログラマがメモリの確保と解放を手動で行う必要があります：

```c
// C言語での手動メモリ管理
char* buffer = malloc(1024);  // メモリ確保
// ... 使用 ...
free(buffer);                 // メモリ解放（忘れやすい！）
```

この手動管理は以下の問題を引き起こします：

1. **メモリリーク**: `free()`を忘れることによる
2. **ダングリングポインタ**: 解放済みメモリへのアクセス
3. **二重解放**: 同じメモリを複数回`free()`する

### Javaの自動メモリ管理

Javaはこれらの問題を**ガベージコレクション（GC）**で解決します：

```java
// Javaでは自動メモリ管理
String message = new String("Hello");  // 自動でメモリ確保
// messageがスコープを出ると自動的にGCの対象になる
// プログラマはメモリ解放を意識する必要なし
```

### ガベージコレクションのしくみ

#### 基本的なアルゴリズム：Mark-Sweep-Compact

GCは以下の手順でメモリを自動管理します：

1. **マーク段階**: ルートオブジェクト（ローカル変数、静的変数など）からたどれるすべてのオブジェクトをマーク
2. **スイープ段階**: マークされていないオブジェクトを削除し、メモリを解放
3. **コンパクト段階**: メモリの断片化を解消し、生きているオブジェクトを連続した領域に移動

#### 世代別ガベージコレクション（Generational GC）

実際のJVMは「世代別仮説」にもとづいた効率的なGCを実装しています：

**仮説**:「ほとんどのオブジェクトは若い段階で死ぬ」

この仮説にもとづき、ヒープを世代別に分割：

```
【JVMヒープ構造】
Young Generation (新世代)
├── Eden Space        ← 新しいオブジェクトが最初に作られる場所
├── Survivor Space 0  ← 1回のGCを生き残ったオブジェクト
└── Survivor Space 1  ← 複数回のGCを生き残ったオブジェクト

Old Generation (旧世代)  ← 長寿命のオブジェクト
```

#### 主要なGCアルゴリズム

**1. Serial GC**
- シングルスレッドで動作
- 小規模アプリケーション向け
- 停止時間： 長い、スループット： 高い

**2. Parallel GC（Java 8のデフォルト）**
- マルチスレッドで並列処理
- サーバアプリケーション向け
- 停止時間： 中程度、スループット： 非常に高い

**3. G1 GC（Java 9以降のデフォルト）**
- 低遅延を重視した設計
- 大容量ヒープ（6GB以上）に最適化
- 停止時間： 短い（10ms以下目標）、スループット： 高い

**4. ZGC / Shenandoah（Java 11以降）**
- 超低遅延コレクタ
- テラバイト級ヒープにも対応
- 停止時間： 極短（1-2ms）、スループット： 中程度

#### Javaでも発生し得るメモリリーク

自動メモリ管理でも、以下のパターンでメモリリークが発生します：

```java
// 悪い例：Staticコレクションへの無制限追加
public class UserCache {
    private static final List<User> cache = new ArrayList<>();
    
    public static void addUser(User user) {
        cache.add(user);  // 永続的に参照を保持 → メモリリーク
    }
}

// 改善例：WeakReferenceの使用
public class UserCache {
    private static final List<WeakReference<User>> cache = new ArrayList<>();
    
    public static void addUser(User user) {
        cache.add(new WeakReference<>(user));  // 弱参照で保持
    }
}
```

### パフォーマンスとのトレードオフ

#### GCの影響

1. **Stop-the-World**: GC実行中は全スレッドが停止（数ミリ秒〜数秒）
2. **CPU使用率**: GCによるオーバーヘッド（通常5-15%）
3. **メモリ使用量**: GC管理用のメタデータが必要

#### 現代JVMの優秀性

しかし、現代のJVMは以下の最適化により、手動管理を上回る性能を実現：

1. **逃避解析（Escape Analysis）**: スタック上に直接オブジェクトを配置
2. **TLAB（Thread Local Allocation Buffer）**: スレッドローカルなメモリ割り当て
3. **適応的サイズ調整**: 実行パターンにもとづく自動チューニング

**ベンチマーク例**：
- C言語（手動管理）: 100% の相対性能
- Java（現代のJVM）: 95-105% の相対性能
- 長時間実行アプリケーションではJavaが勝ることも多い

#### GCチューニングの基本

プロダクション環境では以下のパラメータを調整：

```bash
# G1GCの例
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200    # 最大停止時間の目標
-XX:G1HeapRegionSize=16m    # リージョンサイズ
-Xms4g -Xmx4g              # ヒープサイズの固定
```

### 参考文献・関連資料
- "Java Performance: The Definitive Guide" - Scott Oaks
- Oracle JVMガベージコレクション チュートリアル

## 2.2 開発環境の準備
### JDK(JavaSDK)

プログラミング言語Javaの開発環境をJava Software Development Kitと呼び、JavaSDKやJDKなどと略されます。  
Javaでの開発は、複数あるJDKのどれかをインストールすることから始まります。

Javaでの開発にお勧めのIDEである、IntelliJ IDEAからもJDKをインストールできるようになっています。  
ですが、本書では、本書の内容以外でもJDKを使った開発ができるように、一括でバージョン管理が可能なソフトウェアを使用して必要なバージョンのJDKをインストールします。

### JDKの種類

JDKに挟まざまな提供元があり、インストールするJDKの種類が異なることによって講義を円滑に進められない場合もあります。
そのため、本書で使用するJDKはこの内容で指定しているものを必ずインストールするようにしてください。

#### JDKの種類が混乱するほど増えている理由

JDKと一言で言っても、開発元であるOracle以外にもいくつかの企業や団体がJDKとしてリリースしているものがあり、その配布元ごとにさまざまなバージョンのものがあります。

まず、JavaはOSSです。  
（単純にソフトウェアとしての側面のほかに、エコシステムとしての側面もあります）

Javaの商標は、開発元であるOracleが保持しています。ですので、本来はJava™のような書き方をするのが正しいのかもしれません。

JDKの種類が多い理由として、OSSである点が第一に挙げられます。商標自体はOracleが保持していますが、JDK自体のソースコードの取得は開かれているので、それをビルドしてリリースする企業やコミュニティの数だけ、JDKの種類が増えます。
JDKの基本的な機能がその種類ごとで大きく異なってしまうということはあまり考えにくいのですが、状況によっては選んだJDKによって動作が異なることもあり得ます。
Javaでの開発を始める前に、開発を行う企業やコミュニティで使用されているJDKを確認して、それに合わせるように心がけましょう。

### 開発環境のインストールを行います

本書で使用するJavaのバージョンは、OpenJDKと呼ばれるオープン版のJDKを使用し、以下の開発バージョンを使います。

- `OpenJDK 21.0.6 (Microsoft)`

※本書執筆時点のLTS版（長期サポート対応バージョン）の中で最も新しいものを使用しています。

## 2.3 SDKMANを使用したバージョン管理

JDKのインストールの前に、JDKやJavaの開発ライブラリのバージョン別インストールをサポートしてくれるバージョン管理ツールをインストールします。
SDKMAN自体についてや各環境に合わせたインストール方法など、詳しくは以下のリンク先をみてください。

- [SDKMAN!](https://sdkman.io/)

### SDKMANのインストール

1. ターミナルを起動する
    - macOSのターミナルソフトウェアが起動すればよいです。 ターミナルソフトウェアが分からなければ、以下の操作で起動するウィンドウを使います。
    - `[⌘] + [space]`で `Spotlight` から `terminal` を起動
2. 以下のコマンドを実行してダウンロードする（`$`は入力しません）
    - $ `curl -s "https://get.sdkman.io" | bash`
3. 以下のコマンドを実行して初期設定を行う
    - $ `source "$HOME/.sdkman/bin/sdkman-init.sh"`
4. 以下のコマンドで正しくインストールされたかを確認する
    - $ `sdk version`
    - ```SDKMAN!```<br>```script: 5.19.0```<br>```native: 0.7.4 (macos aarch64)```のようなバージョン情報が出力されていればOKです。
5. 使用しているターミナルソフトウェアに合わせて環境変数を設定

macOSのターミナルソフトウェアとして、zshを使用している場合は以下のコマンドを使用します（`$`は入力しません）

```zsh
$ echo 'export JAVA_HOME=$HOME/.sdkman/candidates/java/current' >> ~/.zprofile
$ echo 'export PATH=$JAVA_HOME/bin:$PATH' >> ~/.zprofile
$ source ~/.zprofile
```

これらの環境変数の設定は、ほかのJavaを参照するアプリケーションのために設定しておきます。

#### 再履修者向け: SDKMANのアップグレード

すでにSDKMANをインストール済みの場合は、以下のコマンドでセルフアップグレードを行ってください。

```bash
$ sdk selfupdate force
```

### SDKMANを使用したJDKインストール

1. ターミナルを起動
2. $ `sdk list java` で現在インストール可能なJavaを一覧表示できます（開かれたテキストはvi形式です。次の行はエンターキー、次のページはスペースキー、閉じる場合は`:q`と入力します）
3. $ `sdk install java 21.0.6-ms` でJDKがインストールされます。
4. $ `java -version` でインストールされたJDKのバージョンが正しいか確認します。

以下のようにバージョン情報が出力されていればOKです。

```
openjdk 21.0.6 2025-01-21 LTS
OpenJDK Runtime Environment Microsoft-10800196 (build 21.0.6+7-LTS)
OpenJDK 64-Bit Server VM Microsoft-10800196 (build 21.0.6+7-LTS, mixed mode, sharing)
```

これでJDKの用意は完了です。

## 2.4 複数バージョンのJDKをインストールした場合

SDKMANをインストールして、SDKMAN経由でJDKをインストールした場合は、SDKMANが使用するバージョンをコントロールしてくれるため、設定ファイルを細々と書き換える必要はありません。

SDKMANでJDKのバージョンを切り替えたい場合は、以下のように行います。

```bash
sdk list java                  # インストール可能なバージョンとインストール済みのバージョンを確認
sdk use java 21.0.6-ms         # 現在のターミナルで使用するバージョンを設定
sdk default java 21.0.6-ms     # 標準で使用するバージョンを設定
```

## 2.5 統合開発環境（IDE）

本書では以下のIDEを推奨します：
- **IntelliJ IDEA**（Community Editionで十分）
- **Visual Studio Code**（Java開発の拡張機能が必須です）

IDEの利用に関しては、IntelliJ IDEA Community Editionがお勧めです。

本書で取り上げる操作説明などは、IntelliJ IDEA Community Editionを基本とします。

## 2.6 Hello Worldプログラム

Javaの開発環境構築やIDEのインストールが完了したところだと思います。  
まずは、JDKのみを使用し、IDEを使わずにJavaのプログラムを作成する方法を知りましょう。

本章の内容に限り、ターミナル上でプログラムを書きます。  
では、macOSに標準搭載されている簡易なテキストエディタである `nano` を使って簡単なプログラムを書いてみましょう。

### 作業スペースの作成

ターミナルを開き、以下のコマンドを入力しましょう。

```bash
$ cd                       # ホームディレクトリに移動
$ mkdir java-practice      # programming-practiceというディレクトリを作成する
$ cd java-practice         # oop1に移動する
```

### 画面に「Hello, World!!」を表示するプログラム

テキストエディタは何でも良いのですが、ファイル名「```HelloWorld.java```」として、ファイルを新規作成しましょう。
本書では、標準搭載されているテキストエディタnanoを使用する方法を書きます。

作業スペースを作成した続きで以下のコマンドを使用します。

```bash
$ nano HelloWorld.java
```

以下のコードを書きます。

### HelloWorld.java

このプログラムは、Javaプログラミングの最初の一歩となる、伝統的な「Hello World」プログラムです。このシンプルなプログラムを通じて、Javaプログラムの基本的な構造と、テキスト出力の方法を学習します。

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!!");
    }
}
```

**このコードで学習できる重要な概念：**

- **クラス定義（`public class HelloWorld`）**：Javaのすべてのプログラムはクラス内に記述されます。クラス名は必ずファイル名と一致させる必要があります。
- **メインメソッド（`public static void main(String[] args)`）**：プログラムの実行開始点となる特別なメソッドです。JVMはこのメソッドからプログラムの実行を開始します。
- **標準出力（`System.out.println`）**：コンソールに文字列を出力し、自動的に改行するメソッドです。これがJavaにおける最も基本的な出力方法です。

コードを書き終えたら、ファイルを保存しておきます。

nanoでの保存は、`[control] + [x]`の後、変更を保存するか聞かれるので`[y]`、ファイル名はそのまま`[return]`でOKです。

### C言語版

C言語でのHello Worldプログラムと比較することで、Javaの特徴をより深く理解できます。以下はC言語での同等のプログラムです：

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

### Java版

同じ機能をJavaで実装すると以下のようになります：

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

### 主な違いと設計思想の比較

この比較から、Java言語の重要な設計原則が見えてきます：

- **クラスベースの設計**：Javaはすべてのコードがクラス内に記述される純粋なオブジェクト指向言語です。これにより、コードの組織化と再利用性が向上します。
- **プラットフォーム独立性**：C言語の`#include <stdio.h>`のようなOS固有のヘッダファイルは不要で、Javaの標準ライブラリ（`System.out`）が抽象化を提供します。
- **メモリ管理の自動化**：C言語の`return 0`による明示的な終了処理は不要で、JVMが自動的にメモリ管理を行います。
- **型安全性の強化**：`main`メソッドのシグネチャが厳密に定義されており、コンパイル時に多くのエラーを検出できます。
- **実行モデルの違い**：C言語は機械語にコンパイルされますが、Javaはバイトコードにコンパイルされ、JVM上での実行により「Write Once, Run Anywhere」を実現します。

このような違いにより、Javaはより安全で保守性の高いプログラムの作成を支援しています。

## 2.7 コンパイルと実行

1. 以下のコマンドで、指定されたJavaファイルをコンパイルする
    - $ `javac HelloWorld.java`
2. コンパイルが成功すると、メッセージは何も表示されません
    - コンパイルに失敗する場合、ソースコードのどこに間違いがあるかがメッセージで表示されます。
    - コンパイル後にいくつかメッセージが表示されて、.classファイルなどが生成されていない、更新されていない場合はJavaファイルのコードを見直して、間違いがないか確認しましょう（エラーメッセージ内に間違っている箇所のヒントが書かれています。それを読みましょう）
3. ワークスペースのディレクトリをFinder等で見ると、「HelloWorld.class」と言ったクラスファイルが生成されている
    - .classファイルが、コンパイルされたJavaの実行ファイルです。
4. 以下のコマンドでプログラムを実行する
    - $ `java HelloWorld`

正しく実行できた場合、ターミナル上には、以下のような出力がされます。

```bash
Hello, World!!
```

ターミナルを使用したJavaプログラムのコンパイルと実行は、統合開発環境を使用する開発に入る前まで、以上の手順を用います。

### 覚えておこう！ コンパイルと実行

IDEを使用し始めると、コンパイルしてから実行という作業が、単に実行だけになります（IDEがコードを書いている裏で自動的にコンパイルしてくれている）

```bash
$ javac Javaファイル名
$ java 実行するクラス名
```

## 2.8 基本的な入出力

Javaプログラムでのプログラムへのデータの受け渡し方法は、さまざまな方法があります。
今回は、プログラムの実行後、キーボードからの入力を待ち受け、Enterキー押下で後続の処理が行われる方法を学びます。

### 標準入力

ユーザーとのインタラクティブなやりとりを実現するため、キーボードからの入力を受け付けるプログラムを作成します。このプログラムは、Java標準ライブラリの`Scanner`クラスを使用して、コンソールからのテキスト入力を処理する方法を学習できます。

ファイル名「```StandardInput.java```」

```java
import java.util.Scanner;  // このライブラリをStandardInputクラスで使う宣言

public class StandardInput {
    public static void main(String[] args) {
        // 標準入力をScannerで取得する
        Scanner in = new Scanner(System.in);
        // nextLine()メソッドは、キーボードからReturnキーの入力があるまで待ち、入力された1行を返す
        String inputLine = in.nextLine();
        // ↑inputLineという変数には、入力された文字列データが設定されています

        // 入力された文字列データをそのまま出力
        System.out.println(inputLine);
    }
}
```

**このコードで学習できる重要な概念：**

- **パッケージのインポート（`import java.util.Scanner`）**：Java標準ライブラリから必要なクラスを使用可能にします。これにより、ほかの開発者が作成した便利な機能を再利用できます。
- **Scannerクラスの活用**：`System.in`（標準入力ストリーム）をラップして、さまざまな形式でのデータ入力を可能にします。C言語の`scanf`に相当しますが、より安全で使いやすい設計です。
- **ブロッキング処理**：`nextLine()`メソッドはユーザーの入力を待機し、Enterキーが押されるまでプログラムの実行が一時停止します。このしくみにより、ユーザーのペースに合わせたプログラム実行が可能になります。
- **文字列の取得と表示**：入力された文字列を変数に格納し、あとで利用する基本的なパターンを学習できます。

### 標準入力から受けた文字列から数値変換を行う

実用的なプログラムでは、ユーザーから数値を入力してもらい、計算処理を行うことが頻繁にあります。しかし、コンソールからの入力はすべて文字列として扱われるため、数値として使用するには型変換が必要です。

#### 基本的な数値変換（問題あり版）

まず、最もシンプルな実装から始めましょう：

ファイル名「```ParseIntBasic.java```」

```java
import java.util.Scanner;

public class ParseIntBasic {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("数値を入力してください: ");
        
        String inputLine = in.nextLine();
        
        // 問題：この実装では不正な入力でプログラムがクラッシュする
        int num = Integer.parseInt(inputLine);  // 例："abc"を入力すると例外発生
        int ans = num + 10;
        
        System.out.println("結果: " + ans);
        in.close();
    }
}
```

**この実装の問題点：**
- ユーザーが「abc」や「12.5」などの無効な値を入力すると`NumberFormatException`が発生
- プログラムが予期せず終了してしまう
- 実際のアプリケーションでは致命的

#### 改善版：エラーハンドリングあり

実用的なプログラムでは、不正な入力に対する適切な処理が必要です：

ファイル名「```ParseIntSafe.java```」

```java
import java.util.Scanner;

public class ParseIntSafe {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int num = 0;
        boolean validInput = false;
        
        // 有効な入力が得られるまでループを継続
        while (!validInput) {
            System.out.print("整数を入力してください: ");
            String inputLine = in.nextLine();
            
            try {
                // 数値変換を試行
                num = Integer.parseInt(inputLine);
                
                // 範囲チェック（例：1-100の範囲のみ許可）
                if (num < 1 || num > 100) {
                    System.out.println("エラー: 1から100の範囲で入力してください");
                    continue;  // ループの先頭に戻る
                }
                
                validInput = true;  // 有効な入力が得られた
                
            } catch (NumberFormatException e) {
                // 数値以外が入力された場合の処理
                System.out.println("エラー: 整数を入力してください（入力値: " + inputLine + "）");
                // validInputはfalseのままなので、ループが継続される
            }
        }
        
        // 有効な入力が確定した後の処理
        int ans = num + 10;
        System.out.println("入力値: " + num);
        System.out.println("結果: " + ans);
        
        in.close();
    }
}
```

**この実装の改善点：**
1. **例外処理**: `try-catch`で`NumberFormatException`をキャッチ
2. **入力検証**: 範囲チェックで適切な値のみ受け入れ
3. **再入力の促進**: エラー時にユーザーに再入力を求める
4. **わかりやすいメッセージ**: 何が間違っているかを明確に表示
5. **リソース管理**: `Scanner`の適切なクローズ

#### より実践的な例：計算機プログラム

実際のアプリケーションを想定した、より高度な例です：

ファイル名「```Calculator.java```」

```java
import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        System.out.println("=== 簡易計算機 ===");
        
        // 第1オペランドの入力
        double num1 = getValidNumber(in, "1つ目の数値を入力してください: ");
        
        // 演算子の入力
        String operator = getValidOperator(in);
        
        // 第2オペランドの入力
        double num2 = getValidNumber(in, "2つ目の数値を入力してください: ");
        
        // 計算実行
        double result = calculate(num1, operator, num2);
        
        // 結果表示
        System.out.printf("%.2f %s %.2f = %.2f%n", num1, operator, num2, result);
        
        in.close();
    }
    
    // 有効な数値入力を取得するメソッド
    private static double getValidNumber(Scanner in, String prompt) {
        while (true) {
            System.out.print(prompt);
            String input = in.nextLine();
            
            try {
                return Double.parseDouble(input);
            } catch (NumberFormatException e) {
                System.out.println("エラー: 数値を入力してください");
            }
        }
    }
    
    // 有効な演算子入力を取得するメソッド
    private static String getValidOperator(Scanner in) {
        while (true) {
            System.out.print("演算子を入力してください (+, -, *, /): ");
            String operator = in.nextLine().trim();
            
            if (operator.equals("+") || operator.equals("-") || 
                operator.equals("*") || operator.equals("/")) {
                return operator;
            }
            
            System.out.println("エラー: +, -, *, / のいずれかを入力してください");
        }
    }
    
    // 計算を実行するメソッド
    private static double calculate(double num1, String operator, double num2) {
        switch (operator) {
            case "+":
                return num1 + num2;
            case "-":
                return num1 - num2;
            case "*":
                return num1 * num2;
            case "/":
                if (num2 == 0) {
                    throw new ArithmeticException("ゼロで割ることはできません");
                }
                return num1 / num2;
            default:
                throw new IllegalArgumentException("不正な演算子: " + operator);
        }
    }
}
```

**このコードで学習できる重要な概念：**

- **型変換の必要性**：Javaは強い型付け言語のため、文字列と数値は明確に区別されます。計算を行うには適切な型への変換が必須です。
- **Integer.parseInt()メソッド**：文字列を整数に変換するJava標準の方法です。このメソッドは文字列の内容を解析し、有効な整数表現の場合にのみ変換を行います。
- **算術演算**：整数に変換された値は、通常の数値として四則演算が可能になります。C言語と同様の演算子が使用できます。
- **変数の型宣言**：`String inputLine`、`int num`、`int ans`のように、Javaでは変数の型を明示的に宣言する必要があります。これにより、コンパイル時に型の不整合を検出できます。

#### 入力文字列が整数値に変換できない場合

Javaの型安全性の特徴を理解するため、意図的に無効な入力を試してみましょう。試しに`aa`という文字列を入力してみます。

**実行時例外（Runtime Exception）の発生：**
```
Exception in thread "main" java.lang.NumberFormatException: For input string: "aa"
	at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
	at java.lang.Integer.parseInt(Integer.java:580)
	at java.lang.Integer.parseInt(Integer.java:615)
	at ParseInt.main(ParseInt.java:14)
```

この結果は、Javaの重要な特徴である「型安全性」と「例外処理システム」を示しています。現時点ではこのエラーが発生することが正常な動作です。

**例外処理システムが示すJavaの設計思想：**

このプログラムは整数値に変換可能な文字列の入力を前提として設計されています。「整数値に変換できない文字列が入力されることは想定外」であるため、エラーが出力される動作が正常です。

この`NumberFormatException`例外は、以下の重要な概念を示しています：

- **型安全性の実装**：C言語では不正な型変換によってプログラムクラッシュを引き起こす可能性がありますが、Javaでは例外として制御可能な形でエラーを報告します。
- **早期エラー検出**：問題のあるデータを使用して計算が進行する前に、データの妥当性を検証し、適切な時点でエラーを発生させます。
- **デバッグ支援**：スタックトレースにより、エラーが発生した正確な場所とその経路が明確に示されます。

このようなエラーを回避するには、入力値の事前検証や例外処理（try-catch文）などの制御が必要になります。これらの高度な技術については、後の章で詳しく解説します。現時点では、Javaが提供する安全性機能の1つとして理解しておきましょう。

もう少し詳しく解説をすると、`Integer.parseInt("")`という処理は、引数で渡された文字を符号付き10進数の整数型として構文解析します。
この時、内部的には`Integer.parseInt("", 10)`の処理内容と同じことをしています。  
Oracleの公式ドキュメントによると、以下の条件で`java.lang.NumberFormatException`という例外が発生します。と解説がされています。

- 1番目の引数がnullであるか、長さゼロの文字列。
- radixがCharacter.MIN_RADIXよりも小さいか、Character.MAX_RADIXよりも大きい。
- 文字列の中に、指定された基数による桁には使えない文字がある。ただし、文字列の長さが1よりも大きい場合は、1番目の文字がマイナス記号'-'（'\u002D'）またはプラス記号'+' ('\u002B')であってもかまわない。
- 文字列によって表される値が、int型の値ではない。

参考： [Integer (Java SE 21 & JDK 21)](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/lang/Integer.html#parseInt(java.lang.String,int))

### 画面に文字列を出力する方法

Javaでは、画面に文字列を出力する方法として、いくつかの方法があります。出力方法の選択は、プログラムの要求に応じて使い分けることが重要です。

#### 1.`System.out.println`

**事前説明：**
`System.out.println`は、Javaにおける最も基本的で頻繁に使用される出力メソッドです。デバッグ情報の表示、ユーザーへのメッセージ表示、プログラムの実行結果出力など、さまざまな場面で活用されます。自動改行機能により、整理された見やすい出力を簡単に実現できます。

この出力方法は、指定された文字列（String型の変数や式でもOK）を改行コードを末尾につけて出力する方法です。

```java
System.out.println("Hello, World!!");
```

これをC言語でたとえるなら、以下のようになるはずです。

```c
printf("%s\n" , "Hello, World!!");
```

`\n`が自動的に追加されるイメージで良いでしょう。

**学習できる重要な概念：**
- **静的メソッド呼び出し**：`System.out.println`は静的メソッドであり、オブジェクトの生成なしに直接呼び出せます。
- **自動改行機能**：C言語の`printf`と異なり、明示的な改行文字の指定が不要です。
- **型の柔軟性**：文字列以外にも数値、真偽値などさまざまな型のデータを自動的に文字列に変換して出力できます。

#### 2. `System.out.print`

**事前説明：**
改行を含まない出力が必要な場合に使用します。複数の値を同一行に連続して出力したい場合や、入力プロンプトの表示など、改行が不要な場面で重要な役割を果たします。

これは、`System.out.println`で改行コードを末尾に追加しないバージョンです。

**学習できる重要な概念：**
- **出力制御の精密性**：改行の有無を明示的にコントロールできることで、より柔軟な出力フォーマットが実現できます。
- **ユーザーインターフェイス設計**：プロンプトメッセージなど、ユーザーとのインタラクションを意識した出力に不可欠です。

#### 3. `System.out.printf`

**事前説明：**
C言語の`printf`関数に慣れ親しんだ開発者や、複雑なフォーマット指定が必要な場合に有効です。数値の桁数制御、小数点以下の桁数指定、文字列の幅指定など、高度な出力フォーマット制御が可能になります。

C言語ライクに書きたい場合は、printfを使用してください。
C言語のprintfと同じような書き方で出力が可能です。

**学習できる重要な概念：**
- **フォーマット文字列の活用**：`%d`、`%f`、`%s`などの書式指定子により、データの表示形式を細かく制御できます。
- **言語間の互換性**：C言語の知識を活用しつつ、Javaの型安全性の恩恵を受けられます。
- **プロフェッショナルな出力**：レポート生成や数値データの整理された表示に適しています。

##### サンプルソース

**事前説明：**
このプログラムは、Javaの3つの主要な出力メソッドの違いと特徴を実践的に学習するためのサンプルです。各メソッドの出力結果を比較することで、適切な使い分けの判断基準を身につけることができます。

ファイル名「`StandardOutput.java`」

```java
public class StandardOutput {
    public static void main(String[] args) {
        System.out.println("標準出力は、「System.out.printlnメソッド」を使用します。");
        System.out.println("「System.out.println」は末尾に改行コードも併せて出力します。");
        System.out.println(); // 引数なしで改行のみ出力されます。
        System.out.print("「System.out.print」を使うと、末尾に改行は出力されません。");
        System.out.print("改行は\\nで出力できます。\n");
        System.out.print("\n");
        String message = "C言語のprintf関数のように出力したい場合は、「System.out.printf」を使います。";
        System.out.printf("%s\n", message);
        System.out.printf("整数値: %d, 実数値: %f\n", 10, 3.142592654d);
    }
}
```

**このコードで学習できる重要な概念：**

- **出力メソッドの使い分け**：各メソッドの特性を理解し、目的に応じた適切な選択ができます。
- **文字列リテラル内でのエスケープ処理**：`\\n`のように、特殊文字を文字列内で表現する方法を学習できます。
- **変数を利用した出力**：`String message`変数を使用することで、データの再利用と可読性の向上を実現しています。
- **書式指定子の活用**：`%s`（文字列）、`%d`（整数）、`%f`（浮動小数点数）の基本的な使用方法を学習できます。
- **型安全性の恩恵**：Javaの型システムにより、書式指定子と実際のデータ型の不整合をコンパイル時に検出できます。

**C言語との比較ポイント：**
- C言語では`printf`のみですべての出力を行いますが、Javaでは用途に応じて3つのメソッドを使い分けることで、より明確で保守しやすいコードが書けます。
- Javaの`printf`は、C言語の知識を活用しつつ、より安全な型チェック機能を提供します。


## 2.9 データ型

**事前説明：**
Javaのデータ型システムは、プログラムの安全性と保守性を大幅に向上させる重要な特徴です。C言語と比較しながら学習することで、Javaの型安全性がもたらす利点と、オブジェクト指向言語としての特性を理解できます。

### 基本データ型の比較

| C言語 | Java | 説明 |
|-------|------|------|
| int | int | 32ビット整数 |
| long | long | 64ビット整数 |
| float | float | 32ビット浮動小数点数 |
| double | double | 64ビット浮動小数点数 |
| char | char | 16ビットUnicode文字 |
| - | boolean | 真偽値（true/false） |

**学習できる重要な概念：**

- **プラットフォーム独立性**：Javaの基本データ型は、実行環境に関係なく常に同じサイズを持ちます。これにより「Write Once, Run Anywhere」が実現されます。
- **Unicode対応**：`char`型が16ビットのUnicode文字を扱えるため、国際化対応のプログラムが容易に作成できます。
- **真偽値型の存在**：C言語では整数で真偽を表現しますが、Javaでは`boolean`型により明確な真偽値表現が可能です。
- **型安全性の強化**：各データ型の役割が明確に分離されており、不正な型変換をコンパイル時に検出できます。

### 文字列の扱い

**事前説明：**
文字列処理は、現代のプログラミングにおいて極めて重要な要素です。Javaの`String`クラスは、C言語の文字配列よりもはるかに強力で安全な文字列処理機能を提供します。

```java
// C言語風（推奨されない）
char[] chars = {'H', 'e', 'l', 'l', 'o'};

// Java推奨
String message = "Hello, World!";
String name = "Java";
String greeting = message + " " + name;  // 文字列連結
```

**このコードで学習できる重要な概念：**

- **オブジェクトとしての文字列**：Javaでは文字列は`String`オブジェクトとして扱われ、豊富なメソッドが利用できます。
- **文字列連結の簡潔性**：`+`演算子による直感的な文字列連結が可能で、C言語の`strcat`関数よりもはるかに簡単です。
- **メモリ管理の自動化**：文字列の作成、変更、削除はJVMが自動的に管理するため、メモリリークの心配がありません。
- **不変性（Immutability）**：Javaの`String`オブジェクトは不変であり、文字列操作によって新しいオブジェクトが作成されます。これによりマルチスレッド環境での安全性が保証されます。
- **文字列プール**：同じ内容の文字列リテラルは、JVMの文字列プールで効率的に管理されます。

## 2.10 変数と定数

**事前説明：**
変数と定数の適切な使い分けは、保守しやすく理解しやすいプログラムを作成するための基本です。Javaの変数宣言システムは、型安全性を提供し、プログラムの実行時エラーを大幅に削減します。また、`final`修飾子による定数の定義は、プログラムの意図を明確に表現し、予期しない値の変更を防ぎます。

```java
// 変数宣言
int number = 10;
double price = 99.99;
boolean isActive = true;

// 定数（final修飾子）
final int MAX_VALUE = 100;
final String COMPANY_NAME = "TechBook";
```

**このコードで学習できる重要な概念：**

- **明示的な型宣言**：各変数の型を明確に宣言することで、コンパイル時の型チェックが可能になり、実行時エラーを防げます。
- **適切な命名規則**：変数名は`camelCase`、定数名は`UPPER_SNAKE_CASE`というJavaの標準的な命名規則を学習できます。
- **final修飾子の意味**：`final`キーワードにより値の変更を禁止し、プログラムの意図を明確に表現できます。
- **データ型の選択基準**：整数には`int`、浮動小数点数には`double`、真偽値には`boolean`という適切な型選択の重要性を理解できます。
- **初期化の重要性**：変数宣言と同時に適切な初期値を設定することで、未初期化変数によるバグを防げます。

**C言語との比較ポイント：**
- C言語の`const`キーワードに対応するのがJavaの`final`修飾子です。
- Javaでは変数の型宣言が必須であり、C言語のような暗黙的な型変換は制限されています。
- 真偽値を専用の`boolean`型で扱うことで、C言語の`0`/`非0`による真偽表現よりも明確になります。

## 2.11 演算子

**事前説明：**
Javaの演算子システムは、C言語の優れた設計を継承しつつ、オブジェクト指向と型安全性の観点から改良が加えられています。特に文字列連結における`+`演算子のオーバーロードは、Javaの利便性を大幅に向上させる重要な機能です。また、論理演算子の短絡評価（ショートサーキット評価）などの高度な概念も含まれています。

Javaの演算子はC言語とほぼ同じですが、いくつかの違いがあります：

```java
// 算術演算子（C言語と同じ）
int a = 10, b = 3;
int sum = a + b;        // 13
int diff = a - b;       // 7
int product = a * b;    // 30
int quotient = a / b;   // 3
int remainder = a % b;  // 1

// 文字列連結（Javaの特徴）
String result = "合計: " + sum;

// 比較演算子
boolean isEqual = (a == b);     // false
boolean isNotEqual = (a != b);  // true

// 論理演算子
boolean result1 = (a > 5) && (b < 10);  // true
boolean result2 = (a < 5) || (b > 10);  // false
```

**このコードで学習できる重要な概念：**

- **演算子の優先順位**：C言語と同じ優先順位ルールにより、複雑な式も予測可能な順序で評価されます。
- **文字列連結の自動型変換**：`"合計: " + sum`のように、数値が自動的に文字列に変換される便利機能を学習できます。
- **短絡評価（Short-circuit evaluation）**：`&&`や`||`演算子では、左辺の結果によって右辺の評価が省略される効率的な評価方法を理解できます。
- **型安全な比較**：比較演算子の結果は必ず`boolean`型となり、C言語のような整数との混同を避けられます。
- **整数除算の特性**：`10 / 3 = 3`のように、整数どうしの除算では小数点以下が切り捨てられることを理解できます。

**Javaの演算子の特別な機能：**

- **文字列連結演算子**：`+`演算子が文字列に対して使用された場合、連結処理が自動的に実行されます。
- **instanceof演算子**：オブジェクトの型を実行時に確認する、オブジェクト指向言語ならではの演算子です。
- **三項演算子**：`条件 ? 真の場合 : 偽の場合`という簡潔な条件分岐が可能です。

**C言語との重要な違い：**
- ポインタ演算子（`*`、`&`）は存在しません。Javaではオブジェクト参照により安全なメモリアクセスを実現しています。
- `sizeof`演算子はありません。配列のサイズは`.length`プロパティで取得します。

## 2.12 制御構造

**事前説明：**
制御構造は、プログラムの流れ（フロー）を制御する基本的なしくみです。条件分岐と繰り返し処理により、プログラムに複雑な判断力と処理能力を与えることができます。Javaの制御構造は、C言語の優れた設計を継承しつつ、より安全で表現力豊かな機能を提供しています。

### 条件分岐

**事前説明：**
条件分岐は、プログラムが状況に応じて異なる処理を選択するしくみです。成績判定、ユーザー入力の検証、システム状態の確認など、実用的なプログラムには不可欠な機能です。

```java
// if文（C言語と同じ）
int score = 85;
if (score >= 90) {
    System.out.println("優");
} else if (score >= 80) {
    System.out.println("良");
} else if (score >= 70) {
    System.out.println("可");
} else {
    System.out.println("不可");
}

// switch文（Java 12以降の新記法も利用可能）
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**このコードで学習できる重要な概念：**

- **多段階条件分岐**：`else if`の連鎖により、複数の条件を順次評価できます。これは成績判定のような段階的評価に最適です。
- **論理的な条件設計**：条件を`score >= 90`から順番に書くことで、重複しない明確な判定ロジックを実現しています。
- **switch式の活用**：Java 12以降の新しいswitch式では、より簡潔で関数型プログラミングに近い記述が可能です。
- **複数ケースの同時処理**：`case 10, 9 ->`のように、複数の値に対して同じ処理を適用できます。
- **型安全な分岐**：条件式は必ず`boolean`型である必要があり、C言語のような整数による条件分岐は許可されません。

**新旧switch文の比較による学習ポイント：**

従来のswitch文：
```java
String grade;
switch (score / 10) {
    case 10:
    case 9:
        grade = "優";
        break;
    case 8:
        grade = "良";
        break;
    case 7:
        grade = "可";
        break;
    default:
        grade = "不可";
        break;
}
```

新しいswitch式：
```java
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**学習できる進化のポイント：**
- **fall-through問題の解決**：新しいswitch式では`break`文が不要で、意図しないfall-throughバグを防げます。
- **式としての利用**：switch文が値を返すことができるようになり、変数への代入が直接可能です。
- **簡潔な記述**：`->`記法により、コードがより読みやすく保守しやすくなります。

### 繰り返し処理

**事前説明：**
繰り返し処理（ループ）は、同じ処理を効率的に何度も実行するためのしくみです。配列の全要素を処理する、計算を指定回数繰り返す、条件が満たされるまで処理を続けるなど、プログラミングの基本的なパターンを実現します。Javaでは、用途に応じて3つの主要なループ構文を提供しています。

```java
// for文
for (int i = 0; i < 10; i++) {
    System.out.println("i = " + i);
}

// 拡張for文（foreach）
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// while文
int count = 0;
while (count < 5) {
    System.out.println("count = " + count);
    count++;
}
```

**このコードで学習できる重要な概念：**

- **for文の3つの要素**：初期化(`int i = 0`）、条件（`i < 10`）、更新（`i++`)の明確な分離により、ループの動作が理解しや少なっています。
- **拡張for文の利便性**：配列やコレクションの全要素を処理する際に、インデックス管理が不要で安全です。Java 5で導入されたこの機能により、配列操作のバグが大幅に減少しました。
- **while文の柔軟性**：条件が複雑な場合や、ループ回数が事前に決まらない場合に適しています。
- **ループ変数のスコープ**：for文内で宣言された変数`i`は、ループ内でのみ有効です。これにより名前空間の汚染を防げます。
- **配列との連携**：拡張for文では、配列の要素に直接アクセスでき、境界値エラー（IndexOutOfBoundsException）を防げます。

**各ループの使い分けの指針：**

- **for文**：繰り返し回数が明確で、カウンタ変数が必要な場合
- **拡張for文**：配列やコレクションの全要素を順次処理する場合
- **while文**：複雑な条件や、繰り返し回数が動的に決まる場合

**C言語との比較における重要なポイント：**
- 拡張for文はC言語にはない、Javaの重要な改良点です。
- ループ変数のスコープがより厳密に管理されています。
- 配列アクセスの安全性が大幅に向上しています。

## 2.13 配列

**事前説明：**
配列は、同じ型の複数のデータを効率的に管理するための基本的なデータ構造です。学生の成績管理、商品の在庫管理、数値計算など、プログラミングの多くの場面で配列が活用されます。Javaの配列は、C言語の配列の利便性を継承しつつ、境界チェックや自動初期化により安全性を大幅に向上させています。

```java
// 配列の宣言と初期化
int[] numbers = {1, 2, 3, 4, 5};

// または
int[] scores = new int[10];  // 10要素の配列
scores[0] = 100;
scores[1] = 95;

// 配列の長さ
System.out.println("配列の長さ: " + numbers.length);

// 多次元配列
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

**このコードで学習できる重要な概念：**

- **配列初期化の2つの方法**：リテラル初期化(`{1, 2, 3, 4, 5}`)と`new`キーワードによる動的作成の使い分けを理解できます。
- **オブジェクトとしての配列**：Javaの配列はオブジェクトであり、`length`プロパティなどの便利な機能を持っています。
- **境界チェックの自動実行**：配列の範囲外アクセスは`ArrayIndexOutOfBoundsException`として検出され、セグメンテナンスーション違反のような深刻な問題を防げます。
- **自動初期化**：`new int[10]`で作成された配列の要素は自動的に0で初期化されます。これによりガベージ値による予期しない動作を防げます。
- **多次元配列の構造**：2次元配列は「配列の配列」として実装され、行列やテーブル形式のデータを直感的に表現できます。

**配列操作の実用例：**

```java
// 配列の全要素を処理する安全な方法
int[] data = {10, 20, 30, 40, 50};

// インデックスを使用した従来の方法
for (int i = 0; i < data.length; i++) {
    System.out.println("data[" + i + "] = " + data[i]);
}

// 拡張for文を使用した推奨方法
for (int value : data) {
    System.out.println("値: " + value);
}
```

**C言語との重要な違い：**

- **lengthプロパティ**：C言語では配列のサイズを別途管理する必要がありますが、Javaでは`array.length`で常に正確なサイズを取得できます。
- **境界チェック**：C言語では配列の範囲外アクセスがシステムクラッシュを引き起こす可能性がありますが、Javaでは例外として安全に処理されます。
- **メモリ管理**：配列のメモリ確保と解放はJVMが自動的に行うため、メモリリークやダングリングポインタの心配がありません。
- **初期化の保証**：Java配列の要素は必ず適切なデフォルト値で初期化されます（数値型は0、真偽値型はfalse、オブジェクト型はnull）。

## 2.14 メソッド（関数）

**事前説明：**
メソッド（関数）は、特定の処理をまとめて名前を付け、必要な時に呼び出して使用するしくみです。コードの再利用性を高め、プログラムの構造を整理し、保守性を向上させる重要な概念です。Javaのメソッドは、C言語の関数の概念を発展させ、オブジェクト指向プログラミングの基礎となる機能を提供しています。

```java
public class Calculator {
    // メソッドの定義
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double divide(double a, double b) {
        if (b == 0) {
            System.out.println("ゼロ除算エラー");
            return 0;
        }
        return a / b;
    }
    
    public static void main(String[] args) {
        int result = add(10, 5);
        System.out.println("結果: " + result);
        
        double divResult = divide(10.0, 3.0);
        System.out.println("除算結果: " + divResult);
    }
}
```

**このコードで学習できる重要な概念：**

- **メソッドシグネチャの構成**：`public static int add(int a, int b)`の各要素（アクセス修飾子、static修飾子、戻り値の型、メソッド名、パラメータ）の意味と役割を理解できます。
- **型安全なパラメータ渡し**：引数の型が明確に定義されており、コンパイル時に型の不整合を検出できます。
- **戻り値の型宣言**：メソッドが返す値の型を明示することで、呼び出し側で適切な変数で結果を受け取れます。
- **エラーハンドリングの実装**：ゼロ除算チェックにより、実行時エラーを防ぐ防御的プログラミングの手法を学習できます。
- **静的メソッドの特徴**：`static`修飾子により、オブジェクトの生成なしにメソッドを呼び出せる便利性を理解できます。

**メソッド設計の重要な原則：**

- **単一責任の原則**：`add`メソッドは加算のみ、`divide`メソッドは除算のみを担当し、1つのメソッドが1つの明確な役割を持っています。
- **再利用性の実現**：一度定義したメソッドは、プログラム内の任意の場所から何度でも呼びだすことができます。
- **デバッグの容易性**：問題が発生した場合、特定のメソッド内に原因を特定しやすくなります。
- **可読性の向上**：メソッド名により処理内容が明確になり、プログラムの意図が理解しやすくなります。

**高度なメソッド活用例：**

```java
// メソッドオーバーロードの例
public static int add(int a, int b) {
    return a + b;
}

public static double add(double a, double b) {
    return a + b;
}

public static int add(int a, int b, int c) {
    return a + b + c;
}
```

**C言語との比較における学習ポイント：**

- **クラス内での定義**：Javaのメソッドは必ずクラス内に定義される必要があり、グローバル関数は存在しません。
- **アクセス制御**：`public`、`private`などの修飾子により、メソッドの可視性を細かく制御できます。
- **オーバーロード機能**：同じ名前で異なるパラメータを持つメソッドを複数定義でき、利便性が向上します。
- **例外処理システム**：エラー処理がより構造化され、安全なプログラムの作成を支援します。

**Java基本文法の総合的な理解：プログラミングパラダイムの変革**

本章で学習した各要素は、独立したテクニックではなく、現代のソフトウェア開発における包括的な設計哲学の一部です。出力メソッドから始まり、データ型、変数、演算子、制御構造、配列、メソッドまで、すべてがJavaの「安全性」「保守性」「可読性」という3つの核心原則にもとづいて設計されています。

**学習した内容の相互関係と実践への応用：**

- **型安全性の一貫した実装**：`System.out.println`による自動型変換、明示的な変数宣言、メソッドのシグネチャ、配列の境界チェックなど、すべての機能が型の整合性を保証しています。
- **オブジェクト指向への基盤構築**：staticメソッド、クラス内でのメソッド定義、String型の活用など、本章で学んだ要素はすべて次章以降のオブジェクト指向学習への準備となっています。
- **C言語からの進化の理解**：単なる機能追加ではなく、ソフトウェア開発の課題（メモリ管理、プラットフォーム依存性、保守性）を根本的に解決するための設計思想の変革を体験できました。

**現代的なプログラミング手法への接続：**

今回学習した基本文法は、フレームワーク開発、Webアプリケーション構築、マイクロサービスアーキテクチャ、クラウドネイティブ開発など、現代のあらゆるJava開発の基盤となります。型安全性、例外処理、適切なメソッド設計などの概念は、企業での実際の開発において直接活用される重要なスキルです。

## 実践演習課題

本章で学習した内容を定着させるため、段階的な演習課題に取り組みましょう。各課題は、実用的な場面を想定して設計されています。

### 基礎演習 2-1：データ型と変数
**目標**：Java基本データ型の理解と活用

**課題内容**：
学生情報管理の基礎プログラムを作成してください。
- 学生ID（整数）
- 学生名（文字列）
- 身長（小数点）
- 在学中フラグ（真偽値）

**実装要件**：
- 各データ型の変数を適切に宣言・初期化する
- 標準入力から値を受け取り、変数に格納する
- すべての情報を整理して出力する

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切なデータ型の選択 |
| 変数の命名規則の遵守 |
| 入力・出力処理の正確な実装 |

### 応用演習 2-2：制御構造の活用
**目標**：条件分岐と繰り返し処理の実践

**課題内容**：
学生の成績判定プログラムを作成してください。
- 5科目の点数を入力として受け取る
- 各科目の合格/不合格を判定（60点以上で合格）
- 平均点を計算する
- 総合判定（全科目合格で卒業認定）を出力する

**実装要件**：
- 繰り返し処理で5科目の点数を効率的に入力
- 条件分岐で合格判定を実装
- 論理演算子を使用して総合判定を実装

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切な条件分岐の使用 |
| 繰り返し処理による効率的な実装 |
| 論理演算子の適切な使用 |

### 実践演習 2-3：配列を使った数値処理
**目標**：配列とアルゴリズムの基本的な組み合わせ

**課題内容**：
数値データ分析プログラムを作成してください。
- 10個の数値を配列に格納
- 最大値、最小値、平均値を計算
- 数値を昇順にソート
- 特定の値の検索機能

**実装要件**：
- 配列の適切な初期化と操作
- ソートアルゴリズムの実装（バブルソートなど）
- 線形検索アルゴリズムの実装

**評価ポイント**：

| 評価項目 |
| :--- |
| 配列操作の正確な実装 |
| アルゴリズムの論理的な構成 |
| エラー処理の考慮 |

**拡張課題**：
- ユーザーが配列サイズを指定できるようにする
- 統計情報（中央値、標準偏差）の計算を追加

### 発展演習 2-4：総合プログラム
**目標**：第2章の全要素を統合した実用的なプログラム

**課題内容**：
簡易家計簿プログラムを作成してください。
- 支出項目と金額の入力
- カテゴリ別集計（食費、交通費、娯楽費など）
- 月間予算との比較
- 支出レポートの表示

**実装要件**：
- 複数のメソッドに機能を分割
- 配列または多次元配列でデータ管理
- メニュー形式のユーザーインターフェイス
- 基本的な入力検証

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切なメソッド設計 |
| データ構造の効率的な活用 |
| ユーザビリティの考慮 |
| コードの可読性と保守性 |

### セルフチェック課題

各演習完了後、以下の項目で自己評価を行ってください：

**技能確認チェック**

| チェック項目 |
| :--- |
| エラーなしでコンパイル・実行できる |
| 意図した動作が正確に実行される |
| C言語との違いを説明できる |
| コードに適切なコメントが記述されている |

**理解度確認チェック**

| チェック項目 |
| :--- |
| 使用したJava文法要素の役割を説明できる |
| 他の問題に応用できる自信がある |
| より良い実装方法を考えることができる |

### 発展的な学習課題

さらなるスキル向上を目指す方は、以下の課題にも挑戦してみてください：

1. **アルゴリズム実装課題**：
   - クイックソート、マージソートの実装
   - 二分探索アルゴリズムの実装
   - 数学的計算（階乗、フィボナッチ数列）

2. **文字列処理課題**：
   - 文字列の逆順変換
   - 単語カウント機能
   - 簡単な暗号化・復号

3. **データ構造課題**：
   - 2次元配列を使った表計算
   - ゲーム盤（オセロ、三目並べ）の実装
   - 簡単な画像処理（ASCIIアート）

## クラスとオブジェクトの基本

章末の練習課題に取り組む前に、Javaプログラミングの核心であるクラスとオブジェクトの基本的な概念と構文を理解しておきましょう。

### クラスの基本構造

Javaでは、すべてのコードは**クラス**という単位で記述します。クラスは「設計図」であり、オブジェクトはその設計図から作られる「実体」です。

#### 基本的なクラスの定義

```java
public class Person {
    // フィールド（インスタンス変数）
    private String name;
    private int age;
    
    // コンストラクタ
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // メソッド（振る舞い）
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void introduce() {
        System.out.println("こんにちは、" + name + "です。" + age + "歳です。");
    }
}
```

### クラスの構成要素

#### 1. フィールド（インスタンス変数）

オブジェクトが持つデータを格納する変数です：

```java
private String name;    // 文字列を格納
private int age;        // 整数を格納
private double height;  // 小数を格納
```

**重要なポイント**：
- `private`を使ってカプセル化（外部からの直接アクセスを防ぐ）
- 各オブジェクトが独自の値を持つ

#### 2. コンストラクタ

オブジェクトを作成する際に呼び出される特別なメソッドです：

```java
public Person(String name, int age) {
    this.name = name;  // パラメータの値をフィールドに設定
    this.age = age;
}
```

**重要なポイント**：
- クラス名と同じ名前
- 戻り値の型を書かない
- `this`キーワードでフィールドを明示的に指定

#### 3. メソッド

オブジェクトの振る舞いを定義します：

```java
// 値を返すメソッド
public String getName() {
    return name;
}

// 処理を実行するメソッド
public void introduce() {
    System.out.println("こんにちは、" + name + "です。");
}
```

### オブジェクトの作成と使用

#### オブジェクトの作成

```java
public class Main {
    public static void main(String[] args) {
        // newキーワードでオブジェクトを作成
        Person person1 = new Person("田中太郎", 25);
        Person person2 = new Person("佐藤花子", 30);
        
        // メソッドを呼び出す
        person1.introduce();  // "こんにちは、田中太郎です。25歳です。"
        person2.introduce();  // "こんにちは、佐藤花子です。30歳です。"
        
        // getterメソッドで値を取得
        String name = person1.getName();
        int age = person1.getAge();
        System.out.println(name + "は" + age + "歳です。");
    }
}
```

### オブジェクト指向の基本概念

#### カプセル化

データ（フィールド）を`private`にして、`public`メソッドを通じてのみアクセスできるようにする：

```java
public class BankAccount {
    private int balance;  // 残高は外部から直接変更できない
    
    public void deposit(int amount) {
        if (amount > 0) {
            balance += amount;  // 正の値のみ受け付ける
        }
    }
    
    public int getBalance() {
        return balance;
    }
}
```

#### オブジェクトどうしの連携

```java
public class Library {
    private String name;
    
    public void lendBook(Person person, String bookTitle) {
        System.out.println(person.getName() + "さんに「" + 
                         bookTitle + "」を貸し出しました。");
    }
}
```

### よく使用されるパターン

#### toString()メソッド

オブジェクトの文字列表現を定義：

```java
public class Person {
    // ... 他のコード ...
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}
```

#### equals()とhashCode()

オブジェクトの同値性を定義：

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Person person = (Person) obj;
    return age == person.age && Objects.equals(name, person.name);
}

@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

### 練習課題で使用する重要な概念

1. **オブジェクトの状態管理**：フィールドを使ってオブジェクトの状態を保持
2. **メソッドによる操作**：状態を変更したり、計算を行ったりするメソッド
3. **オブジェクト間の関係**：異なるオブジェクトどうしが連携する設計
4. **データの妥当性**：setterメソッドでの入力値検証

---

これらの基本概念を理解することで、章末の練習課題により効果的に取り組むことができます。

## まとめ

本章では、C言語との比較を通じてJavaの基本文法を学習しました。重要なのは、単に文法を暗記することではなく、Javaが提供する「安全性」「保守性」「可読性」という設計思想を理解することです。

**次章への準備：**
- 基本文法の習得により、Java言語の基礎的な表現力を身につけました
- 型安全性、例外処理、メソッド設計などの概念により、品質の高いコードを書くための基盤を構築しました  
- クラスとメソッドの概念に触れることで、オブジェクト指向プログラミングへの準備が整いました

次章では、Javaの最大の特徴であるオブジェクト指向プログラミングについて学習します。本章で学んだ基本文法の知識をベースに、より高度で実用的なプログラミング技法を習得していきましょう。
## 章末演習

本章で学んだJava基本文法を活用して、段階的な練習課題に取り組みましょう。各レベルは前のレベルの習得を前提として設計されています。

### 演習の目標
- 変数とデータ型の適切な使用
- 制御構造（if文、for文、while文）の実装
- 配列の操作と活用
- メソッドの定義と呼び出し

### 演習課題の難易度レベル

#### 🟢 基礎レベル（Basic）
- **目的**: Java基本文法の確実な理解と基本的な実装力の習得
- **所要時間**: 15-30分/課題
- **前提**: 教科書の例題が理解できること
- **評価基準**: 
  - 基本構文を正しく使える（変数宣言、型、演算子）
  - 簡単な制御構造が実装できる（if文、for文、while文）
  - エラーなくコンパイル・実行できる
  - 期待される出力が得られる

#### 🟡 応用レベル（Applied）
- **目的**: 複数の概念を組み合わせた実践的な問題解決
- **所要時間**: 30-45分/課題
- **前提**: 基礎レベルを完了していること
- **評価基準**:
  - 複数の基本構文を適切に組み合わせられる
  - 配列とメソッドを効果的に活用できる
  - 簡単なアルゴリズムが実装できる
  - 可読性のあるコードが書ける

#### 🔴 発展レベル（Advanced）
- **目的**: より実務に近い複雑な問題への挑戦
- **所要時間**: 45-60分/課題
- **前提**: 応用レベルを完了し、追加の調査意欲があること
- **評価基準**:
  - 効率的なアルゴリズムを選択できる
  - エラーハンドリングを考慮している
  - 拡張性を意識した実装ができる

#### ⚫ 挑戦レベル（Challenge）
- **目的**: 創造性と高度な問題解決能力の発揮
- **所要時間**: 60分以上
- **前提**: 発展レベル完了と自主的な学習
- **評価基準**:
  - 独創的なアプローチで問題解決できる
  - 複数の解法を比較検討できる
  - 他者に説明できるレベルの理解

### 演習課題の詳細

演習課題の完全な解答例とテストファイルは `exercises/chapter02/` ディレクトリにあります。
以下では各課題の問題内容、要求仕様、実装ヒントを示します。

## 🟢 基礎レベル課題（必須）

### 課題1: 基本計算機（Calculator.java）

**学習目標：** 標準入力、数値変換、基本演算、エラーハンドリング

**問題説明：**
ユーザーから2つの数値と演算子（+, -, *, /）を入力させ、計算結果を表示する基本的な計算機を作成してください。

**要求仕様：**
1. "1つ目の数値を入力してください： " と表示し、数値を入力受け付け
2. "2つ目の数値を入力してください： " と表示し、数値を入力受け付け  
3. "演算子を入力してください (+, -, *, /): " と表示し、演算子を入力受け付け
4. 計算結果を "結果： X ? Y = Z" の形式で表示
5. ゼロ除算の場合は "エラー: ゼロで割ることはできません" と表示

**実行例：**
```
1つ目の数値を入力してください: 10
2つ目の数値を入力してください: 3
演算子を入力してください (+, -, *, /): /
結果: 10.0 / 3.0 = 3.333333333333333
```

**実装ヒント：**
```java
// Scanner使用のためのimport
import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 数値入力（Double.parseDoubleを使用）
        System.out.print("1つ目の数値を入力してください: ");
        double num1 = Double.parseDouble(scanner.nextLine());
        
        // 演算子判定にはswitch文またはif-else文を使用
        // ゼロ除算チェックを忘れずに
        
        scanner.close();
    }
}
```

**評価基準：**
- [ ] 正確な数値入力と演算ができる
- [ ] すべての演算子（+, -, *, /）に対応
- [ ] ゼロ除算エラーを適切に処理
- [ ] 出力形式が仕様通り

---

### 課題2: 配列の基本操作（ArrayBasics.java）

**学習目標：** 配列の宣言、初期化、要素アクセス、ループ処理

**問題説明：**
5つの整数を入力させ、配列に格納して、最大値、最小値、平均値を計算して表示するプログラムを作成してください。

**要求仕様：**
1. "5つの整数を入力してください："と表示
2. 5回ループして数値を入力受け付け（"数値X: "の形式で入力促進）
3. 入力した5つの数値を表示
4. 最大値、最小値、平均値を計算して表示

**実行例：**
```
5つの整数を入力してください:
数値1: 23
数値2: 45
数値3: 12
数値4: 67
数値5: 34

入力された数値: [23, 45, 12, 67, 34]
最大値: 67
最小値: 12
平均値: 36.2
```

**実装ヒント：**
```java
public class ArrayBasics {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int[] numbers = new int[5];  // 5要素の配列を宣言
        
        System.out.println("5つの整数を入力してください:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.print("数値" + (i + 1) + ": ");
            numbers[i] = Integer.parseInt(scanner.nextLine());
        }
        
        // 最大値・最小値はnumbers[0]で初期化
        // 平均値は合計÷要素数で計算
    }
}
```

**評価基準：**
- [ ] 配列を正しく宣言・初期化できる
- [ ] ループを使って配列要素にアクセスできる
- [ ] 最大値・最小値・平均値を正確に計算
- [ ] 配列の内容を適切に表示

---

### 課題3: 文字列の基本処理（StringBasics.java）

**学習目標：** 文字列操作、文字列メソッド、文字カウント

**問題説明：**
ユーザーから文字列を入力させ、その文字列に対して以下の情報を表示するプログラムを作成してください。

**要求仕様：**
1. "文字列を入力してください： "と表示し、文字列を入力受け付け
2. 文字列の長さを表示
3. 大文字に変換した文字列を表示
4. 小文字に変換した文字列を表示
5. 各文字を1行ずつ表示
6. 特定の文字（'a'または'A'）の出現回数を表示

**実行例：**
```
文字列を入力してください: Hello Java
文字列の長さ: 10
大文字: HELLO JAVA
小文字: hello java
各文字:
H
e
l
l
o
 
J
a
v
a
文字 'a' の出現回数: 3
```

**実装ヒント：**
```java
public class StringBasics {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("文字列を入力してください: ");
        String input = scanner.nextLine();
        
        // 文字列の長さ: input.length()
        // 大文字変換: input.toUpperCase()
        // 小文字変換: input.toLowerCase()
        // 各文字へのアクセス: input.charAt(i)
        
        // 文字カウントはループで各文字をチェック
        int count = 0;
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
            if (c == 'a' || c == 'A') {
                count++;
            }
        }
    }
}
```

**評価基準：**
- [ ] 文字列の基本メソッドを適切に使用
- [ ] ループを使って各文字にアクセス
- [ ] 文字カウント処理が正確
- [ ] 出力形式が仕様通り

---

### 課題4: メソッドの基本使用（MethodBasics.java）

**学習目標：** メソッドの定義、戻り値、引数、static修飾子

**問題説明：**
数学的な計算を行うメソッドを複数定義し、mainメソッドから呼び出してテストするプログラムを作成してください。

**要求仕様：**
1. `add(int a, int b)`: 2つの整数の和を返す
2. `multiply(int a, int b)`: 2つの整数の積を返す
3. `power(int base, int exponent)`: baseのexponent乗を返す
4. `factorial(int n)`: nの階乗を返す（nは1〜10の範囲）
5. mainメソッドでそれぞれのメソッドをテストして結果を表示

**実行例：**
```
=== メソッドテスト ===
add(5, 3) = 8
multiply(4, 7) = 28
power(2, 3) = 8
factorial(5) = 120
```

**実装ヒント：**
```java
public class MethodBasics {
    // staticメソッドとして定義（mainから直接呼び出し可能）
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static int multiply(int a, int b) {
        // TODO: 実装
    }
    
    public static int power(int base, int exponent) {
        // ループまたは再帰で実装
        // Math.powは使わずに自分で実装
    }
    
    public static int factorial(int n) {
        // 1 * 2 * 3 * ... * nを計算
        // ループで実装
    }
    
    public static void main(String[] args) {
        System.out.println("=== メソッドテスト ===");
        System.out.println("add(5, 3) = " + add(5, 3));
        // 他のメソッドも同様にテスト
    }
}
```

**評価基準：**
- [ ] すべてのメソッドが正しく定義されている
- [ ] メソッドの戻り値と引数が適切
- [ ] factorial（階乗）の計算が正確
- [ ] power（累乗）の計算が正確
- [ ] mainメソッドから全メソッドをテスト

## 🟡 応用レベル課題（推奨）

基礎レベルを完了した方は、以下のより実践的な課題に挑戦してください。

### 課題1: 科学計算機（ScientificCalculator.java）

**学習目標：** 複数演算子の処理、Mathクラス、メニュー形式のプログラム

**問題説明：**
基本的な四則演算に加え、三角関数、対数、平方根などの科学計算機能を持つプログラムを作成してください。

**要求仕様：**
1. メニューを表示し、ユーザーに操作を選択させる
2. 基本演算（+, -, *, /）
3. 科学演算（sin, cos, tan, log, sqrt, pow）
4. "exit" で終了
5. 不正な入力に対するエラーハンドリング

**実行例：**
```
=== 科学計算機 ===
1. 基本演算 (+, -, *, /)
2. 三角関数 (sin, cos, tan)
3. その他 (log, sqrt, pow)
4. 終了
選択してください: 2
数値を入力してください: 30
sin(30°) = 0.5
cos(30°) = 0.866
tan(30°) = 0.577
```

### 課題2: 配列処理アルゴリズム（ArrayProcessor.java）

**学習目標：** アルゴリズムの実装、配列の高度な操作

**問題説明：**
配列に対する基本的なアルゴリズム（ソート、検索、統計）を実装するプログラムを作成してください。

**実装する機能：**
- バブルソート
- 線形探索
- 重複の検出
- 配列の反転
- 中央値の計算

### 課題3: テキスト解析（TextAnalyzer.java）

**学習目標：** 文字列の高度な処理、文字分析

**問題説明：**
入力されたテキストを分析し、さまざまな統計情報を表示するプログラムを作成してください。

**分析項目：**
- 文字数、単語数、行数
- 最も頻繁に出現する文字
- 各文字の出現頻度
- パリンドローム（回文）の判定

### 課題4: 数当てゲーム（NumberGame.java）

**学習目標：** ゲームロジック、ランダム数生成、ゲームループ

**問題説明：**
コンピュータがランダムに選んだ1〜100の数値を、ユーザーがヒントを元に当てるゲームを作成してください。

**要求仕様：**
- ヒント（"大きい" / "小さい"）の表示
- 試行回数の記録
- 最高記録の保存
- ゲーム継続の選択

## 🔴 発展レベル課題（挑戦者向け）

### 課題1: 行列計算（MatrixCalculator.java）

**学習目標：** 多次元配列、数学的アルゴリズム

**問題説明：**
2次元配列を使って行列の基本演算（加算、減算、乗算）を実装してください。

### 課題2: ソートアルゴリズム（SortingAlgorithms.java）

**学習目標：** 高度なアルゴリズム、性能分析

**問題説明：**
複数のソートアルゴリズム（バブル、選択、挿入、クイック）を実装し、性能を比較してください。

### 課題3: データ処理システム（DataProcessor.java）

**学習目標：** ファイル処理、CSV形式、データ変換

**問題説明：**
CSV形式のデータを読み込み、集計・分析・レポート出力を行うシステムを作成してください。

## ⚫ 挑戦レベル課題（上級者向け）

### 課題1: 簡易式計算機（MiniCompiler.java）

**学習目標：** パーサ、構文解析、再帰処理

**問題説明：**
"3 + 4 * 2 - 1" のような数式文字列を解析し、正しい演算順序で計算するプログラムを作成してください。

### 課題2: 簡易ゲームエンジン（GameEngine.java）

**学習目標：** オブジェクト指向設計、ゲームループ、状態管理

**問題説明：**
テキストベースの簡単なRPGゲームエンジンを作成してください。キャラクタ、アイテム、戦闘システムを含めます。

---

### 推奨学習パス

```
【段階的学習フロー】
🟢 基礎課題1-4 (全完了必須)
    ↓
🟡 応用課題1 → 応用課題2 → 応用課題3 → 応用課題4
    ↓ (80%以上達成で進級)
🔴 発展課題 (1課題以上完了推奨)
    ↓
⚫ 挑戦課題 (自由選択)
```

### 学習の進め方

1. **🟢 基礎レベル**: 4課題すべてを順番に完了してください
   - 各課題で基本構文の使い方を確認
   - エラーメッセージを理解し、修正する練習
   - コードの実行結果を予測する練習

2. **🟡 応用レベル**: 基礎完了後、興味のある課題から取り組む
   - 複数の概念を組み合わせる練習
   - 小さなアルゴリズムの実装練習
   - コードの改善・最適化を考える

3. **🔴 発展レベル**: より実務に近い問題に挑戦
   - 効率性と可読性のバランスを考慮
   - エラーハンドリングの実装
   - 設計の改善を意識

4. **⚫ 挑戦レベル**: 創造性を発揮して自由に挑戦
   - 独自のアプローチを考える
   - 機能の拡張を検討
   - 他の解法との比較

### 自己評価チェックリスト

各レベル完了時に以下をチェックしてください：

#### 🟢 基礎レベル完了の条件
- [ ] 変数宣言と初期化が正しくできる
- [ ] 基本的な演算子を使った計算ができる  
- [ ] if文、for文、while文を適切に使い分けられる
- [ ] 配列の宣言、初期化、要素アクセスができる
- [ ] 簡単なメソッドを定義し、呼びだすことができる

#### 🟡 応用レベル完了の条件
- [ ] 複数の制御構造を組み合わせた処理が書ける
- [ ] 配列を使った検索・集計処理が実装できる
- [ ] 文字列の操作と変換が適切にできる
- [ ] メソッドを使ったモジュール化ができる
- [ ] 基本的なアルゴリズム（線形探索、バブルソート等）が理解できる

