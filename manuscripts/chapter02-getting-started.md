# 第2章 Java基本文法

## 本章の学習目標

### 前提知識
**必須前提**：
- 第1章のJava開発環境構築完了
- Hello Worldプログラムの作成・実行経験
- C言語での基本的なプログラミング経験（変数、条件分岐、ループ）

**望ましい前提**：
- テキストエディタまたはIDEの基本操作
- コマンドライン操作の基礎知識

### 学習目標
**知識理解目標**：
- Java言語仕様の基本的な理解
- JVM（Java仮想マシン）の役割としくみ
- プラットフォーム独立性の意味と利点
- Javaのメモリ管理（ガベージコレクション）の基本概念

**技能習得目標**：
- Java基本データ型の適切な使用
- 変数宣言と初期化の正確な記述
- 制御構造（if-else、for、while）のJava記法での実装
- メソッドの定義、呼び出し、戻り値の処理
- 配列の宣言、初期化、操作

**実践的な活用目標**：
- 基本的な数値計算プログラムの作成
- 文字列処理を含む実用的な小プログラムの開発
- エラーメッセージの理解と基本的なデバッグ

**到達レベルの指標**：
- 手続き型スタイルでの基本的なJavaプログラムが独力で作成できる
- C言語とJavaの文法的違いを説明できる
- 基本的なコンパイルエラーを理解し修正できる
- 簡単なアルゴリズム（ソート、検索）をJavaで実装できる



## 章の構成

本章は、Javaの基本文法を体系的に学習できるよう、以下のパートで構成されています：

### [Part A: Javaの基礎](chapter02a-java-fundamentals.md)
- Javaという言語の特徴
- Java仮想マシン（JVM）の主要な特徴
- 基本データ型
- 変数の宣言と初期化
- 演算子
- 型変換
- コンソール入出力

### [Part B: 制御構造と配列](chapter02b-control-and-arrays.md)
- 条件分岐（if文、switch文）
- 繰り返し処理（for文、while文、拡張for文）
- 配列の宣言と操作
- 多次元配列

### [Part C: メソッドと文字列処理](chapter02c-methods-and-strings.md)
- メソッドの定義と呼び出し
- メソッドオーバーロード
- 文字列の基本操作
- StringBuilderによる効率的な文字列処理

### [Part D: クラスとオブジェクトの基礎](chapter02d-class-basics.md)
- クラスの基本構造
- フィールド、メソッド、コンストラクタ
- オブジェクトの作成と使用
- カプセル化の基本
- アクセス修飾子
- staticキーワード

### [Part E: 章末演習](chapter02e-exercises.md)
- 基礎演習：データ型と変数
- 応用演習：制御構造の活用
- 実践演習：配列を使った数値処理
- 発展演習：総合プログラム
- セルフチェック課題

## 学習の進め方

1. Part AでJavaの基本的な特徴と文法要素を理解
2. Part Bでプログラムの流れを制御する方法を習得
3. Part Cで再利用可能なコードの作成方法を学習
4. Part Dでオブジェクト指向への橋渡しとなる基礎を固める
5. Part Eの演習課題で実践的なスキルを身につける

各パートは独立して読むことも可能ですが、順番に学習することで、C言語の知識をベースにJavaプログラミングの基礎を体系的に習得できるよう設計されています。



<!-- Merged from chapter02a-java-fundamentals.md -->


## 始めに：Javaという言語の特徴

本章では、プログラミング言語Javaの基本文法を学習します。Javaは1995年にSun Microsystems（現Oracle）によって発表され、現在も世界中で広く使用されている主要なプログラミング言語の1つです。

### Javaの誕生と基本思想

Javaは「Write Once, Run Anywhere（一度書けば、どこでも動く）」という革新的な思想のもとに設計されました。これは、Java仮想マシン（JVM）という実行環境上でプログラムを動作させることで実現されています。C言語のように特定のハードウェアやOSに依存せず、JVMさえあればWindows、macOS、Linuxなど、どの環境でも同じプログラムが動作します。

### Java仮想マシン（JVM）の主要な特徴

JVMは、Javaプログラムの実行環境として、従来のコンパイル型言語にはない革新的な機能を提供します。最も重要な特徴は**プラットフォーム独立性**です。JavaソースコードはJavaコンパイラによってバイトコードと呼ばれる中間言語に変換され、このバイトコードがJVM上で実行されます。これにより、OSやハードウェアの違いを意識することなく、同じプログラムをさまざまな環境で動作させることができます。

もう1つの重要な特徴は**自動メモリ管理**です。C言語では`malloc()`と`free()`を使って手動でメモリ管理を行う必要がありましたが、Javaではガベージコレクションというしくみにより、使用されなくなったメモリを自動的に解放します。これにより、メモリリークやダングリングポインタといった、C言語プログラミングで頻繁に遭遇する問題から解放されます。

さらに、JVMは**セキュリティ**の面でも優れています。サンドボックス環境と呼ばれる制限された実行環境により、悪意のあるコードがシステムに損害を与えることを防ぎます。また、**実行時最適化**も特筆すべき機能です。JIT（Just-In-Time）コンパイラは、プログラムの実行中に頻繁に使用される部分を検出し、それらをネイティブコードに変換することで、インタプリタ型言語の柔軟性とコンパイル型言語の高速性を両立させています。

### なぜJavaを学ぶのか

Javaは、その誕生から四半世紀以上が経過した現在でも、世界中で最も広く使用されているプログラミング言語の1つです。特に**企業システム開発**の分野では圧倒的な存在感を示しています。銀行のもと幹システム、保険会社の契約管理システム、政府機関の公共サービスシステムなど、私たちの生活を支える重要なインフラストラクチャの多くがJavaで構築されています。これは、Javaが提供する高い信頼性、拡張性、そして長期的なサポートが評価されているためです。

**Webアプリケーション開発**においても、Javaは主要な選択肢の1つです。Spring BootやJakarta EEといった成熟したフレームワークにより、複雑なビジネスロジックを含むWebアプリケーションを効率的に開発できます。また、**モバイル開発**の分野では、AndroidアプリケーションがJavaベースで開発されてきた歴史があり、現在でもKotlinと並んで重要な開発言語となっています。

さらに近年では、**ビッグデータ処理**の分野でもJavaの重要性が増しています。Apache HadoopやApache Sparkといった分散処理フレームワークの多くがJavaで実装されており、大規模データの処理・分析においてJavaの知識は不可欠となっています。

本章では、このような実践的な開発に必要なJavaの基本文法を、C言語との比較を交えながら体系的に学習していきます。

**より詳しい歴史や技術的背景について**：Javaの詳細な歴史、企業システムでの採用事例、オープンソース化の経緯などについては、付録B.01「言語設計とプラットフォーム」を参照してください。

## 2.1 Javaの特徴

Javaがこれほど長期にわたって広く使用されている理由は、言語設計における優れた特徴にあります。最も象徴的な特徴は**プラットフォーム独立性**であり、「Write Once, Run Anywhere（一度書けば、どこでも動く）」というスローガンに集約されています。この特徴により、Windows上で開発したプログラムを、再コンパイルすることなくLinuxやmacOSで実行できます。

Javaは純粋な**オブジェクト指向言語**として設計されています。すべてのコードはクラスの中に記述され、データと処理を一体化したオブジェクトとして扱います。この設計により、大規模なプログラムでも構造化された保守しやすいコードを書くことができます。

**ガベージコレクション**による自動メモリ管理は、プログラマを煩雑なメモリ管理から解放します。C言語でよく発生するメモリリークやセグメンテナンスーション違反といった問題を心配する必要がなくなり、ビジネスロジックの実装に集中できます。

また、Javaは**強い型付け**を採用しており、コンパイル時に多くのエラーを検出できます。これにより、実行時エラーを減らし、より信頼性の高いプログラムを作成できます。さらに、**豊富なライブラリ**エコシステムも大きな魅力です。標準ライブラリだけでなく、Apache Commons、Google Guava、Spring Frameworkなど、数多くの高品質なサードパーティライブラリが利用可能です。

## メモリ管理とガベージコレクション

Javaの最も重要な特徴の1つは、自動メモリ管理（ガベージコレクション）です。C言語ではプログラマがメモリの確保と解放を手動で行う必要がありましたが、Javaではこれを自動化することで、メモリリークやダングリングポインタなどの問題を防ぎます。

ガベージコレクションは世代別仮説にもとづいて効率的に動作し、現代のJVMではG1 GCやZGCなどの低遅延コレクタにより、大規模なアプリケーションでも実用的なパフォーマンスを実現しています。

**メモリ管理の詳細、GCアルゴリズム、パフォーマンスチューニングについては、付録B.02「メモリ管理とパフォーマンス」を参照してください。**

## 2.2 基本データ型

Javaのデータ型システムは、プログラムの安全性と効率性を両立させるよう慎重に設計されています。Javaには8つの基本データ型（プリミティブ型）があり、これらは数値、文字、真偽値を表現するための基本的な構成要素です。C言語と比較すると、型のサイズがプラットフォームに依存しないという重要な違いがあります。

### なぜ異なるサイズの整数型が必要なのか

実際のプログラミングでは、扱うデータの範囲と使用するメモリ量のトレードオフを考慮して適切な型を選択する必要があります。たとえば、人の年齢を表すのに`long`型（8バイト）を使うのは無駄ですし、逆に国の人口を`byte`型で表すことはできません。以下のコード例では、各基本データ型の宣言と、それぞれの実用的な使用場面を示します：

```java
// 整数型の使い分け例
byte age = 25;                    // 年齢（0〜127歳で十分）
short temperatureCelsius = -273;  // 温度（絶対零度から数千度まで）
int tokyoPopulation = 14000000;   // 東京都の人口（約1400万人）
long worldPopulation = 8000000000L; // 世界人口（約80億人、intでは表現不可）

// 浮動小数点型の使い分け例
float productPrice = 1980.50f;    // 商品価格（精度7桁で十分な場合）
double piValue = 3.14159265359;   // 円周率（高精度が必要な科学計算）

// その他の型の実用例
char grade = 'A';                 // 成績評価（A, B, C...）
boolean isStudent = true;         // 学生かどうかのフラグ
```

**実際の開発での型選択の指針**：
- **メモリ効率が重要な場合**：配列やコレクションで大量のデータを扱う場合は、適切な最小サイズの型を選択
- **計算精度が重要な場合**：金融計算では`BigDecimal`、科学計算では`double`を使用
- **可読性を優先する場合**：特別な理由がない限り、整数は`int`、小数は`double`を使用するのが一般的

**重要な違い（C言語との比較）**：
- `char`型は16ビット（Unicode対応）
- `boolean`型は`true`/`false`のみ（0/1ではない）
- 各型のサイズは環境によらず固定

## 2.3 変数の宣言と初期化

Javaでは、すべての変数は使用前に宣言する必要があり、型の明示が必須です。これはC言語と同様ですが、Javaはより厳格な初期化ルールを持っています。ローカル変数は明示的に初期化しないと使用できません。また、`final`キーワードを使用することで、一度だけ値を設定できる定数を作成できます。以下の例で、さまざまな変数宣言のパターンを示します：

```java
// 宣言と同時に初期化
int count = 0;
String message = "Hello";

// 宣言後に初期化
double price;
price = 100.0;

// 定数の宣言（finalキーワード）
final double PI = 3.14159265359;
```

## 2.4 演算子

Javaの演算子体系は、C言語の演算子をベースにしていますが、型安全性を高めるためのいくつかの重要な改良が加えられています。特に注目すべきは、論理演算子における短絡評価の明確な仕様化と、文字列連結演算子（`+`）のオーバーロードです。以下のコード例では、Javaで利用可能な主要な演算子とその動作を示します：

```java
// 算術演算子
int a = 10, b = 3;
int sum = a + b;      // 13
int diff = a - b;     // 7
int prod = a * b;     // 30
int quot = a / b;     // 3（整数除算）
int rem = a % b;      // 1（剰余）

// インクリメント・デクリメント
int x = 5;
int y = x++;  // y = 5, x = 6（後置）
int z = ++x;  // z = 7, x = 7（前置）

// 比較演算子
boolean result1 = (a > b);   // true
boolean result2 = (a == b);  // false
boolean result3 = (a != b);  // true

// 論理演算子
boolean p = true, q = false;
boolean and = p && q;        // false（短絡評価）
boolean or = p || q;         // true（短絡評価）
boolean not = !p;            // false

// ビット演算子
int m = 5;    // 0101
int n = 3;    // 0011
int bitAnd = m & n;  // 0001 = 1
int bitOr = m | n;   // 0111 = 7
int bitXor = m ^ n;  // 0110 = 6
```

## 2.5 型変換

Javaの型変換システムは、プログラムの安全性を保証するために厳格に設計されています。C言語では暗黙的に行われていた多くの型変換が、Javaでは明示的なキャストを要求されます。これは一見煩雑に思えるかもしれませんが、予期しないデータ損失やバグを防ぐ重要なしくみです。型変換には、データの精度を失わない拡たいへん換（widening conversion）と、精度を失う可能性がある縮小変換（narrowing conversion）があります：

```java
// 暗黙的な型変換（拡大変換）
int i = 100;
long l = i;        // OK: int → long
double d = i;      // OK: int → double

// 明示的な型変換（縮小変換）
double pi = 3.14159;
int truncated = (int) pi;  // 3（小数部分は切り捨て）

// 文字列との変換
String str = "123";
int num = Integer.parseInt(str);  // 文字列→整数
String str2 = String.valueOf(num);  // 整数→文字列
```

## 2.6 コンソール入出力

プログラムとユーザーの対話は、多くのアプリケーションにおいて基本的な要素です。Javaでは、標準入出力を扱うためのクラスが`java.lang`パッケージと`java.util`パッケージに用意されています。C言語の`printf()`や`scanf()`に相当する機能を、よりオブジェクト指向的な方法で実現しています。以下の例では、基本的な出力方法と、`Scanner`クラスを使用した入力処理を示します：

```java
import java.util.Scanner;

public class IOExample {
    public static void main(String[] args) {
        // 出力
        System.out.println("Hello, World!");
        System.out.print("改行なし");
        System.out.printf("書式付き出力: %d, %.2f%n", 10, 3.14159);
        
        // 入力
        Scanner scanner = new Scanner(System.in);
        System.out.print("名前を入力: ");
        String name = scanner.nextLine();
        System.out.print("年齢を入力: ");
        int age = scanner.nextInt();
        
        System.out.printf("%sさん（%d歳）、こんにちは！%n", name, age);
        scanner.close();
    }
}
```



次のパート：[Part B - 制御構造と配列](chapter02b-control-and-arrays.md)




<!-- Merged from chapter02b-control-and-arrays.md -->


## 2.12 制御構造

**事前説明：**
制御構造は、プログラムの流れ（フロー）を制御する基本的なしくみです。条件分岐と繰り返し処理により、プログラムに複雑な判断力と処理能力を与えることができます。Javaの制御構造は、C言語の優れた設計を継承しつつ、より安全で表現力豊かな機能を提供しています。

### 条件分岐

**事前説明：**
条件分岐は、プログラムが状況に応じて異なる処理を選択するしくみです。成績判定、ユーザー入力の検証、システム状態の確認など、実用的なプログラムには不可欠な機能です。

```java
// if文（C言語と同じ）
int score = 85;
if (score >= 90) {
    System.out.println("優");
} else if (score >= 80) {
    System.out.println("良");
} else if (score >= 70) {
    System.out.println("可");
} else {
    System.out.println("不可");
}

// switch文（Java 12以降の新記法も利用可能）
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**このコードで学習できる重要な概念：**

- **多段階条件分岐**：`else if`の連鎖により、複数の条件を順次評価できます。これは成績判定のような段階的評価に最適です。
- **論理的な条件設計**：条件を`score >= 90`から順番に書くことで、重複しない明確な判定ロジックを実現しています。
- **switch式の活用**：Java 12以降の新しいswitch式では、より簡潔で関数型プログラミングに近い記述が可能です。
- **複数ケースの同時処理**：`case 10, 9 ->`のように、複数の値に対して同じ処理を適用できます。
- **型安全な分岐**：条件式は必ず`boolean`型である必要があり、C言語のような整数による条件分岐は許可されません。

**新旧switch文の比較による学習ポイント：**

従来のswitch文：
```java
String grade;
switch (score / 10) {
    case 10:
    case 9:
        grade = "優";
        break;
    case 8:
        grade = "良";
        break;
    case 7:
        grade = "可";
        break;
    default:
        grade = "不可";
        break;
}
```

新しいswitch式：
```java
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**学習できる進化のポイント：**
- **fall-through問題の解決**：新しいswitch式では`break`文が不要で、意図しないfall-throughバグを防げます。
- **式としての利用**：switch文が値を返すことができるようになり、変数への代入が直接可能です。
- **簡潔な記述**：`->`記法により、コードがより読みやすく保守しやすくなります。

### 繰り返し処理

**事前説明：**
繰り返し処理（ループ）は、同じ処理を効率的に何度も実行するためのしくみです。配列の全要素を処理する、計算を指定回数繰り返す、条件が満たされるまで処理を続けるなど、プログラミングの基本的なパターンを実現します。Javaでは、用途に応じて3つの主要なループ構文を提供しています。

```java
// for文
for (int i = 0; i < 10; i++) {
    System.out.println("i = " + i);
}

// 拡張for文（foreach）
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// while文
int count = 0;
while (count < 5) {
    System.out.println("count = " + count);
    count++;
}
```

**このコードで学習できる重要な概念：**

- **for文の3つの要素**：初期化(`int i = 0`）、条件（`i < 10`）、更新（`i++`)の明確な分離により、ループの動作が理解しや少なっています。
- **拡張for文の利便性**：配列やコレクションの全要素を処理する際に、インデックス管理が不要で安全です。Java 5で導入されたこの機能により、配列操作のバグが大幅に減少しました。
- **while文の柔軟性**：条件が複雑な場合や、ループ回数が事前に決まらない場合に適しています。
- **ループ変数のスコープ**：for文内で宣言された変数`i`は、ループ内でのみ有効です。これにより名前空間の汚染を防げます。
- **配列との連携**：拡張for文では、配列の要素に直接アクセスでき、境界値エラー（IndexOutOfBoundsException）を防げます。

**各ループの使い分けの指針：**

- **for文**：繰り返し回数が明確で、カウンタ変数が必要な場合
- **拡張for文**：配列やコレクションの全要素を順次処理する場合
- **while文**：複雑な条件や、繰り返し回数が動的に決まる場合

**C言語との比較における重要なポイント：**
- 拡張for文はC言語にはない、Javaの重要な改良点です。
- ループ変数のスコープがより厳密に管理されています。
- 配列アクセスの安全性が大幅に向上しています。

## 2.13 配列

**事前説明：**
配列は、同じ型の複数のデータを効率的に管理するための基本的なデータ構造です。学生の成績管理、商品の在庫管理、数値計算など、プログラミングの多くの場面で配列が活用されます。Javaの配列は、C言語の配列の利便性を継承しつつ、境界チェックや自動初期化により安全性を大幅に向上させています。

```java
// 配列の宣言と初期化
int[] numbers = {1, 2, 3, 4, 5};

// または
int[] scores = new int[10];  // 10要素の配列
scores[0] = 100;
scores[1] = 95;

// 配列の長さ
System.out.println("配列の長さ: " + numbers.length);

// 多次元配列
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

**このコードで学習できる重要な概念：**

- **配列初期化の2つの方法**：リテラル初期化(`{1, 2, 3, 4, 5}`)と`new`キーワードによる動的作成の使い分けを理解できます。
- **オブジェクトとしての配列**：Javaの配列はオブジェクトであり、`length`プロパティなどの便利な機能を持っています。
- **境界チェックの自動実行**：配列の範囲外アクセスは`ArrayIndexOutOfBoundsException`として検出され、セグメンテーション違反のような深刻な問題を防げます。
- **自動初期化**：`new int[10]`で作成された配列の要素は自動的に0で初期化されます。これによりガベージ値による予期しない動作を防げます。
- **多次元配列の構造**：2次元配列は「配列の配列」として実装され、行列やテーブル形式のデータを直感的に表現できます。

**配列操作の実用例：**

```java
// 配列の全要素を処理する安全な方法
int[] data = {10, 20, 30, 40, 50};

// インデックスを使用した従来の方法
for (int i = 0; i < data.length; i++) {
    System.out.println("data[" + i + "] = " + data[i]);
}

// 拡張for文を使用した推奨方法
for (int value : data) {
    System.out.println("値: " + value);
}
```

**C言語との重要な違い：**

- **lengthプロパティ**：C言語では配列のサイズを別途管理する必要がありますが、Javaでは`array.length`で常に正確なサイズを取得できます。
- **境界チェック**：C言語では配列の範囲外アクセスがシステムクラッシュを引き起こす可能性がありますが、Javaでは例外として安全に処理されます。
- **メモリ管理**：配列のメモリ確保と解放はJVMが自動的に行うため、メモリリークやダングリングポインタの心配がありません。
- **初期化の保証**：Java配列の要素は必ず適切なデフォルト値で初期化されます（数値型は0、真偽値型はfalse、オブジェクト型はnull）。

### 配列操作の応用例

```java
// 配列の要素を検索する
public static int findElement(int[] array, int target) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == target) {
            return i;  // 見つかった位置を返す
        }
    }
    return -1;  // 見つからなかった
}

// 配列の要素を合計する
public static int sumArray(int[] array) {
    int sum = 0;
    for (int value : array) {
        sum += value;
    }
    return sum;
}

// 配列をコピーする
int[] original = {1, 2, 3, 4, 5};
int[] copy = new int[original.length];
System.arraycopy(original, 0, copy, 0, original.length);

// またはArraysクラスを使用
import java.util.Arrays;
int[] copy2 = Arrays.copyOf(original, original.length);
```

**配列使用時の注意点：**

1. **サイズの固定性**：一度作成した配列のサイズは変更できません。動的にサイズを変更したい場合は、後の章で学習する`ArrayList`などのコレクションを使用します。

2. **参照型としての配列**：配列は参照型ですので、配列変数の代入は参照のコピーになります：
```java
int[] a = {1, 2, 3};
int[] b = a;  // bはaと同じ配列を参照
b[0] = 100;   // a[0]も100になる
```

3. **多次元配列の柔軟性**：Javaの多次元配列は各行の長さが異なってもかまいません：
```java
int[][] jaggedArray = {
    {1, 2},
    {3, 4, 5, 6},
    {7}
};
```



次のパート：[Part C - メソッドと文字列処理](chapter02c-methods-and-strings.md)




<!-- Merged from chapter02c-methods-and-strings.md -->


## 2.14 メソッド（関数）

**事前説明：**
メソッド（関数）は、特定の処理をまとめて名前を付け、必要な時に呼び出して使用するしくみです。コードの再利用性を高め、プログラムの構造を整理し、保守性を向上させる重要な概念です。Javaのメソッドは、C言語の関数の概念を発展させ、オブジェクト指向プログラミングの基礎となる機能を提供しています。

```java
public class Calculator {
    // メソッドの定義
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double divide(double a, double b) {
        if (b == 0) {
            System.out.println("ゼロ除算エラー");
            return 0;
        }
        return a / b;
    }
    
    public static void main(String[] args) {
        int result = add(10, 5);
        System.out.println("結果: " + result);
        
        double divResult = divide(10.0, 3.0);
        System.out.println("除算結果: " + divResult);
    }
}
```

**このコードで学習できる重要な概念：**

- **メソッドシグネチャの構成**：`public static int add(int a, int b)`の各要素（アクセス修飾子、static修飾子、戻り値の型、メソッド名、パラメータ）の意味と役割を理解できます。
- **型安全なパラメータ渡し**：引数の型が明確に定義されており、コンパイル時に型の不整合を検出できます。
- **戻り値の型宣言**：メソッドが返す値の型を明示することで、呼び出し側で適切な変数で結果を受け取れます。
- **エラーハンドリングの実装**：ゼロ除算チェックにより、実行時エラーを防ぐ防御的プログラミングの手法を学習できます。
- **静的メソッドの特徴**：`static`修飾子により、オブジェクトの生成なしにメソッドを呼び出せる便利性を理解できます。

**メソッド設計の重要な原則：**

- **単一責任の原則**：`add`メソッドは加算のみ、`divide`メソッドは除算のみを担当し、1つのメソッドが1つの明確な役割を持っています。
- **再利用性の実現**：一度定義したメソッドは、プログラム内の任意の場所から何度でも呼びだすことができます。
- **デバッグの容易性**：問題が発生した場合、特定のメソッド内に原因を特定しやすくなります。
- **可読性の向上**：メソッド名により処理内容が明確になり、プログラムの意図が理解しやすくなります。

**高度なメソッド活用例：**

```java
// メソッドオーバーロードの例
public static int add(int a, int b) {
    return a + b;
}

public static double add(double a, double b) {
    return a + b;
}

public static int add(int a, int b, int c) {
    return a + b + c;
}
```

**C言語との比較における学習ポイント：**

- **クラス内での定義**：Javaのメソッドは必ずクラス内に定義される必要があり、グローバル関数は存在しません。
- **アクセス制御**：`public`、`private`などの修飾子により、メソッドの可視性を細かく制御できます。
- **オーバーロード機能**：同じ名前で異なるパラメータを持つメソッドを複数定義でき、利便性が向上します。
- **例外処理システム**：エラー処理がより構造化され、安全なプログラムの作成を支援します。

## 2.15 文字列処理

Javaにおける文字列処理は、C言語のアプローチとは根本的に異なる設計思想にもとづいています。C言語では文字列を文字の配列として扱い、終端文字（\0）で管理していましたが、Javaでは文字列を第一級のオブジェクトとして扱います。この設計により、文字列の長さの管理、メモリの確保と解放、バッファオーバーフローの防止など、C言語で頻繁に問題となっていた課題が根本的に解決されています。さらに、豊富な文字列操作メソッドが標準で提供され、複雑な文字列処理も簡潔かつ安全に実装できるようになりました。

### 文字列の基本

文字列オブジェクトの作成と基本操作は、Javaプログラミングにおいて最も頻繁に使用される機能の1つです。以下のコード例では、文字列の作成、連結、長さの取得、個別文字へのアクセスという基本的な操作を示します：

```java
// 文字列の作成
String str1 = "Hello";
String str2 = new String("World");

// 文字列の連結
String message = str1 + " " + str2;  // "Hello World"

// 文字列の長さ
int length = message.length();  // 11

// 文字の取得
char firstChar = message.charAt(0);  // 'H'
```

このコードで注目すべき重要な概念は、文字列リテラル（`"Hello"`）と`new`キーワードを使用した文字列作成の違いです。文字列リテラルはJVMが管理する文字列プールに格納され、同じ内容の文字列は共有されます。これは、メモリ効率とパフォーマンスの最適化のための重要なしくみです。一方、`new String()`は常に新しいオブジェクトを作成するため、通常は文字列リテラルの使用が推奨されます。

### 文字列の比較

文字列の比較は、Javaプログラミングで最も誤解されやすい概念の1つです。C言語では`strcmp()`関数を使用していましたが、Javaではオブジェクトの比較という観点から、より慎重なアプローチが必要です。以下のコード例で、参照の比較と内容の比較の重要な違いを示します：

```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");

// == は参照の比較（推奨されない）
boolean ref1 = (s1 == s2);    // true（文字列プール）
boolean ref2 = (s1 == s3);    // false

// equals() は内容の比較（推奨）
boolean content1 = s1.equals(s2);  // true
boolean content2 = s1.equals(s3);  // true

// 大文字小文字を無視した比較
boolean ignore = s1.equalsIgnoreCase("java");  // true
```

このコードは、Javaの文字列比較における重要な教訓を示しています。`==`演算子はオブジェクトの参照（メモリアドレス）を比較するため、文字列の内容が同じでも異なるオブジェクトであれば`false`を返します。特に注意すべきは、文字列プールの存在により`s1 == s2`が`true`となる点です。これは偶然の一致であり、信頼すべきではありません。常に`equals()`メソッドを使用して文字列の内容を比較することが、バグのない堅牢なプログラムを作成する鍵となります。

### 便利な文字列操作メソッド

Javaの`String`クラスは、テキスト処理に必要な豊富なメソッドを提供しています。これらのメソッドは、Web開発でのユーザー入力の処理、データベースから取得した文字列の整形、ファイルの読み書きなど、実際の開発で頻繁に使用されます。以下のコード例で、最も重要な文字列操作メソッドを実践的に学習します：

```java
String text = "  Java Programming  ";

// 空白の除去
String trimmed = text.trim();  // "Java Programming"

// 大文字・小文字変換
String upper = text.toUpperCase();  // "  JAVA PROGRAMMING  "
String lower = text.toLowerCase();  // "  java programming  "

// 部分文字列の取得
String sub = text.substring(2, 6);  // "Java"

// 文字列の置換
String replaced = text.replace("Java", "Python");  // "  Python Programming  "

// 文字列の分割
String csv = "apple,banana,orange";
String[] fruits = csv.split(",");  // ["apple", "banana", "orange"]

// 文字列の検索
int index = text.indexOf("Pro");  // 7
boolean contains = text.contains("Java");  // true
```

これらのメソッドは、単なる文字列操作の道具ではなく、実際のビジネスロジックを実装する上で不可欠な要素です。`trim()`メソッドはユーザー入力の前後の空白を除去してデータの一貫性を保ち、`split()`メソッドはCSVファイルの解析や構造化データの処理に使用されます。`indexOf()`と`contains()`は検索機能の実装に欠かせず、`replace()`はテンプレート処理やデータのサニタイゼーションで活用されます。重要なのは、これらすべてのメソッドが元の文字列を変更せず、新しい文字列を返すという点です。

### 文字列の不変性（Immutability）

Javaの文字列設計における最も重要な特徴の1つが不変性（Immutability）です。この設計思想は、最初は直感に反するように感じるかもしれませんが、スレッドセーフティ、セキュリティ、パフォーマンスの観点から極めて重要な役割を果たしています。文字列が不変であることにより、複数のスレッドが同じ文字列オブジェクトを安全に共有でき、予期しない変更によるバグを防ぐことができます。以下のコード例で、この重要な概念を実際に確認してみましょう：

```java
String str = "Hello";
str.concat(" World");  // str自体は変更されない
System.out.println(str);  // "Hello"

// 新しい文字列を作成して代入する必要がある
str = str.concat(" World");
System.out.println(str);  // "Hello World"
```

このコードは、`concat()`メソッドを呼び出しても元の文字列オブジェクトが変更されないことを示しています。これは、C言語の`strcat()`関数とは根本的に異なる動作です。Javaでは、文字列操作メソッドは常に新しい文字列オブジェクトを返し、元のオブジェクトはそのまま保持されます。この設計により、文字列を辞書のキーやハッシュマップのキーとして安全に使用でき、文字列プールによる最適化も可能になっています。

### StringBuilderによる効率的な文字列操作

文字列の不変性は多くの利点をもたらしますが、頻繁な文字列操作が必要な場合にはパフォーマンスの問題を引き起こす可能性があります。なぜなら、文字列を連結するたびに新しいオブジェクトが作成され、古いオブジェクトはガベージコレクションの対象となるからです。この問題を解決するために、Javaは`StringBuilder`クラスを提供しています。`StringBuilder`は内部にmuテーブルな（変更可能な）文字配列を持ち、効率的な文字列操作を可能にします：

```java
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(" ");
sb.append("World");
sb.insert(5, ",");  // "Hello, World"
sb.reverse();       // "dlroW ,olleH"

String result = sb.toString();
```

このコードは、`StringBuilder`の威力を示しています。`append()`メソッドは既存の内容に文字列を追加し、`insert()`は指定位置に文字列を挿入し、`reverse()`は文字列全体を反転させます。これらの操作はすべて同じオブジェクト上で行われるため、メモリ効率が大幅に向上します。

`StringBuilder`を使用すべき典型的な場面は、ループ内での文字列連結です。たとえば、1000個の要素を連結する場合、通常の文字列連結では約50万個の一時オブジェクトが作成される可能性がありますが、`StringBuilder`を使用すれば、最小限のオブジェクト作成で済みます。また、ログファイルの生成、SQLクエリの動的構築、HTMLやXMLの生成など、大量の文字列操作を伴う処理でも`StringBuilder`は不可欠です。ただし、単純な文字列連結や、変更頻度の低い場合は、可読性の観点から通常の文字列操作を使用することが推奨されます。

## Java基本文法の総合的な理解

本章で学習した各要素は、独立したテクニックではなく、現代のソフトウェア開発における包括的な設計哲学の一部です。出力メソッドから始まり、データ型、変数、演算子、制御構造、配列、メソッドまで、すべてがJavaの「安全性」「保守性」「可読性」という3つの核心原則にもとづいて設計されています。

**学習した内容の相互関係と実践への応用：**

- **型安全性の一貫した実装**：`System.out.println`による自動型変換、明示的な変数宣言、メソッドのシグネチャ、配列の境界チェックなど、すべての機能が型の整合性を保証しています。
- **オブジェクト指向への基盤構築**：staticメソッド、クラス内でのメソッド定義、String型の活用など、本章で学んだ要素はすべて次章以降のオブジェクト指向学習への準備となっています。
- **C言語からの進化の理解**：単なる機能追加ではなく、ソフトウェア開発の課題（メモリ管理、プラットフォーム依存性、保守性）を根本的に解決するための設計思想の変革を体験できました。

**現代的なプログラミング手法への接続：**

今回学習した基本文法は、フレームワーク開発、Webアプリケーション構築、マイクロサービスアーキテクチャ、クラウドネイティブ開発など、現代のあらゆるJava開発の基盤となります。型安全性、例外処理、適切なメソッド設計などの概念は、企業での実際の開発において直接活用される重要なスキルです。



次のパート：[Part D - クラスとオブジェクトの基礎](chapter02d-class-basics.md)




<!-- Merged from chapter02d-class-basics.md -->


## クラスとオブジェクトの基本

章末の練習課題に取り組む前に、Javaプログラミングの核心であるクラスとオブジェクトの基本的な概念と構文を理解しておきましょう。これらの概念は、オブジェクト指向プログラミングの基盤となる重要な要素です。

### クラスの基本構造

Javaプログラミングにおいて、すべてのコードはクラスという単位で記述されます。クラスをしばしば「設計図」にたとえることがありますが、これは建築における設計図と同じように、実際の建物（オブジェクト）を作るための詳細な仕様を定義するからです。1つの設計図から同じ構造を持つ複数の建物を建ていることができるように、1つのクラスから同じ構造を持つ複数のオブジェクトを作成できます。この関係性を理解することが、オブジェクト指向プログラミングの第一歩となります。

#### 基本的なクラスの定義

以下のコード例では、人物を表現する`Person`クラスを定義しています。このクラスは、実世界の「人」という概念をプログラムで表現するための構造を提供します：

```java
public class Person {
    // フィールド（インスタンス変数）
    private String name;
    private int age;
    
    // コンストラクタ
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // メソッド（振る舞い）
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void introduce() {
        System.out.println("こんにちは、" + name + "です。" + age + "歳です。");
    }
}
```

### クラスの構成要素

#### 1. フィールド（インスタンス変数）

オブジェクトが持つデータを格納する変数です：

```java
private String name;    // 文字列を格納
private int age;        // 整数を格納
private double height;  // 小数を格納
```

フィールドの設計において最も重要な原則は、カプセル化です。`private`修飾子を使用することで、フィールドへの直接アクセスを防ぎ、データの整合性を保護します。これは単なる慣習ではなく、予期しない値の変更によるバグを防ぐための重要な防御機構です。また、各オブジェクトは独自のフィールド値を持つため、同じクラスから作成された複数のオブジェクトが、それぞれ異なる状態を維持できます。

#### 2. コンストラクタ

オブジェクトを作成する際に呼び出される特別なメソッドです：

```java
public Person(String name, int age) {
    this.name = name;  // パラメータの値をフィールドに設定
    this.age = age;
}
```

コンストラクタには、通常のメソッドとは異なる特別な規則があります。まず、コンストラクタの名前は必ずクラス名と完全に一致させる必要があります。これにより、Javaコンパイラはこのメソッドがコンストラクタであることを認識します。また、コンストラクタは戻り値を持たないため、戻り値の型を宣言しません（`void`も書きません）。`this`キーワードは現在のオブジェクトを参照し、パラメータ名とフィールド名が同じ場合に、どちらを指しているかを明確にするために使用されます。

#### 3. メソッド

オブジェクトの振る舞いを定義します：

```java
// 値を返すメソッド
public String getName() {
    return name;
}

// 処理を実行するメソッド
public void introduce() {
    System.out.println("こんにちは、" + name + "です。");
}
```

### オブジェクトの作成と使用

#### オブジェクトの作成

```java
public class Main {
    public static void main(String[] args) {
        // newキーワードでオブジェクトを作成
        Person person1 = new Person("田中太郎", 25);
        Person person2 = new Person("佐藤花子", 30);
        
        // メソッドを呼び出す
        person1.introduce();  // こんにちは、田中太郎です。25歳です。
        person2.introduce();  // こんにちは、佐藤花子です。30歳です。
        
        // getter メソッドで値を取得
        String name1 = person1.getName();
        System.out.println("名前: " + name1);
    }
}
```

### 実践的な例：銀行口座クラス

より実用的な例として、銀行口座を表すクラスを見てみましょう。これは第3章と第4章でさらに詳しく学習するカプセル化の基礎となる例です：

```java
public class BankAccount {
    // フィールド
    private String accountNumber;
    private String ownerName;
    private double balance;
    
    // コンストラクタ
    public BankAccount(String accountNumber, String ownerName) {
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.balance = 0.0;  // 初期残高は0
    }
    
    // 入金メソッド
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println(amount + "円を入金しました。");
        } else {
            System.out.println("入金額が不正です。");
        }
    }
    
    // 出金メソッド
    public boolean withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println(amount + "円を出金しました。");
            return true;
        } else {
            System.out.println("出金できません。");
            return false;
        }
    }
    
    // 残高照会メソッド
    public double getBalance() {
        return balance;
    }
    
    // 口座情報表示メソッド
    public void displayInfo() {
        System.out.println("口座番号: " + accountNumber);
        System.out.println("名義人: " + ownerName);
        System.out.println("残高: " + balance + "円");
    }
}
```

使用例：

```java
public class BankExample {
    public static void main(String[] args) {
        // 口座を作成
        BankAccount account = new BankAccount("12345678", "山田太郎");
        
        // 操作を実行
        account.deposit(10000);     // 10000円を入金しました。
        account.withdraw(3000);     // 3000円を出金しました。
        account.displayInfo();      // 口座情報を表示
        
        // 残高: 7000円
    }
}
```

### クラス設計の重要な概念

#### 1. カプセル化

データ（フィールド）を`private`にして外部から直接アクセスできないようにし、メソッドを通じてのみアクセスを許可する設計パターン：

```java
// 悪い例（カプセル化されていない）
public class BadExample {
    public double balance;  // 外部から直接変更可能
}

// 良い例（カプセル化されている）
public class GoodExample {
    private double balance;  // 外部から直接アクセス不可
    
    public double getBalance() {
        return balance;
    }
    
    public void setBalance(double balance) {
        if (balance >= 0) {  // 検証ロジック
            this.balance = balance;
        }
    }
}
```

#### 2. 情報隠蔽

クラスの内部実装を隠し、必要なインターフェイスのみを公開する原則：

```java
public class Calculator {
    // 内部的な計算方法は隠蔽
    private double internalCalculation(double a, double b) {
        // 複雑な計算ロジック
        return a * b * 0.95;
    }
    
    // 公開インターフェース
    public double calculate(double a, double b) {
        return internalCalculation(a, b);
    }
}
```

### アクセス修飾子

Javaには4つのアクセスレベルがあります：

| 修飾子 | 同じクラス | 同じパッケージ | サブクラス | すべて |
|--------|-----------|---------------|-----------|---------|
| private | ○ | × | × | × |
| (なし) | ○ | ○ | × | × |
| protected | ○ | ○ | ○ | × |
| public | ○ | ○ | ○ | ○ |

### staticキーワード

`static`を付けることで、クラスレベルのメンバー（クラス変数・クラスメソッド）を定義できます：

```java
public class MathUtils {
    // クラス変数
    public static final double PI = 3.14159265359;
    
    // クラスメソッド
    public static double circleArea(double radius) {
        return PI * radius * radius;
    }
}

// 使用例（インスタンス化不要）
double area = MathUtils.circleArea(5.0);
```

### まとめ

本節で学習したクラスとオブジェクトの概念は、Javaプログラミングの基礎を形成する重要な要素です。クラスは、関連するデータ（フィールド）と操作（メソッド）を1つの単位にまとめた設計図として機能します。この設計図から作成されるオブジェクトは、それぞれが独立した状態を持つ実体となります。

フィールドはオブジェクトの状態を表現し、メソッドはその状態に対する操作を定義します。コンストラクタは、オブジェクトが作成される際に適切な初期状態を設定する重要な役割を担います。そして、カプセル化の原則により、オブジェクトの内部状態を保護し、制御された方法でのみアクセスを許可することで、プログラムの安全性と保守性を高めています。

これらの概念は、単なる文法上の規則ではなく、現実世界の複雑な問題をプログラムで表現するための強力な道具です。銀行口座の例で見たように、実世界の概念（口座、入金、出金）をクラスとして適切にモデル化することで、理解しやすく保守しやすいプログラムを作成できます。次章以降では、これらの基本概念をさらに発展させ、継承やポリモーフィズムといった高度なオブジェクト指向の概念を学習していきます。



次のパート：[Part E - 章末演習](chapter02e-exercises.md)




<!-- Merged from chapter02e-exercises.md -->


## 実践演習課題

本章で学習した内容を定着させるため、段階的な演習課題に取り組みましょう。各課題は、実用的な場面を想定して設計されています。

### 基礎演習 2-1：データ型と変数
**目標**：Java基本データ型の理解と活用

**課題内容**：
学生情報管理の基礎プログラムを作成してください。
- 学生ID（整数）
- 学生名（文字列）
- 身長（小数点）
- 在学中フラグ（真偽値）

**技術的背景：型システムの重要性とJavaのデータ型設計**

プログラミング言語における型システムは、データの安全性と効率性を保証する重要なしくみです：

**C言語との型システムの違い：**
```c
// C言語：暗黙的な型変換が頻繁に発生
int i = 3.14;  // 警告は出るが、コンパイル可能（3になる）
char c = 1000; // オーバーフローしても実行される
```

```java
// Java：厳格な型チェック
int i = 3.14;  // コンパイルエラー：型の不一致
char c = 1000; // 正常（charは16ビット、0-65535）
```

**Javaの基本データ型の設計思想：**
- **明確なサイズ規定**：プラットフォーム独立性のため
  - int: 必ず32ビット（C言語では環境依存）
  - long: 必ず64ビット
- **boolean型の独立**：C言語の0/1ではなく専用型
- **charの16ビット化**：Unicode対応（日本語も一文字1char）

**実世界での型選択の重要性：**
- **金融システム**：BigDecimalで正確な金額計算
- **科学計算**：doubleで高精度計算
- **Webアプリケーション**：Stringで安全な文字列処理
- **組み込み**：byteで省メモリ

**メモリ効率と型選択：**
```java
// 100万人の年齢を保存する場合
byte[] ages = new byte[1_000_000];  // 1MB
int[] ages = new int[1_000_000];    // 4MB（4倍のメモリ）
```

この演習では、適切な型選択による安全で効率的なプログラミングを学びます。

**実装要件**：
- 各データ型の変数を適切に宣言・初期化する
- 標準入力から値を受け取り、変数に格納する
- すべての情報を整理して出力する

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切なデータ型の選択 |
| 変数の命名規則の遵守 |
| 入力・出力処理の正確な実装 |

### 応用演習 2-2：制御構造の活用
**目標**：条件分岐と繰り返し処理の実践

**課題内容**：
学生の成績判定プログラムを作成してください。
- 5科目の点数を入力として受け取る
- 各科目の合格/不合格を判定（60点以上で合格）
- 平均点を計算する
- 総合判定（全科目合格で卒業認定）を出力する

**技術的背景：制御構造の進化と現代的な使い方**

制御構造は、プログラムの流れを決定する基本要素です。Javaの制御構造はC言語を基礎としながら、より安全で表現力豊かになっています：

**条件分岐の進化：**
```java
// Java 14以降：switch式（より安全で簡潔）
String grade = switch (score / 10) {
    case 10, 9 -> "S";
    case 8 -> "A";
    case 7 -> "B";
    case 6 -> "C";
    default -> "F";
};
// break忘れによるfall-throughバグを防止
```

**繰り返し処理の使い分け：**
- **for文**：回数が明確な場合（配列走査、カウント処理）
- **while文**：条件が明確な場合（ユーザー入力待ち）
- **拡張for文**：コレクション全体の処理（Java 5以降）
- **Stream API**：関数型スタイル（Java 8以降）

**実際の教育システムでの応用：**
- **大学の成績管理**：GPA計算、単位認定
- **資格試験システム**：合格基準の複雑な判定
- **e-ラーニング**：進捗管理、適応的学習

**パフォーマンスの考慮：**
```java
// 非効率：ループ内で毎回条件評価
for (int i = 0; i < list.size(); i++) { }

// 効率的：サイズを事前に取得
int size = list.size();
for (int i = 0; i < size; i++) { }
```

**論理演算子の短絡評価：**
```java
// &&は左がfalseなら右を評価しない（短絡評価）
if (student != null && student.getScore() > 60) { }
// nullチェックが先に行われるため安全
```

この演習では、効率的で読みやすい制御構造の実装を学びます。

**実装要件**：
- 繰り返し処理で5科目の点数を効率的に入力
- 条件分岐で合格判定を実装
- 論理演算子を使用して総合判定を実装

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切な条件分岐の使用 |
| 繰り返し処理による効率的な実装 |
| 論理演算子の適切な使用 |

### 実践演習 2-3：配列を使った数値処理
**目標**：配列とアルゴリズムの基本的な組み合わせ

**課題内容**：
数値データ分析プログラムを作成してください。
- 10個の数値を配列に格納
- 最大値、最小値、平均値を計算
- 数値を昇順にソート
- 特定の値の検索機能

**技術的背景：配列とアルゴリズムの基礎**

配列は最も基本的なデータ構造であり、多くのアルゴリズムの基礎となります：

**Javaの配列の特徴：**
```java
// C言語：配列は単なるメモリ領域
int arr[10];  // サイズ情報なし
int size = sizeof(arr) / sizeof(int);

// Java：配列はオブジェクト
int[] arr = new int[10];
int size = arr.length;  // サイズ情報を保持
// 境界チェック付き（ArrayIndexOutOfBoundsException）
```

**基本的なアルゴリズムの計算量：**
| アルゴリズム | 時間計算量 | 用途 |
|------------|-----------|------|
| 線形探索 | O(n) | 未ソートデータ |
| 二分探索 | O(log n) | ソート済みデータ |
| バブルソート | O(n²) | 教育用 |
| クイックソート | O(n log n) | 実用的 |

**実世界でのデータ分析応用：**
- **株価分析**：移動平均、ボラティリティ計算
- **気象データ**：最高/最低気温、平均降水量
- **成績分析**：偏差値計算、順位付け
- **センサデータ**：異常値検出、トレンド分析

**メモリ効率とキャッシュ最適化：**
```java
// キャッシュフレンドリー：連続アクセス
for (int i = 0; i < arr.length; i++) {
    sum += arr[i];
}

// キャッシュ非効率：ランダムアクセス
for (int i = 0; i < arr.length; i++) {
    sum += arr[random.nextInt(arr.length)];
}
```

**Java標準ライブラリの活用：**
```java
// 実務では標準ライブラリを使用
Arrays.sort(arr);  // 高速なDual-Pivot Quicksort
int index = Arrays.binarySearch(arr, target);
```

この演習では、アルゴリズムの基礎を実装しながら、効率性の重要性を学びます。

**実装要件**：
- 配列の適切な初期化と操作
- ソートアルゴリズムの実装（バブルソートなど）
- 線形検索アルゴリズムの実装

**評価ポイント**：

| 評価項目 |
| :--- |
| 配列操作の正確な実装 |
| アルゴリズムの論理的な構成 |
| エラー処理の考慮 |

**拡張課題**：
- ユーザーが配列サイズを指定できるようにする
- 統計情報（中央値、標準偏差）の計算を追加

### 発展演習 2-4：総合プログラム
**目標**：第2章の全要素を統合した実用的なプログラム

**課題内容**：
簡易家計簿プログラムを作成してください。
- 支出項目と金額の入力
- カテゴリ別集計（食費、交通費、娯楽費など）
- 月間予算との比較
- 支出レポートの表示

**技術的背景：実用的なアプリケーション設計の基礎**

実用的なプログラムを作成する際は、単なる機能実装だけでなく、ユーザビリティと保守性を考慮する必要があります：

**家計簿アプリケーションの設計パターン：**
```java
// データ構造の設計例
// 方法1：並列配列（シンプルだが拡張性に欠ける）
String[] categories = {"食費", "交通費", "娯楽費"};
int[] expenses = new int[3];

// 方法2：二次元配列（より柔軟）
String[][] expenseData = new String[100][3]; // [日付, カテゴリ, 金額]

// 将来的にはオブジェクト指向で
class Expense {
    LocalDate date;
    String category;
    int amount;
}
```

**実際の家計簿アプリケーションの機能：**
- **マネーフォワード**：自動カテゴリ分類、銀行連携
- **Zaim**：レシート撮影、予算アラート
- **家計簿アプリケーション**：グラフ表示、家族共有

**ユーザビリティの考慮点：**
- **入力の簡便性**：頻出項目の記憶、予測入力
- **エラー処理**：負の金額、文字入力への対応
- **データ永続化**：ファイル保存（次章以降）
- **視覚的表現**：棒グラフ、円グラフ（GUI編）

**メソッド分割の重要性：**
```java
// 悪い例：main メソッドに全て記述
public static void main(String[] args) {
    // 500行のコード...
}

// 良い例：機能ごとにメソッド分割
public static void main(String[] args) {
    showMenu();
    processUserChoice();
}

private static void inputExpense() { }
private static void showReport() { }
private static void compareWithBudget() { }
```

**拡張性を考慮した設計：**
- **カテゴリの追加**：固定配列より動的な構造
- **期間指定**：日別、週別、月別集計
- **複数通貨対応**：為替レート考慮
- **データ分析**：支出傾向、節約提案

この演習では、実用的なプログラムの設計と実装の基礎を学びます。

**実装要件**：
- 複数のメソッドに機能を分割
- 配列または多次元配列でデータ管理
- メニュー形式のユーザーインターフェイス
- 基本的な入力検証

**評価ポイント**：

| 評価項目 |
| :--- |
| 適切なメソッド設計 |
| データ構造の効率的な活用 |
| ユーザビリティの考慮 |
| コードの可読性と保守性 |

### セルフチェック課題

各演習完了後、以下の項目で自己評価を行ってください：

**技能確認チェック**

| チェック項目 |
| :--- |
| エラーなしでコンパイル・実行できる |
| 意図した動作が正確に実行される |
| C言語との違いを説明できる |
| コードに適切なコメントが記述されている |

**理解度確認チェック**

| チェック項目 |
| :--- |
| 使用したJava文法要素の役割を説明できる |
| 他の問題に応用できる自信がある |
| より良い実装方法を考えることができる |

### 発展的な学習課題

さらなるスキル向上を目指す方は、以下の課題にも挑戦してみてください：

1. **アルゴリズム実装課題**：
   - クイックソート、マージソートの実装
   - 二分探索アルゴリズムの実装
   - 数学的計算（階乗、フィボナッチ数列）

2. **文字列処理課題**：
   - 文字列の逆順変換
   - 単語カウント機能
   - 簡単な暗号化・復号

3. **データ構造課題**：
   - 2次元配列を使った表計算
   - ゲーム盤（オセロ、三目並べ）の実装
   - 簡単な画像処理（ASCIIアート）

## 解答例とヒント

### 基礎演習 2-1 の解答例

```java
import java.util.Scanner;

public class StudentInfo {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // 変数の宣言
        int studentId;
        String studentName;
        double height;
        boolean isEnrolled;
        
        // 入力処理
        System.out.print("学生IDを入力してください: ");
        studentId = scanner.nextInt();
        scanner.nextLine(); // 改行文字を消費
        
        System.out.print("学生名を入力してください: ");
        studentName = scanner.nextLine();
        
        System.out.print("身長を入力してください(cm): ");
        height = scanner.nextDouble();
        
        System.out.print("在学中ですか？(true/false): ");
        isEnrolled = scanner.nextBoolean();
        
        // 出力処理
        System.out.println("\n=== 学生情報 ===");
        System.out.println("学生ID: " + studentId);
        System.out.println("氏名: " + studentName);
        System.out.println("身長: " + height + "cm");
        System.out.println("在学状況: " + (isEnrolled ? "在学中" : "卒業/退学"));
        
        scanner.close();
    }
}
```

### 実装のポイント

1. **Scanner使用時の注意**：
   - `nextInt()`の後に`nextLine()`を使う場合は、改行文字を消費する必要がある
   - リソースリークを防ぐため、最後に`close()`を呼ぶ

2. **三項演算子の活用**：
   - `isEnrolled ? "在学中" : "卒業/退学"`で簡潔な条件分岐

3. **適切な型の選択**：
   - 学生IDは整数型（int）
   - 身長は小数を含むため浮動小数点型（double）

### 課題に取り組む際のアドバイス

1. **段階的な実装**：
   - まず基本機能を実装してから、徐々に機能を追加
   - 各機能が正しく動作することを確認してから次へ進む

2. **エラー処理の考慮**：
   - ユーザーが不正な入力をした場合の対処を考える
   - try-catch文の使用（後の章で詳しく学習）

3. **コードの整理**：
   - 適切なインデント
   - 意味のある変数名
   - 必要に応じたコメントの追加

4. **テストの重要性**：
   - 正常なケースだけでなく、異常なケースもテスト
   - 境界値（最大値、最小値、0など）のテスト

これらの演習を通じて、Javaの基本文法を実践的に習得し、より複雑なプログラムを作成する基礎を築いてください。次章では、これらの基礎知識をもとに、オブジェクト指向プログラミングの本格的な学習に進みます。



