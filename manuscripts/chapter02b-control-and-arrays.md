# 第2章 Java基本文法 - Part B: 制御構造と配列

## 2.12 制御構造

**事前説明：**
制御構造は、プログラムの流れ（フロー）を制御する基本的なしくみです。条件分岐と繰り返し処理により、プログラムに複雑な判断力と処理能力を与えることができます。Javaの制御構造は、C言語の優れた設計を継承しつつ、より安全で表現力豊かな機能を提供しています。

### 条件分岐

**事前説明：**
条件分岐は、プログラムが状況に応じて異なる処理を選択するしくみです。成績判定、ユーザー入力の検証、システム状態の確認など、実用的なプログラムには不可欠な機能です。

```java
// if文（C言語と同じ）
int score = 85;
if (score >= 90) {
    System.out.println("優");
} else if (score >= 80) {
    System.out.println("良");
} else if (score >= 70) {
    System.out.println("可");
} else {
    System.out.println("不可");
}

// switch文（Java 12以降の新記法も利用可能）
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**このコードで学習できる重要な概念：**

- **多段階条件分岐**：`else if`の連鎖により、複数の条件を順次評価できます。これは成績判定のような段階的評価に最適です。
- **論理的な条件設計**：条件を`score >= 90`から順番に書くことで、重複しない明確な判定ロジックを実現しています。
- **switch式の活用**：Java 12以降の新しいswitch式では、より簡潔で関数型プログラミングに近い記述が可能です。
- **複数ケースの同時処理**：`case 10, 9 ->`のように、複数の値に対して同じ処理を適用できます。
- **型安全な分岐**：条件式は必ず`boolean`型である必要があり、C言語のような整数による条件分岐は許可されません。

**新旧switch文の比較による学習ポイント：**

従来のswitch文：
```java
String grade;
switch (score / 10) {
    case 10:
    case 9:
        grade = "優";
        break;
    case 8:
        grade = "良";
        break;
    case 7:
        grade = "可";
        break;
    default:
        grade = "不可";
        break;
}
```

新しいswitch式：
```java
String grade = switch (score / 10) {
    case 10, 9 -> "優";
    case 8 -> "良";
    case 7 -> "可";
    default -> "不可";
};
```

**学習できる進化のポイント：**
- **fall-through問題の解決**：新しいswitch式では`break`文が不要で、意図しないfall-throughバグを防げます。
- **式としての利用**：switch文が値を返すことができるようになり、変数への代入が直接可能です。
- **簡潔な記述**：`->`記法により、コードがより読みやすく保守しやすくなります。

### 繰り返し処理

**事前説明：**
繰り返し処理（ループ）は、同じ処理を効率的に何度も実行するためのしくみです。配列の全要素を処理する、計算を指定回数繰り返す、条件が満たされるまで処理を続けるなど、プログラミングの基本的なパターンを実現します。Javaでは、用途に応じて3つの主要なループ構文を提供しています。

```java
// for文
for (int i = 0; i < 10; i++) {
    System.out.println("i = " + i);
}

// 拡張for文（foreach）
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// while文
int count = 0;
while (count < 5) {
    System.out.println("count = " + count);
    count++;
}
```

**このコードで学習できる重要な概念：**

- **for文の3つの要素**：初期化(`int i = 0`）、条件（`i < 10`）、更新（`i++`)の明確な分離により、ループの動作が理解しやすくなっています。
- **拡張for文の利便性**：配列やコレクションの全要素を処理する際に、インデックス管理が不要で安全です。Java 5で導入されたこの機能により、配列操作のバグが大幅に減少しました。
- **while文の柔軟性**：条件が複雑な場合や、ループ回数が事前に決まらない場合に適しています。
- **ループ変数のスコープ**：for文内で宣言された変数`i`は、ループ内でのみ有効です。これにより名前空間の汚染を防げます。
- **配列との連携**：拡張for文では、配列の要素に直接アクセスでき、境界値エラー（IndexOutOfBoundsException）を防げます。

**各ループの使い分けの指針：**

- **for文**：繰り返し回数が明確で、カウンタ変数が必要な場合
- **拡張for文**：配列やコレクションの全要素を順次処理する場合
- **while文**：複雑な条件や、繰り返し回数が動的に決まる場合

**C言語との比較における重要なポイント：**
- 拡張for文はC言語にはない、Javaの重要な改良点です。
- ループ変数のスコープがより厳密に管理されています。
- 配列アクセスの安全性が大幅に向上しています。

## 2.13 配列

**事前説明：**
配列は、同じ型の複数のデータを効率的に管理するための基本的なデータ構造です。学生の成績管理、商品の在庫管理、数値計算など、プログラミングの多くの場面で配列が活用されます。Javaの配列は、C言語の配列の利便性を継承しつつ、境界チェックや自動初期化により安全性を大幅に向上させています。

```java
// 配列の宣言と初期化
int[] numbers = {1, 2, 3, 4, 5};

// または
int[] scores = new int[10];  // 10要素の配列
scores[0] = 100;
scores[1] = 95;

// 配列の長さ
System.out.println("配列の長さ: " + numbers.length);

// 多次元配列
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

**このコードで学習できる重要な概念：**

- **配列初期化の2つの方法**：リテラル初期化(`{1, 2, 3, 4, 5}`)と`new`キーワードによる動的作成の使い分けを理解できます。
- **オブジェクトとしての配列**：Javaの配列はオブジェクトであり、`length`プロパティなどの便利な機能を持っています。
- **境界チェックの自動実行**：配列の範囲外アクセスは`ArrayIndexOutOfBoundsException`として検出され、セグメンテーション違反のような深刻な問題を防げます。
- **自動初期化**：`new int[10]`で作成された配列の要素は自動的に0で初期化されます。これによりガベージ値による予期しない動作を防げます。
- **多次元配列の構造**：2次元配列は「配列の配列」として実装され、行列やテーブル形式のデータを直感的に表現できます。

**配列操作の実用例：**

```java
// 配列の全要素を処理する安全な方法
int[] data = {10, 20, 30, 40, 50};

// インデックスを使用した従来の方法
for (int i = 0; i < data.length; i++) {
    System.out.println("data[" + i + "] = " + data[i]);
}

// 拡張for文を使用した推奨方法
for (int value : data) {
    System.out.println("値: " + value);
}
```

**C言語との重要な違い：**

- **lengthプロパティ**：C言語では配列のサイズを別途管理する必要がありますが、Javaでは`array.length`で常に正確なサイズを取得できます。
- **境界チェック**：C言語では配列の範囲外アクセスがシステムクラッシュを引き起こす可能性がありますが、Javaでは例外として安全に処理されます。
- **メモリ管理**：配列のメモリ確保と解放はJVMが自動的に行うため、メモリリークやダングリングポインタの心配がありません。
- **初期化の保証**：Java配列の要素は必ず適切なデフォルト値で初期化されます（数値型は0、真偽値型はfalse、オブジェクト型はnull）。

### 配列操作の応用例

```java
// 配列の要素を検索する
public static int findElement(int[] array, int target) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == target) {
            return i;  // 見つかった位置を返す
        }
    }
    return -1;  // 見つからなかった
}

// 配列の要素を合計する
public static int sumArray(int[] array) {
    int sum = 0;
    for (int value : array) {
        sum += value;
    }
    return sum;
}

// 配列をコピーする
int[] original = {1, 2, 3, 4, 5};
int[] copy = new int[original.length];
System.arraycopy(original, 0, copy, 0, original.length);

// またはArraysクラスを使用
import java.util.Arrays;
int[] copy2 = Arrays.copyOf(original, original.length);
```

**配列使用時の注意点：**

1. **サイズの固定性**：一度作成した配列のサイズは変更できません。動的にサイズを変更したい場合は、後の章で学習する`ArrayList`などのコレクションを使用します。

2. **参照型としての配列**：配列は参照型なので、配列変数の代入は参照のコピーになります：
```java
int[] a = {1, 2, 3};
int[] b = a;  // bはaと同じ配列を参照
b[0] = 100;   // a[0]も100になる
```

3. **多次元配列の柔軟性**：Javaの多次元配列は各行の長さが異なっても構いません：
```java
int[][] jaggedArray = {
    {1, 2},
    {3, 4, 5, 6},
    {7}
};
```

---

次のパート：[Part C - メソッドと文字列処理](chapter02c-methods-and-strings.md)