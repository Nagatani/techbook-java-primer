# 第18章 GUIのイベント処理 - Part D: 章末演習

本章で学んだGUIイベント処理の概念を活用して、実践的な練習課題に取り組みましょう。

## 演習の目標
高度なGUIイベント処理とリアルタイムな双方向GUIアプリケーションの作成技術を習得します。

---

## 基礎レベル課題（必須）

### 課題1: インタラクティブ描画アプリケーション

マウス操作で図形を描画できるアプリケーションを作成してください。

**要求仕様：**
- マウスドラッグによる線・矩形・楕円の描画
- 色選択機能（パレットまたはカラーチューザー）
- 線の太さ調整スライダー
- 描画モード選択（ペン、矩形、楕円、消しゴム）
- 描画のアンドゥ・リドゥ機能
- 描画内容のファイル保存・読み込み

**実行例：**
```
=== インタラクティブ描画アプリケーション ===
ウィンドウ表示: "Interactive Drawing Application"
サイズ: 800x600ピクセル

ツールバー構成:
┌─────────────────────────────┐
│ モード: [ペン▼] 色:[■] 太さ:━━━○━━ │
│ [クリア] [戻す] [進む]         │
└─────────────────────────────┘

描画エリア:
┌─────────────────────────────┐
│                           │
│   ○ ← マウスで自由描画     │
│  /|\                      │
│  / \  □ ← 矩形描画        │
│                           │
│      ◯ ← 楕円描画         │
└─────────────────────────────┘

操作テスト:
1. ペンモード: マウスドラッグで自由描画
2. 矩形モード: ドラッグで矩形描画
3. 色変更: カラーボタンでJColorChooser表示
4. アンドゥ: 前の操作を取り消し
5. 保存: PNG形式でファイル保存
```

---

### 課題2: フォームバリデータ

リアルタイムバリデーション機能付きのフォームを作成してください。

**要求仕様：**
- 複数の入力フィールド（名前、メール、電話番号、パスワード、確認パスワード）
- リアルタイムバリデーション（文字入力時に即座にチェック）
- バリデーション結果の視覚的フィードバック（色変更、アイコン表示）
- 送信ボタンの有効/無効制御
- キーボードショートカット（Enterで次フィールド移動等）

**実行例：**
```
=== フォームバリデーター ===
ウィンドウ表示: "Form Validator - リアルタイムバリデーション"
サイズ: 600x400ピクセル

バリデーション状況:
┌─────────────────────────────┐
│ ✓ すべての入力が正しく完了しています │
└─────────────────────────────┘

フォーム構成:
┌─────────────────────────────┐
│ 名前:     [田中太郎_______] ✓  │
│ メール:   [tanaka@example.com] ✓ │
│ 電話番号: [090-1234-5678__] ✓  │
│ パスワード: [********____] ✓   │
│ 確認:     [********____] ✓   │
│                           │
│      [送信] [リセット]      │
└─────────────────────────────┘

バリデーション例:
❌ 名前が空 → "名前を入力してください"
❌ 無効メール → "有効なメールアドレスを入力してください"
❌ 短いパスワード → "パスワードは8文字以上で入力してください"
❌ パスワード不一致 → "パスワードが一致しません"
✓ 有効入力 → 緑色のボーダーとチェックマーク表示
```

**評価ポイント：**
- DocumentListenerによるリアルタイム入力監視
- 正規表現を使った入力値の検証
- 視覚的フィードバックの実装

**実装ヒント：**
- Timerクラスで入力完了後の遅延バリデーション
- setBorder（） やsetBackground() で視覚的フィードバック
- ActionMapとInputMapでキーバインディング設定

---

### 課題3: 高度なメニューシステム

**学習目標：** JMenuBar、JMenu、JMenuItemの階層構造、Actionクラスによる統一的なアクション管理、PopupMenuの作成と表示制御

**問題説明：**
多層メニューシステムと動的メニュー生成機能を持つアプリケーションを作成してください。

**要求仕様：**
- 階層的なメニュー構造（メニュー、サブメニュー、サブサブメニュー）
- 動的メニュー項目の追加・削除・変更機能
- コンテキストメニュー（右クリックメニュー）の実装
- 最近使用したファイル（MRU: Most Recently Used）メニュー
- メニューアクションの履歴管理

**実行例：**
```
=== 高度なメニューシステム ===
ウィンドウ表示: "Advanced Menu System"
サイズ: 800x600ピクセル

メニューバー構成:
ファイル(F) 編集(E) 表示(V) ツール(T) ヘルプ(H)
├── 新規作成 (Ctrl+N)
├── 開く (Ctrl+O)
├── 保存 (Ctrl+S)
├── 最近使用したファイル
│   ├── 1. document1.txt
│   ├── 2. report.txt
│   └── 履歴をクリア
└── 終了 (Ctrl+Q)

動的メニュー機能:
- メニュー項目の追加/削除
- カスタムメニュー名の設定
- メニューアクションの履歴表示

コンテキストメニュー:
右クリック → メニューカスタマイズ
           → 動的メニュー追加
           → メニューをリセット
```

**評価ポイント：**
- JMenuBar、JMenu、JMenuItemの階層構造
- Actionクラスによる統一的なアクション管理
- PopupMenuの作成と表示制御

**実装ヒント：**
- Actionクラスでアクションの統一管理
- MenuListenerでメニューの表示/非表示イベントを処理
- DefaultListModelでMRUリストを管理

---

### 課題4: マウストラッカー

**学習目標：** MouseListener、MouseMotionListenerの詳細実装、Pointクラスと座標計算、数学的計算（距離、速度、角度）

**問題説明：**
マウスの詳細な動作を追跡・分析できるアプリケーションを作成してください。

**要求仕様：**
- リアルタイムマウス座標表示
- マウスの移動軌跡の記録と表示
- クリック位置のマーキング（左、右、中央ボタン別）
- マウス移動速度の計算と表示
- マウスイベントログの記録と出力
- 統計情報の表示（総移動距離、クリック数等）

**実行例：**
```
=== マウストラッカー ===
ウィンドウ表示: "Advanced Mouse Tracker"
サイズ: 800x600ピクセル

リアルタイム情報:
┌─────────────────────────────┐
│ 座標: (425, 312)           │
│ 速度: 15.3 px/s           │
│ 総移動距離: 1,234 px       │
│ 左クリック: 12回           │
│ 右クリック: 3回            │
└─────────────────────────────┘

軌跡表示エリア:
┌─────────────────────────────┐
│     ●─●─●    ← マウス軌跡   │
│    /        ○ ← 左クリック  │
│   ●           ● ← 右クリック │
│              /             │
│         ●─●─●              │
└─────────────────────────────┘

イベントログ:
[12:34:56] Mouse moved to (100, 150)
[12:34:57] Left click at (120, 160)
[12:34:58] Mouse dragged to (140, 180)
[12:34:59] Right click at (160, 200)
```

**評価ポイント：**
- MouseListener、MouseMotionListenerの詳細な実装
- Pointクラスと座標計算
- 数学的計算（距離、速度、角度）

**実装ヒント：**
- System.currentTimeMillis() で時間測定
- Point.distance() で移動距離計算
- CircularBufferの使用でメモリ効率化

---

## 実装のヒント

### 高度なイベント処理のポイント

1. **イベントの種類**: MouseEvent、KeyEvent、ActionEvent、DocumentEvent
2. **リスナの実装**: 適切なリスナインターフェイスの選択と実装
3. **イベントの伝播**: イベントの発生源から処理まで
4. **タイマー処理**: javax.swing.Timerによる定期処理
5. **カスタム描画**: paintComponent()のオーバーライド
6. **状態管理**: アプリケーション状態とUI状態の同期

### よくある落とし穴
- EDT以外からのGUI操作（SwingUtilities.invokeLater使用）
- イベントリスナの登録忘れまたは重複登録
- メモリリークの原因となるリスナの削除忘れ
- 適切なイベント処理パフォーマンスの考慮不足

### 設計のベストプラクティス
- イベント処理ロジックとビジネスロジックの分離
- リアルタイム性とレスポンシブネスの両立
- ユーザビリティを重視したイベント設計
- 複雑なイベント処理の段階的な実装

---

## 実装環境

演習課題の詳細な実装テンプレート、テストコード、解答例は以下のディレクトリを参照してください：

```
exercises/chapter18/
├── basic/          # 基礎レベル課題
│   ├── README.md   # 詳細な課題説明
│   ├── InteractiveDrawing.java
│   ├── FormValidator.java
│   ├── MenuSystem.java
│   └── MouseTracker.java
├── advanced/       # 応用レベル課題
├── challenge/      # 発展レベル課題
└── solutions/      # 解答例（実装完了後に参照）
```

---

## 完了確認チェックリスト

### 基礎レベル
- [ ] インタラクティブ描画でマウスイベント処理ができている
- [ ] フォームバリデータでリアルタイム検証ができている
- [ ] メニューシステムで動的メニューが作成できている
- [ ] マウストラッカーで詳細な動作分析ができている

### 技術要素
- [ ] 高度なイベント処理のしくみを理解している
- [ ] リアルタイムな双方向性を実装できている
- [ ] カスタム描画とアニメーションができている
- [ ] ユーザーの多様な操作に適切に応答できている

### 応用レベル
- [ ] 複雑なイベント処理を含むアプリケーションが構築できている
- [ ] パフォーマンスを考慮したイベント処理ができている
- [ ] カスタムコンポーネントとイベント処理が作成できている
- [ ] ユーザビリティの高いインターフェイスが設計できている

**次のステップ**: 基本課題が完了したら、advanced/の発展課題でより複雑なイベント処理とカスタムコンポーネントの実装に挑戦しましょう！