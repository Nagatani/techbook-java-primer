# 付録B.07: プログラミング言語の歴史的発展

## 概要

Javaが現在の形に至るまでには、プログラミング言語の長い進化の歴史があります。本節では、機械語から始まり、高級言語、構造化プログラミング、オブジェクト指向へと発展してきた経緯を詳しく解説します。

## B.7.1 コンピュータプログラミングの黎明期

### 機械語の時代（1940年代）

最初期のコンピュータでは、プログラムは0と1の機械語で直接記述されていました：

```
00110000 00000001  // データをレジスタAにロード
00110001 00000010  // データをレジスタBにロード
00000000           // A + B を実行
01000000 00000011  // 結果をメモリ位置3に格納
```

この時代のプログラミングは、以下の特徴と課題を持っていました：

**特徴**
- ハードウェアに直接対応した命令
- 最高の実行効率
- メモリ使用量の最小化

**課題**
- プログラムの作成が極めて困難
- バグの発見と修正が非常に困難
- 特定のハードウェアに完全に依存
- プログラマーの生産性が極めて低い

### アセンブリ言語の登場（1950年代）

機械語の課題を解決するため、ニーモニック（覚えやすい略語）を使用したアセンブリ言語が開発されました：

```assembly
LOAD  A      ; 変数Aをロード
ADD   B      ; 変数Bを加算
STORE C      ; 結果を変数Cに格納
```

アセンブリ言語は、機械語に対して以下の改善をもたらしました：

- 人間に理解しやすい記述
- アセンブラによる自動的な機械語変換
- シンボル名による変数やラベルの使用
- 基本的なマクロ機能

しかし、依然としてハードウェア依存性が高く、複雑なプログラムの開発は困難でした。

## B.7.2 高級言語の誕生（1950-60年代）

### FORTRAN（1957年）

IBM社のジョン・バッカスらによって開発されたFORTRANは、最初の実用的な高級言語でした：

```fortran
      PROGRAM CALCULATE
      INTEGER A, B, C
      A = 10
      B = 20
      C = A + B
      PRINT *, 'RESULT:', C
      END PROGRAM
```

FORTRANがもたらした革新：
- 数式を自然な形で記述可能
- ハードウェアからの抽象化
- 科学技術計算での圧倒的な生産性向上
- 最適化コンパイラの概念

### COBOL（1959年）

グレース・ホッパーらによって開発されたCOBOLは、ビジネス処理に特化した言語でした：

```cobol
ADD PRICE TO TOTAL GIVING NEW-TOTAL.
IF NEW-TOTAL > CREDIT-LIMIT
    DISPLAY "Credit limit exceeded"
END-IF.
```

COBOLの特徴：
- 英語に近い構文
- 優れたファイル処理機能
- 10進数演算のネイティブサポート
- 今日でも多くの基幹システムで使用

### ALGOL（1958-1960）

ALGOLは、プログラミング言語の理論的基礎を確立しました：

```algol
begin
    integer a, b, c;
    a := 10;
    b := 20;
    c := a + b;
    print(c)
end
```

ALGOLの影響：
- ブロック構造の導入
- 再帰の明示的サポート
- BNF記法による構文定義
- 多くの現代言語の祖先

## B.7.3 構造化プログラミングの時代（1960-70年代）

### ソフトウェアクライシス

1960年代後半、ソフトウェアの複雑性が急速に増大し、以下の問題が顕在化しました：

- プロジェクトの大幅な遅延
- 予算の大幅な超過
- 品質の低下とバグの多発
- 保守の困難さ

### 構造化プログラミングの提唱

エドガー・ダイクストラは、1968年に「Go To Statement Considered Harmful」を発表し、構造化プログラミングを提唱しました。

基本的な制御構造：
1. **順次実行**: 上から下へ順番に実行
2. **選択**: if-then-else による条件分岐
3. **反復**: while、for によるループ

### C言語（1972年）

デニス・リッチーによって開発されたC言語は、構造化プログラミングの理想を実現しました：

```c
#include <stdio.h>

int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

int main() {
    printf("10! = %d\n", factorial(10));
    return 0;
}
```

C言語の革新性：
- システムプログラミングとアプリケーション開発の両立
- ポータビリティと効率性の両立
- 簡潔で表現力豊かな構文
- UNIXとの共進化

## B.7.4 オブジェクト指向の登場（1960-80年代）

### Simula（1967年）

ノルウェーで開発されたSimulaは、最初のオブジェクト指向言語でした：

```simula
Class Rectangle(width, height);
    Real width, height;
Begin
    Real Procedure area;
        area := width * height;
End;
```

Simulaが導入した概念：
- クラスとオブジェクト
- 継承
- 仮想メソッド
- ガベージコレクション

### Smalltalk（1972-1980）

アラン・ケイらによるSmalltalkは、純粋なオブジェクト指向を実現しました：

```smalltalk
Object subclass: #Point
    instanceVariableNames: 'x y'
    
Point>>distanceTo: anotherPoint
    | dx dy |
    dx := x - anotherPoint x.
    dy := y - anotherPoint y.
    ^ (dx squared + dy squared) sqrt
```

Smalltalkの革新：
- すべてがオブジェクト
- メッセージパッシング
- 動的型付け
- 統合開発環境の先駆け

### C++（1983年）

ビャーネ・ストロヴストルップによるC++は、C言語にオブジェクト指向を追加しました：

```cpp
class Shape {
public:
    virtual double area() = 0;
};

class Circle : public Shape {
private:
    double radius;
public:
    Circle(double r) : radius(r) {}
    double area() override {
        return 3.14159 * radius * radius;
    }
};
```

C++の特徴：
- C言語との互換性
- 多重継承
- テンプレート
- 演算子オーバーロード

## B.7.5 Javaの誕生（1995年）

### 時代背景

1990年代前半、以下の技術的課題が存在しました：

1. **インターネットの普及**: プラットフォーム独立性の必要性
2. **C++の複雑性**: メモリ管理、多重継承の問題
3. **セキュリティ**: ネットワーク環境での安全な実行
4. **開発生産性**: より簡潔で安全な言語の需要

### Javaの設計思想

ジェームズ・ゴスリンらは、これらの課題を解決する言語としてJavaを設計しました：

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

Javaの革新的特徴：
- Write Once, Run Anywhere
- ガベージコレクション
- 単一継承とインターフェース
- 強い型付けと安全性
- 豊富な標準ライブラリ

## B.7.6 現代への発展（2000年代以降）

### 関数型プログラミングの再評価

2000年代以降、マルチコア時代の到来により、関数型プログラミングが再評価されました：

```java
// Java 8のラムダ式
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
    .filter(n -> n % 2 == 0)
    .mapToInt(n -> n * n)
    .sum();
```

### 新しいパラダイムの統合

現代のJavaは、複数のパラダイムを統合しています：

1. **オブジェクト指向**: クラス、継承、ポリモーフィズム
2. **関数型**: ラムダ式、Stream API、不変性
3. **並行処理**: CompletableFuture、並列ストリーム
4. **リアクティブ**: Flow API、非同期処理

### 言語の継続的進化

Javaは6ヶ月リリースサイクルを採用し、継続的に進化しています：

- **Java 8（2014）**: ラムダ式、Stream API
- **Java 9（2017）**: モジュールシステム
- **Java 11（2018）**: 長期サポート版、HTTPクライアント
- **Java 14（2020）**: switch式、Records（プレビュー）
- **Java 17（2021）**: 長期サポート版、封印クラス
- **Java 21（2023）**: 仮想スレッド、パターンマッチング

## まとめ

プログラミング言語の歴史は、以下の大きな流れで発展してきました：

1. **抽象化の向上**: 機械語→アセンブリ→高級言語
2. **構造化**: スパゲッティコードから構造化プログラミングへ
3. **オブジェクト指向**: データと処理の一体化
4. **マルチパラダイム**: 複数のプログラミング手法の統合

Javaは、この歴史的発展の集大成として、実用性と理論的優雅さを兼ね備えた言語として設計されました。過去の教訓を活かしつつ、現代的な課題に対応し続けることで、四半世紀以上にわたって主要なプログラミング言語としての地位を維持しています。

この歴史的視点を持つことで、なぜJavaが現在の形になったのか、そして今後どのような方向に進化していくのかを理解することができます。