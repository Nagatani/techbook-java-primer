# 第6章 ポリモーフィズム：多様なオブジェクトを統一的に扱う

## 🎯総合演習プロジェクトへのステップ

本章で学ぶ「ポリモーフィズム」は、**総合演習プロジェクト「ToDoリストアプリケーション」** のコードを、より柔軟で拡張しやすい構造にするための鍵となります。

- **統一的なタスク管理**: `ArrayList<Task>`のように、スーパークラスである`Task`のリストを用意するだけで、将来追加するかもしれない`PriorityTask`や`RecurringTask`といった**サブクラスのオブジェクトも一緒に管理**できます。
- **拡張性の高いコード**: 新しい種類のタスクを追加する際に、タスク一覧を表示する処理や、タスクをファイルに保存する処理など、既存のコードを一切変更する必要がなくなります。`for (Task task : allTasks)`のようなループは、新しいタスクの種類を意識することなく、そのまま動作します。

本章を学ぶことで、変化に強く、保守しやすいソフトウェアを設計するための、オブジェクト指向の真髄に触れることができます。

## 📋 本章の学習目標

### 前提知識
- **第5章の継承**: `extends`によるクラスの継承と、メソッドのオーバーライドを理解している。

### 到達目標

#### 知識理解目標
- ポリモーフィズム（多態性）の基本概念を説明できる。
- スーパークラスの型でサブクラスのインスタンスを扱えることを理解する。
- 同じメソッド呼び出しでも、インスタンスの種類によって実際の動作が変わるしくみ（動的ディスパッチ）を理解する。
- `instanceof`演算子とダウンキャストの必要性と使い方を説明できる。

#### 技能習得目標
- スーパークラス型の配列やリストに、複数の異なるサブクラスのインスタンスを格納できる。
- ループ処理の中で、各オブジェクトのオーバーライドされたメソッドを呼び出し、それぞれの固有の動作を確認できる。
- `instanceof`で型をチェックし、安全にダウンキャストしてサブクラス固有のメソッドを呼び出せる。

---

## 6.1 ポリモーフィズムとは？

**ポリモーフィズム（Polymorphism）** は「多態性」や「多様性」と訳され、オブジェクト指向プログラミングの最も強力な概念の1つです。その本質は、「**同じ型の変数や、同じメソッド呼び出しで、実際のインスタンスの種類に応じて異なる振る舞いを実現する**」ことにあります。

前章で学んだ「継承」と「メソッドのオーバーライド」が、このポリモーフィズムを実現するための土台となります。

### スーパークラス型でサブクラスを扱う

Javaでは、スーパークラス型の変数で、そのサブクラスのインスタンスを参照できます。

```java
// Productはスーパークラス、BookとElectronicsはサブクラス
Product product1 = new Book("Java入門", 3200, "田中太郎");
Product product2 = new Electronics("4Kテレビ", 80000, "TechCorp");
```

`product1`と`product2`は、どちらも`Product`型として宣言されていますが、実際に参照しているオブジェクトは`Book`と`Electronics`という異なる種類です。このように、サブクラスのインスタンスをスーパークラスの型に代入することを**アップキャスト**と呼びます。

### 同じ呼び出しで、異なる振る舞い

ポリモーフィズムの真価は、この状態でメソッドを呼び出したときに発揮されます。

```java
product1.displayDetails(); // 実行されるのは Bookクラスでオーバーライドされた displayDetails()
product2.displayDetails(); // 実行されるのは Electronicsクラスでオーバーライドされた displayDetails()
```

`displayDetails()`という**まったく同じメソッド呼び出し**にもかかわらず、JVM（Java仮想マシン）は実行時に変数が実際に参照しているインスタンスの種類を判断し、それぞれに最適なメソッドを自動的に呼び分けます。このしくみを**動的ディスパッチ**または**動的束縛**と呼びます。

### ポリモーフィズムの実践例：動物園のショータイム

動物園にいるさまざまな動物（ライオン、ゾウ、サル）に「芸をしなさい」と一斉に指示する場面を考えてみましょう。

```java
// Animal.java (スーパークラス)
abstract class Animal {
    protected String name;
    public Animal(String name) { this.name = name; }
    public abstract void performTrick(); // 芸をする（具体的な内容はサブクラスで決める）
}

// Lion.java
class Lion extends Animal {
    public Lion(String name) { super(name); }
    @Override
    public void performTrick() {
        System.out.println(this.name + " が火の輪くぐりを披露！");
    }
}

// Elephant.java
class Elephant extends Animal {
    public Elephant(String name) { super(name); }
    @Override
    public void performTrick() {
        System.out.println(this.name + " が鼻で絵を描きます！");
    }
}

// Zoo.java
public class Zoo {
    public static void main(String[] args) {
        // Animal型の配列に、異なるサブクラスのインスタンスをまとめて格納
        Animal[] performers = {
            new Lion("レオ"),
            new Elephant("パオ"),
            new Lion("シンバ")
        };

        // ショーの開始
        System.out.println("=== ショータイム！ ===");
        for (Animal performer : performers) {
            // 同じ performTrick() の呼び出しでも、実際の動作はインスタンスによって変わる
            performer.performTrick();
        }
    }
}
```

**実行結果:**
```
=== ショータイム！ ===
レオ が火の輪くぐりを披露！
パオ が鼻で絵を描きます！
シンバ が火の輪くぐりを披露！
```

`Zoo`クラスは、個々の動物がライオンなのかゾウなのかを一切気にしていません。ただ`Animal`として「芸をしなさい (`performTrick()`)」と指示するだけで、各動物が自分自身の芸を披露します。

もし将来、`Seal`（アシカ）クラスを追加したとしても、`Zoo`クラスの`main`メソッドを修正する必要は一切ありません。これがポリモーフィズムがもたらす**柔軟性**と**拡張性**です。

## 6.2 ダウンキャストと`instanceof`演算子

スーパークラスの型でオブジェクトを扱っていると、そのオブジェクトがもともと持っていたサブクラス固有のメソッドを呼びだすことはできません。

```java
Animal animal = new Lion("レオ");
// animal.hunt(); // コンパイルエラー！ Animalクラスにはhunt()メソッドがない
```

このような場合に、スーパークラス型から元のサブクラス型へ参照を戻すことを**ダウンキャスト**と呼びます。

ただし、安全でないダウンキャストは実行時エラー（`ClassCastException`）を引き起こす可能性があるため、キャストする前に`instanceof`演算子を使って、オブジェクトが本当にそのクラスのインスタンスであるかを確認するのが定石です。

```java
Animal[] animals = { new Lion("レオ"), new Elephant("パオ") };

for (Animal animal : animals) {
    // animalがLionクラスのインスタンスかチェック
    if (animal instanceof Lion) {
        // 安全にダウンキャスト
        Lion lion = (Lion) animal;
        // Lionクラス固有のメソッド���呼び出す
        lion.hunt();
    }
}
```

## まとめ

本章では、継承を基盤としたオブジェクト指向の強力な概念「ポリモーフィズム」について学びました。

-   **ポリモーフィズム**は、同じ型やメソッド呼び出しで、インスタンスの種類に応じて異なる振る舞いを実現するしくみです。
-   スーパークラスの型でサブクラスのインスタンスを統一的に扱うことができます（**アップキャスト**）。
-   同じメソッドを呼び出しても、実行時に実際のインスタンスのメソッドが呼び出されます（**動的ディスパッチ**）。
-   これにより、コードの**柔軟性**と**拡張性**が大幅に向上し、変更に強いプログラムを設計できます。
-   サブクラス固有の機能を使いたい場合は、`instanceof`で型をチェックしてから**ダウンキャスト**を行います。

次章では、ポリモーフィズムをさらに強力に活用するための「抽象クラス」と「インターフェイス」について学びます。