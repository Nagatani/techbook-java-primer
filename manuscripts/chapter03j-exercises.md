# 第3章 オブジェクト指向の考え方 - Part J: 章末演習

## 3.7 章末演習

本章で学んだクラス、メソッド、配列、制御構造の知識を総動員して、以下の演習問題に取り組んでください。これらの課題は、単に文法を理解するだけでなく、実際にプログラムを設計し、問題を解決する能力を養うことを目的としています。

### 演習1：メソッド作成練習

この演習は、メソッドの定義、引数、戻り値の基本的な使い方に慣れるためのものです。プログラムとして直接的な意味は持ちませんが、メソッド設計の基礎を固める上で重要です。

**技術的背景：メソッド設計の重要性**

実際のソフトウェア開発では、1つのプログラムが数千、数万行のコードから構成されることは珍しくありません。このような大規模なプログラムを1つの巨大なmainメソッドに書くことは不可能です。そこで、プログラムを適切な単位（メソッド）に分割することが不可欠となります。

メソッドを適切に設計することで以下のメリットが得られます：
- **コードの再利用性**：同じ処理を何度も書かずに済む
- **保守性の向上**：バグ修正や機能変更が局所的に行える
- **可読性の向上**：処理の意味が明確になり、他の開発者が理解しやすい
- **テストの容易性**：単位テストにより品質を保証できる

この演習では、引数なし・戻り値なし、引数あり・戻り値あり、さらに特殊な処理（遅延実行）を含むメソッドなど、さまざまなパターンを実装することで、メソッド設計の基本的な型を身につけます。

**1. クラスの準備**

`MethodsPractice.java`というファイル名で、`MethodsPractice`クラスを作成してください。

**2. メソッドの実装**

`MethodsPractice`クラス内に、以下の仕様に従って4つのメソッドを実装してください。

**2-1. 金額表示メソッド**

-   **メソッド名:** `printCurrency`
-   **戻り値:** `void`
-   **引数:** `double`型の金額
-   **処理内容:** 受け取った金額を、`System.out.printf("%.2f\n", ...)` を使って小数点以下2桁の形式で画面に出力します。

**2-2. 整数加算メソッド**

-   **メソッド名:** `add`
-   **戻り値:** `int`
-   **引数:** `int`型の数値2つ
-   **処理内容:** 2つの引数を加算した結果を返します。

**2-3. 整数除算メソッド**

-   **メソッド名:** `division`
-   **戻り値:** `double`
-   **引数:** `int`型の数値2つ
-   **処理内容:** 1つ目の引数を2つ目の引数で除算した結果を、`double`型で返します。整数除算で結果が切り捨てられないように注意してください（例： `1 / 2` が `0.5` となるようにする）。

**2-4. 「生命、宇宙、そして万物についての究極の疑問の答え」を返すメソッド**

-   **メソッド名:** `getTheAnswerToTheUltimateQuestionOfLife_TheUniverse_And_Everything`
-   **戻り値:** `String`
-   **引数:** なし
-   **処理内容:** 750ミリ秒待機した後に、文字列 `"42"` を返します。
    -   **ヒント:** 750ミリ秒待機するには、以下のコードを使用します。例外処理については後の章で詳しく学びますが、今は「おまじない」として利用してください。
        ```java
        try {
            Thread.sleep(750);
        } catch (InterruptedException e) {
            // 今は空でOK
        }
        ```

**3. 動作確認**

`main`メソッドを作成し、実装した各メソッドを呼び出して、その動作が正しいことを確認してください。`static`ではないメソッドを呼びだすには、`MethodsPractice`クラスのインスタンスを生成する必要がある点に注意してください。

```java
// mainメソッド内での呼び出し例
MethodsPractice app = new MethodsPractice();
app.printCurrency(1234.567);
int sum = app.add(10, 20);
System.out.println("加算結果: " + sum);
// ... 他のメソッドも同様にテストする
```

### 演習2：テストの点数管理クラス

生徒一人一人のテストの点数を管理し、合計点や平均点などを計算するクラスを設計します。この課題を通じて、データ（フィールド）と振る舞い（メソッド）をまとめたクラスの設計方法を学びます。

**技術的背景：データとロジックの一体化**

従来の手続き型プログラミング（C言語など）では、データ構造（構造体）と、そのデータを操作する関数を別々に定義していました。しかし、この方法では以下の問題が発生します：

- **データの不整合**：どの関数からでもデータを変更できるため、予期しない変更が起こりやすい
- **関連性の不明瞭さ**：どの関数がどのデータに対して使用されるべきかが不明確
- **保守の困難さ**：データ構造を変更すると、関連するすべての関数を修正する必要がある

オブジェクト指向では、データ（生徒の点数）とそれを操作するロジック（合計計算、平均計算など）を1つのクラスにまとめることで、これらの問題を解決します。この設計により、データの整合性が保たれ、関連する処理が明確になり、変更の影響範囲を限定できます。

この演習では、教育現場でよく見られる成績管理という実務的な例を通じて、オブジェクト指向設計の基本を実践的に学習します。

**1. クラスの設計**

以下の2つのクラスを作成します。

-   `StudentScores.java`: 生徒一人の情報を保持するクラス。
-   `ScoresRegistry.java`: `main`メソッドを持ち、プログラム全体を管理するクラス。

**2. `StudentScores`クラスの実装**

**フィールド:**

| フィールド名 | 型 | 説明 |
| :--- | :--- | :--- |
| `id` | `int` | 出席番号 |
| `name` | `String` | 氏名 |
| `scores` | `int[5]` | 5教科の点数配列<br>([0]:国語, [1]:数学, [2]:理科, [3]:社会, [4]:英語) |

**メソッド:**

| メソッド名 | 戻り値 | 引数 | 説明 |
| :--- | :--- | :--- | :--- |
| `(各教科のゲッター)` | `int` | なし | 各教科の点数を返す (`getJapaneseScore`, `getMathematicsScore`など) |
| `(各教科のセッター)` | `void` | `int value` | 各教科の点数を設定する (`setJapaneseScore`, `setMathematicsScore`など) |
| `getTotal` | `int` | なし | 5教科の合計点を計算して返す |
| `getAverage` | `double` | なし | 5教科の平均点を計算して返す |
| `getHighScore` | `int` | なし | 5教科のうち最高得点を返す |
| `getHighScoreSubject` | `String` | なし | 最高得点の科目名を返す（複数ある場合はカンマ区切り。例: "国語,英語"） |
| `getLowScore` | `int` | なし | 5教科のうち最低得点を返す |
| `getLowScoreSubject` | `String` | なし | 最低得点の科目名を返す（複数ある場合はカンマ区切り） |
| `getInfo` | `String` | なし | 生徒の全情報を整形した文字列を返す（例: "出席番号: 1 氏名: 田中太郎 国語:80点 ... 合計:400点 平均:80.0点"） |

**3. `ScoresRegistry`クラスの実装**

-   `main`メソッドを実装します。
-   `Scanner`クラスなどを使って、ユーザーから複数人分の生徒情報（出席番号、氏名、各教科の点数）をコンソールから入力させます。
-   入力された情報を使って`StudentScores`のインスタンスを生成します。
-   すべての入力が終わったら、各生徒の`getInfo`メソッドを呼び出し、全員分の情報を画面に表示します。

### 演習3：車の燃料消費シミュレータ

オブジェクトの状態がメソッド呼び出しによって変化していく様子をシミュレートします。

**技術的背景：オブジェクトの状態管理とシミュレーション**

実世界の多くのシステムは、時間とともに状態が変化します。例えば：
- **銀行口座**：入出金により残高が変化
- **在庫管理**：商品の入荷・出荷により在庫数が変化
- **ゲームキャラクター**：行動によりHP、経験値などが変化

このような状態変化を適切にモデル化することは、ソフトウェア開発の重要な要素です。オブジェクト指向プログラミングでは、オブジェクトが内部状態（フィールド）を持ち、メソッドを通じてその状態を変更することで、実世界のシステムを自然に表現できます。

この演習では、車の走行による燃料消費というシンプルだが実用的な例を通じて、以下の概念を学習します：
- **状態の累積**：走行距離と燃料消費の累積管理
- **計算ロジックのカプセル化**：燃費計算をクラス内部に隠蔽
- **イミュータブルな操作**：runメソッドは副作用を持つが、計算結果も返す設計

これらは、より複雑なビジネスロジックやゲーム開発などで必要となる基本的な設計パターンです。

**1. クラスの設計**

-   `Car.java`: 車の状態と振る舞いを定義するクラス。
-   `FuelExpenseCalculator.java`: `main`メソッドを持ち、シミュレーションを実行するクラス。

**2. `Car`クラスの実装**

**フィールド:**

| フィールド名 | 型 | 説明 |
| :--- | :--- | :--- |
| `fuelEfficiency` | `double` | 燃費 (km/L) |
| `totalMileage` | `double` | 累積走行距離 (km) |
| `expendedFuel` | `double` | 累積消費燃料 (L) |

**メソッド:**

| メソッド名 | 戻り値 | 引数 | 説明 |
| :--- | :--- | :--- | :--- |
| `run` | `double` | `double mileage` | 引数で渡された距離を走行し、消費燃料を計算してフィールドを更新する。今回消費した燃料を返す。 |
| `getInfo` | `String` | なし | 現在の累積走行距離と累積消費燃料を整形した文字列を返す。 |

**3. `FuelExpenseCalculator`クラスの実装**

-   `main`メソッドを実装します。
-   最初に車の燃費を設定して`Car`インスタンスを生成します。
-   ユーザーに走行距離を繰り返し入力させます。「end」と入力されたらループを終了します。
-   入力があるたびに`Car`の`run`メソッドを呼び出し、`getInfo`メソッドで現在の状況を表示します。

### 演習のポイント

これらの演習では、以下の重要な概念を実践的に学習できます：

1. **カプセル化**: データ（フィールド）と処理（メソッド）を1つのクラスにまとめる
2. **情報隠蔽**: 必要な情報のみを公開し、内部実装を隠す
3. **オブジェクトの状態管理**: メソッド呼び出しによるオブジェクトの状態変化
4. **クラス間の連携**: 複数のクラスを組み合わせたプログラム設計

各演習の解答例は、`source/chapter03/`ディレクトリに用意されています。まずは自分で実装してみて、その後で解答例と比較することで、より深い理解が得られるでしょう。