# 第6章 不変性とfinalキーワード

## 本章の学習目標

### 前提知識

本章を学習するためには、いくつかの大切な前提知識があるとよいでしょう。まずポイントとして、第5章までに学習したオブジェクト指向プログラミングの基本概念を理解していることが挙げられます。特に、クラスとインスタンスの関係、カプセル化の大切さ、パッケージとアクセス制御のメカニズムについての深い理解が役立ちます。また、オブジェクトの状態（フィールド）とその変更がプログラムの動作に与える影響について、実践的な経験を持っているとよいでしょう。

さらに、より深い学習を希望する学生には、マルチスレッド環境での共有データの問題や、オブジェクトの予期しない変更によるバグを経験したことがあると、不変性の大切さをより深く理解できるでしょう。大規模なプログラムでのデータの一貫性維持の難しさを理解していると、不変オブジェクトの設計思想がより鮮明になります。

### 知識理解目標

本章では、Javaプログラミングにおける不変性（Immutability）とfinalキーワードの概念を深く理解することが目標です。不変性は単なるプログラミングテクニックではなく、堅牢で保守性の高いソフトウェアを構築するための大切な設計原則です。finalキーワードの3つの用途（変数、メソッド、クラス）それぞれの意味と効果を理解し、適切に使い分けられます。また、不変オブジェクトがスレッドセーフティ、キャッシング、関数型プログラミングなどの高度な概念とどのように関連するかを学びます。

### 技能習得目標

技能習得の面では、不変オブジェクトを正しく設計・実装できるようになることが目標です。これには、finalフィールドの宣言、コンストラクタでの初期化、setterメソッドを持たない設計、防御的コピーの実装などが含まれます。また、既存の可変クラスを不変クラスに変換する技術、ビルダパターンを使った不変オブジェクトの構築方法も習得します。final変数を使った定数の定義、finalメソッドによる継承の制御、finalクラスによる拡張の防止など、finalキーワードのすべての側面を実践的に使いこなせます。

### 設計能力目標

設計能力の観点からは、不変性を活用した安全で予測可能なシステム設計ができるようになることが目標です。これは、副作用を最小化したメソッド設計、状態変更を局所化したアーキテクチャ、不変性と可変性のトレードオフを考慮した設計判断などを含みます。値オブジェクトパターン、不変コレクションの活用、関数型プログラミングスタイルの採用など、モダンなJavaプログラミングで求められる設計スキルを身につけます。

### 到達レベルの指標

最終的な到達レベルとしては、以下のことができます：
- finalキーワードの3つの用途を正しく理解し、状況に応じて適切に使い分けられる
- 完全な不変オブジェクトを設計・実装し、その利点を最大限に活用できる
- スレッドセーフなコードを不変性を使って実現できる
- 不変性と性能のトレードオフを理解し、適切なバランスを取った設計ができる
- Java標準ライブラリの不変クラス（String、Integer等）の設計思想を理解し、同様の品質のコードを書ける



## 4.1 カプセル化とアクセス制限

オブジェクト指向プログラミングの大切な原則の1つである**カプセル化 (Encapsulation)** について詳しく学習しましょう。カプセル化とは、オブジェクトのデータ（フィールド）とそのデータを操作するメソッドを1つにまとめ、オブジェクトの内部構造を外部から隠蔽することです。

### なぜカプセル化が必要か？

もし、クラスのフィールドが外部から自由にアクセスできてしまうと、どうなるでしょうか？

### 実際の開発で起こる深刻な問題

以下のコードは、カプセル化を無視した設計が実際の開発でどのような深刻な問題を引き起こすかを示しています：

<span class="listing-number">**サンプルコード6-1**</span>

```java
// カプセル化されていない危険なコード
public class BankAccount {
    public String ownerName;
    public double balance;      // publicなので誰でも直接変更できてしまう
    public double creditLimit;  // クレジット限度額
    public double loanAmount;   // ローン残高
}

public class BankingSystemProblem {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.ownerName = "山田太郎";
        account.balance = 100000;
        account.creditLimit = 500000;
        account.loanAmount = 200000;

        // 問題1: 不正な値の設定による論理的矛盾
        account.balance = -50000;  // 負の残高（物理的にありえない）
        
        // 問題2: ビジネスルールの破壊
        account.loanAmount = 1000000;  // クレジット限度額を超えるローン
        
        // 問題3: 悪意のある操作やバグによるデータ破壊
        account.balance = Double.MAX_VALUE;  // 突然、無限のお金持ちに！
        
        // 問題4: 並行処理での競合状態
        // スレッドAとスレッドBが同時にbalanceを変更すると...
        // データの整合性が保証されない
    }
}
```

**実際に発生した事例**：
- **金融システムでの事故**：直接フィールドアクセスを許可していたため、バグにより顧客の口座残高が誤って変更され、多額の損失が発生
- **在庫管理システムでの問題**：複数の処理が同時に在庫数を直接変更した結果、実際の在庫と記録が一致しなくなり、ビジネスに深刻な影響
- **セキュリティの脆弱性**：外部からの入力値を検証せずに直接フィールドに設定できたため、SQLインジェクションなどの攻撃を受ける

このように、外部から直接データを操作できると、オブジェクトが不正な状態になったり、意図しない変更が加えられたりする危険性があります。

カプセル化は、このような問題を防ぎ、以下の利点をもたらします。

まず最も大切な利点は、**データの保護と整合性の維持**です。外部から直接フィールドにアクセスできなくすることで、意図しない値の書き換えや、不正な状態になることを防ぎます。たとえば、銀行口座の残高が負の値になったり、人の年齢が負の値になったりするような、ビジネスロジック上あり得ない状態を確実に防止できます。

次に、**保守性の向上**という大きなメリットがあります。クラスの内部実装（フィールドの持ち方やメソッド内のロジック）を変更しても、外部への影響を最小限に抑えることができます。公開しているメソッドの仕様が変わらなければ、内部は自由に変更できます。これにより、パフォーマンスの最適化やバグ修正を、ほかのコードに影響を与えることなく実施できます。

さらに、**独立性と再利用性の向上**も大切な利点です。適切にカプセル化されたクラスは、部品としての独立性が高まり、ほかのプログラムでも安心して利用しやすくなります。使う側は公開されたインターフェイス（メソッド）だけを意識すればよく、内部の複雑な実装を知ることは大切ではありません。これにより、クラスをライブラリとして配布したり、チーム開発で共有したりすることが容易になります。

### アクセス修飾子によるアクセス制御

Javaでは、クラス、フィールド、メソッド、コンストラクタに対して**アクセス修飾子**を指定することで、外部からのアクセスレベルを制御します。

| 修飾子 | 同じクラス | 同じパッケージ | サブクラス (別パッケージ) | それ以外 (別パッケージ) | 説明 |
| :--- | :---: | :---: | :---: | :---: | :--- |
| `public` | ○ | ○ | ○ | ○ | **公開**。どこからでもアクセス可能。 |
| `protected` | ○ | ○ | ○ | × | **保護**。同じクラス、同じパッケージ、または別パッケージのサブクラスからアクセス可能。 |
| (修飾子なし) | ○ | ○ | × | × | **パッケージプライベート**。修飾子を記述しない場合。同じパッケージ内からのみアクセス可能。 |
| `private` | ○ | × | × | × | **非公開**。同じクラス内からのみアクセス可能。 |

**選択の基本方針:**

アクセス修飾子を選択する際の基本方針を理解することは、安全で保守性の高いコードを書く上でポイントになります。まず大切な原則として、**フィールドは原則として`private`にする**ことが挙げられます。クラスの心臓部であるデータは、外部から直接触られないように隠し、オブジェクトの状態の一貫性を保ちます。これにより、フィールドの値が不正に変更されるリスクを最小化できます。

次に、**メソッドは外部に公開するものだけを`public`にする**という方針も大切です。外部から使われることを意図した機能だけを公開し、内部だけで使う補助的なメソッドは`private`にします。これにより、クラスのインターフェイスが明確になり、使う側が必要以上に複雑な内部構造を意識する必要がなくなります。

最後に、**迷ったらできるだけ厳しい（狭い）範囲の修飾子を選ぶ**という安全第一のアプローチを推奨します。最初は`private`にしておき、必要に応じてアクセス範囲を広げていく方が、最初から広い範囲を設定してしまい、後から狭めるよりも、はるかに安全です。この方針に従うことで、予期せぬ副作用やセキュリティ上の問題を未然に防ぐことができます。

### getter/setter パターンによる実践

カプセル化の最も一般的な実践方法が、`private`なフィールドと、それに対応する`public`な**getter**（ゲッタ／取得メソッド）と**setter**（セッタ／設定メソッド）を用意するパターンです。

カプセル化されたフィールドにアクセスするための標準的な方法として、**getterメソッド**と**setterメソッド**があります。getterメソッドは、`private`なフィールドの値を読み取って返すメソッドで、メソッド名は`get`にフィールド名を続けた形（例：`getName()`）とするのが慣例です。これにより、外部からフィールドの値を安全に取得できます。

一方、setterメソッドは、`private`なフィールドに値を設定するメソッドで、メソッド名は`set`にフィールド名を続けた形（例：`setAge(int age)`）とします。setterメソッドの大切な役割は、単に値を設定するだけではなく、設定される値が適切かどうかを検証できる点にあります。

setterメソッドの大切な役割は、フィールドに値を設定する前に、その値が**妥当かどうかを検証（バリデーション）**できる点にあります。

#### 実践例：`Employee`クラス

<span class="listing-number">**サンプルコード6-2**</span>

```java
// Employee.java
public class Employee {
    private String name; // private: このクラス内からのみアクセス可能
    private int age;     // private: このクラス内からのみアクセス可能
    private double salary;

    public Employee(String name, int age, double salary) {
        // コンストラクタでもsetterを呼ぶことで、生成時にもバリデーションを適用できる
        this.setName(name);
        this.setAge(age);
        this.setSalary(salary);
    }

    // nameフィールドのgetter
    public String getName() {
        return this.name;
    }

    // nameフィールドのsetter
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name.trim();
        } else {
            // 不正な値の場合は例外を投げて処理を中断する（例外処理は後の章で学びます）
            throw new IllegalArgumentException("名前は空にできません。");
        }
    }

    // ageフィールドのgetter
    public int getAge() {
        return this.age;
    }

    // ageフィールドのsetter（バリデーション付き）
    public void setAge(int age) {
        if (age >= 18 && age < 150) {
            this.age = age;
        } else {
            throw new IllegalArgumentException("年齢は18～149の範囲で入力してください。");
        }
    }

    // salaryフィールドのgetter
    public double getSalary() {
        return this.salary;
    }
    
    // salaryフィールドのsetter
    public void setSalary(double salary) {
        if (salary >= 0) {
            this.salary = salary;
        } else {
            throw new IllegalArgumentException("給与は0以上である必要があります。");
        }
    }

    // 昇給メソッド（ビジネスロジック）
    public void giveRaise(double percentage) {
        if (percentage > 0) {
            // salaryフィールドの操作はクラス内部なので自由に行える
            this.salary *= (1 + percentage / 100.0);
        } else {
            throw new IllegalArgumentException("昇給率は正の値である必要があります。");
        }
    }

    public void displayInfo() {
        System.out.println("名前: " + this.name + ", 年齢: " + this.age + ", 給与: " + this.salary);
    }
}
```

以下の例では、Employeeクラスを実際に使用して、カプセル化されたフィールドへの安全なアクセス、ビジネスロジックの実行、不正な値に対するエラーハンドリングを確認できます。

<span class="listing-number">**サンプルコード6-3**</span>

```java
// EmployeeManagement.java
public class EmployeeManagement {
    public static void main(String[] args) {
        Employee emp = new Employee("山田 太郎", 30, 300000);
        emp.displayInfo();

        // フィールドへの直接アクセスはコンパイルエラーになる
        // emp.salary = -10000; 

        // setterを使って安全に値を変更
        emp.setSalary(320000);
        System.out.println("新しい給与: " + emp.getSalary());

        // ビジネスロジックの実行
        emp.giveRaise(5); // 5%昇給
        System.out.println("昇給後の給与: " + emp.getSalary());

        // 不正な値を設定しようとすると、例外が発生してプログラムが停止する
        try {
            emp.setAge(200);
        } catch (IllegalArgumentException e) {
            System.err.println("エラー: " + e.getMessage());
        }
        
        // 現在の状態を再表示
        emp.displayInfo();
    }
}
```

この例のように、カプセル化はクラスを「データの番人」として機能させ、オブジェクトが常に正しく、一貫性のある状態を保つことを保証します。

## 4.2 パッケージによるクラスの整理

プログラムの規模が大きくなると、作成するクラスの数も増えていきます。すべてのクラスを同じ場所に置いていると、名前の衝突が起きたり、目的のクラスを探すのがたいへんになったりします。

そこでJavaでは、関連するクラスをグループ化するためのしくみとして**パッケージ (package)** が用意されています。

パッケージは、コンピュータのフォルダ（ディレクトリ）でファイルを整理するのと似ています。

### パッケージの役割

*   **名前空間の提供**: パッケージが異なれば、同じ名前のクラスを定義できます。これにより、Java標準ライブラリのクラス名（例： `List`）や、外部ライブラリのクラス名と偶然同じ名前を付けてしまっても、衝突を避けられます。クラスの完全な名前は `パッケージ名.クラス名` となります（例： `java.util.List`）。
*   **クラスの分類**: 機能や役割に応じてクラスを分類することで、プロジェクトの構造が分かりやすくなります。たとえば、データモデル関連のクラスを`model`パッケージに、UI関連のクラスを`ui`パッケージにまとめる、といった使い方ができます。
*   **アクセス制御**: パッケージはアクセス制御の単位にもなります。アクセス修飾子を何も付けない（`default`）場合、そのメンバーは同じパッケージ内のクラスからのみアクセス可能になります。

### パッケージの宣言とディレクトリ構造

クラスがどのパッケージに属するかを指定するには、ソースファイルの先頭で`package`文を使います。

<span class="listing-number">**サンプルコード6-4**</span>

```java
package com.example.geometry; // このファイル内のクラスは com.example.geometry パッケージに属する

public class Circle {
    // ...
}
```

この`package`宣言は、ソースファイルの**物理的なディレクトリ構造と一致している必要があります**。`com.example.geometry`パッケージの場合、ソースファイルは以下のようなディレクトリに配置されている必要があります。

```
(プロジェクトのソースルート)
└── com
    └── example
        └── geometry
            ├── Circle.java
            └── Rectangle.java
```

### パッケージの命名規則

パッケージ名が世界中で一意（ユニーク）になるように、Javaでは組織が所有する**インターネットのドメイン名を逆順にする**ことが推奨されています。

*   例： `example.com` というドメインを持つ組織なら、`com.example.プロジェクト名.機能名` のように命名します。

この規則は、特にライブラリを公開する場合に大切です。個人学習や組織内での利用の場合は、`「逆引きドメイン名」.プロジェクト名` のような構造的な命名を心がけるとよいでしょう。また、パッケージ名は**すべて小文字**で記述するのが慣例です。

## 4.3 import文によるクラスの利用

他のパッケージに属するクラスを利用するには、本来`パッケージ名.クラス名`という**完全限定名 (Fully Qualified Name)** で記述する必要があります。

<span class="listing-number">**サンプルコード6-5**</span>

```java
// importを使わない場合
java.util.Scanner scanner = new java.util.Scanner(System.in);
java.util.ArrayList<String> list = new java.util.ArrayList<>();
```

しかし、これではコードが長くなり、可読性が低下します。そこで、ソースファイルの先頭（`package`文の後）に`import`文を記述することで、クラス名を短く書けます。

<span class="listing-number">**サンプルコード6-6**</span>

```java
import java.util.Scanner; // java.util.Scannerクラスをインポート
import java.util.ArrayList; // java.util.ArrayListクラスをインポート

public class MyProgram {
    public static void main(String[] args) {
        // importしているので、クラス名だけで書ける
        Scanner scanner = new Scanner(System.in);
        ArrayList<String> list = new ArrayList<>();
    }
}
```

### オンデマンドインポート

同じパッケージの多くのクラスを使いたい場合、アスタリスク `*` を使って、そのパッケージに属するすべての`public`なクラスをまとめてインポートできます。これを**オンデマンドインポート**と呼びます。

<span class="listing-number">**サンプルコード6-7**</span>

```java
import java.util.*; // java.utilパッケージの全クラスを対象にする

public class MyProgram {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ArrayList<String> list = new ArrayList<>();
        Random random = new Random();
    }
}
```
**注意:** オンデマンドインポートは、そのパッケージのさらに下のサブパッケージのクラスまではインポートしません（例： `import java.util.*` は `java.util.regex.Pattern` をインポートしない）。

### `import`文の注意点：名前の衝突

異なるパッケージに同じ名前のクラスが存在する場合、両方を同時にオンデマンドインポートしたり、個別にインポートしたりすると、コンパイラがどちらのクラスを使えばよいか判断できず、コンパイルエラーになります。

<span class="listing-number">**サンプルコード6-8**</span>

```java
import java.util.List;
import java.awt.List; // エラー: Listクラスが両方のパッケージに存在する

public class AmbiguousClass {
    // List list; // どちらのListか不明
}
```

このような場合は、片方を`import`し、もう片方は完全限定名で記述して、どちらのクラスを使うかを明示的に指定する必要があります。

<span class="listing-number">**サンプルコード6-9**</span>

```java
import java.util.List; // java.util.Listを主に使うと決める

public class SolvedAmbiguity {
    public static void main(String[] args) {
        List<String> utilList = new java.util.ArrayList<>(); // importした方
        java.awt.List awtList = new java.awt.List();      // 完全限定名で指定
    }
}
```

## 4.4 章末演習

本章で学んだ不変性とfinalキーワードを実践的な課題で確認しましょう。

### 演習課題へのアクセス

本書の演習課題は、以下のGitHubリポジトリで提供されています：

**リポジトリ**: `https://github.com/[your-repo]/java-primer-exercises`

### 第6章の課題構成

```
exercises/chapter06/
├── basic/              # 基礎課題（推奨）
│   ├── README.md       # 詳細な課題説明
│   └── ImmutableClass/ # 不変クラス設計課題
├── advanced/           # 発展課題（推奨）
├── challenge/          # チャレンジ課題（任意）
└── solutions/          # 解答例（実装後に参照）
```

### 学習の目標

本章の演習を通じて以下のスキルを習得します：
- finalキーワードの3つの用途（変数、メソッド、クラス）の適切な使用
- 完全な不変オブジェクトの設計と実装
- 防御的コピーによるデータの保護
- スレッドセーフなコードの作成

### 課題の概要

1. **基礎課題**: 不変なPointクラス - 基本的な不変オブジェクトの実装
2. **発展課題**: 不変コレクション - 防御的コピーを使った複雑な不変性の実現
3. **チャレンジ課題**: ビルダーパターン - 不変オブジェクトの柔軟な構築

詳細な課題内容と実装のヒントは、GitHubリポジトリの各課題フォルダ内のREADME.mdを参照してください。

**次のステップ**: 基礎課題が完了したら、第7章「抽象クラスとインターフェイス」に進みましょう。

## より深い理解のために

本章で学んだ不変性の基本概念をさらに深く理解したい方は、GitHubリポジトリの付録資料を参照してください：

**付録リソース**: `/appendix/b06-immutability-patterns/`

この付録では以下の高度なトピックを扱います：

- **完全な不変性の実現**: 防御的コピー、ビルダパターンとの組み合わせ
- **Copy-on-Writeパターン**: 効率的な構造共有、永続的データ構造
- **イミュータブルコレクション**: カスタム実装、Trieベースのマップ
- **関数型プログラミング**: レンズパターン、Redux風の状態管理
- **パフォーマンス最適化**: オブジェクトプーリング、遅延評価

これらの技術は、並行プログラミングや大規模システムの設計において大切な役割を果たします。