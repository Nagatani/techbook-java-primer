# 第4章 クラスとオブジェクト

前章ではJavaの基本構文について学びました。この章では、Javaの最も重要な概念であるクラスとオブジェクトについて詳しく学習します。

## 4.1 手続き型からオブジェクト指向へ

皆さんが学んできたC言語は、主に**手続き型プログラミング**という考え方に基づいています。これは、プログラムを「手順（関数）」の集まりとして捉え、データを関数に渡して処理する手法です。

一方、Javaは**オブジェクト指向プログラミング (OOP)** を中心とした言語です。OOPはプログラムを、**オブジェクト**の集まりとして捉えます。それぞれのオブジェクトは、各々の**データ（状態）**と、そのデータを操作する**手続き（振る舞い・機能）**をまとめて扱います。

### なぜオブジェクト指向なのか

* **現実世界のモデリング**: 「顧客」「商品」「注文」のように、現実世界の概念をそのままプログラムの構成要素（オブジェクト）として表現しやすいため、設計が直感的になります。
* **再利用性の向上**: 一度作成したクラス（オブジェクトの設計図）は、使い回すことができます。たとえば、「商品」クラスを作れば、在庫管理システムでも、販売システムなどの他のシステムでも利用できます。
* **保守性の向上**: データとそれに関連する操作がクラス内にまとまっている（これを**カプセル化**と言います）ため、変更の影響範囲を特定しやすく、修正や機能追加が容易になります。バグが特定のクラス内に限定されやすくなります。
* **分業のしやすさ**: 大規模なシステム開発において、クラス単位で開発を分担しやすくなり、適切なカプセル化により、効率の良い開発を進められます。

C言語の手続き型でも大抵のアプリケーションは作成できますが、複雑で大規模なシステムを構築する場合において、オブジェクト指向のアプローチが有効になる場面が多くあります。

## 4.2 クラスとオブジェクト - お店の商品を例に

オブジェクト指向の基本的な構成要素が「クラス」と「オブジェクト」です。お店の商品管理を例に考えてみましょう。

### C言語の構造体とJavaのクラス

C言語では、商品のデータを構造体で定義し、そのデータを操作する関数を別途用意していました。

```c
#include <stdio.h>
#include <string.h>

// C言語: データと操作は別々
struct Product {
    char name[50];
    int price;
    int stock;
};

// 在庫があるか確認する関数
int C_isInStock(struct Product *p) {
    return p->stock > 0;
}

int main() {
    struct Product apple;
    strcpy(apple.name, "Apple");
    apple.price = 150;
    apple.stock = 50;

    if (C_isInStock(&apple)) { // 関数にデータを渡してチェック
        printf("%s is in stock.\n", apple.name);
    }
    return 0;
}
```

Javaでは、これらをクラスとして一体化します。

```java
// Java: データ(フィールド)と操作(メソッド)がクラス内にまとまる
public class Product {
    String name;
    int price;
    int stock;

    // 在庫があるか確認するメソッド
    boolean isInStock() {
        // this.stock は、このメソッドが呼び出されたオブジェクト自身の stock フィールドを指す
        return this.stock > 0;
    }

    // 現在の状態を表示するメソッド
    void displayInfo() {
        System.out.println("商品名: " + this.name + ", 価格: " + this.price + "円, 在庫: " + this.stock + "個");
    }
}

public class Shop {
    public static void main(String[] args) {
        // Product クラスから apple オブジェクトを生成
        Product apple = new Product();
        apple.name = "りんご";
        apple.price = 150;
        apple.stock = 50;

        // オブジェクト自身が持つメソッドを呼び出す
        if (apple.isInStock()) {
            System.out.println(apple.name + " は在庫があります。");
        }
        apple.displayInfo();
    }
}
```

Javaのアプローチでは、`apple`というオブジェクト自身が`isInStock()`という「在庫確認能力」を持っている、というより管理しやすい形でプログラムを表現できます。

商品自体に在庫管理能力を持たせるべきか、商品を管理する別のクラスを作成してそちらで在庫管理を行わせるか、こういった組み合わせを考える作業を**設計**と呼びます。

設計は正解がなく、状況に応じて最適な選択を行う必要があります。オブジェクト指向でプログラミングを行う場合、もっとも難しいと思われる部分です。すぐに良い設計を思い浮かぶことはないと考えて、より良い設計はないかを意識しましょう。

### クラス (Class): 商品情報の「テンプレート」

クラスは、同じ種類のモノが共通して持つべき情報（状態や属性）と、できること（機能）を定義した「設計図」や「テンプレート」をイメージしてください。

例：お店にはさまざまな商品がありますが、「商品」というカテゴリで共通して「商品名」「価格」「在庫数」といった情報を持っています。また、「価格を表示する」「在庫があるか確認する」といった共通の操作が考えられます。この共通の定義をまとめたものが`Product`クラスです。

C言語との比較：C言語の構造体 (`struct`) は、関連するデータをまとめるものでした。Javaのクラスは、これらのデータ（**フィールド**）に加えて、そのデータを扱う**手続き（メソッド）**、たとえば `displayPrice()` や `isInStock()` といった関数に相当するものも一緒にクラス内で定義します。これが大きな違いです。

### オブジェクト (Object): 具体的な「商品」そのもの

オブジェクトは、クラスという設計図に基づいて、メモリ上に実際に作成された「実体」です。インスタンス (Instance) とも呼ばれます。

例：`Product`クラス（設計図）から、「りんご（商品名: "りんご", 価格: 150, 在庫数: 50）」という具体的な商品オブジェクトや、「みかん（商品名: "みかん", 価格: 100, 在庫数: 80）」という別の商品オブジェクトを作成します。

オブジェクトの生成（インスタンス化）は`new`というキーワードを使って、クラスからオブジェクトを生成します。`Product apple = new Product();`のように書きます。

### カプセル化：データと操作をひとまとめにする利点

クラスによって、関連性の高いデータ（フィールド）とそれを操作する手続き（メソッド）が1つの単位にまとめられます。これを**カプセル化**と呼びます。

* **安全性**: 外部から直接フィールドを不正に変更されることを防ぎ、メソッドを通じてのみ操作させるように制限できます（アクセス修飾子`private`などを使いますが、ここでは概念だけ説明します）。これにより、データの整合性を保ちやすくなります。
* **独立性**: クラス内部の仕組みを変更しても、外部への影響を最小限に抑えられます。たとえば、価格の計算方法が変わっても、`displayPrice()`メソッドの呼び出し方は変わらないように作れます。

## 4.3 フィールドとメソッド - 商品の情報とできること

クラスの具体的な中身（メンバ）である「フィールド」と「メソッド」について、もう少し詳しく見ていきましょう。

### フィールド (Field): 商品の「状態」や「属性」

オブジェクトが持つべき具体的な**データ**を保持します。管理対象となるオブジェクトの「状態」や「属性」を表します。

フィールドは、クラス内で変数を宣言することで定義します。

* 例（`Product`クラスの場合）
    * `String name;` // 商品名（文字列型）
    * `int price;` // 価格（整数型）
    * `int stock;` // 在庫数（整数型）

クラスを元に生成されたオブジェクト（インスタンス）は、それぞれ独自のフィールドに各々の値を持ちます。

### メソッド (Method): 商品の「機能」や「振る舞い」

オブジェクトが行える**操作**や**処理**を定義し、オブジェクトの「機能」や「振る舞い」を表します。

クラス内に関数を定義するような形で記述します。

* 例
    * フィールドの値を参照する（例: `getPrice()`, `getName()`）。
    * フィールドの値を変更する（例: `reduceStock(int amount)`, `setPrice(int newPrice)`）。
    * 特定の計算や処理を行う（例: `calculateTaxIncludedPrice()` 税込み価格を計算する）。
    * 情報を表示する（例: `displayInfo()`）。

#### `this`キーワード

メソッド内では、`this`というキーワードを使うことで、そのメソッドを呼び出している**オブジェクト自身**を参照できます。

`this.name`は「このオブジェクトの`name`フィールド」、`this.displayInfo()`は「このオブジェクトの`displayInfo`メソッド」を意味します。

多くの場合、フィールド名がメソッド内のローカル変数と衝突しなければ`this`は省略可能ですが、明示的につけることでコードが読みやすくなることもあります（とくにコンストラクタや値をフィールドに設定する目的のセッターメソッドでよく使われます）。

### `Product`クラスの例

```java
public class Product {
    String name;
    int price;
    int stock;

    // 在庫があるか確認するメソッド
    boolean isInStock() {
        return this.stock > 0;
    }

    // 現在の状態を表示するメソッド
    void displayInfo() {
        System.out.println("商品名: " + this.name + ", 価格: " + this.price + "円, 在庫: " + this.stock + "個");
    }

    // 価格をメッセージ形式で表示するメソッド
    void displayPrice() {
        System.out.println(this.name + " の価格は " + this.price + "円です。");
    }

    // 商品を売るメソッド (在庫を減らす)
    // amount: 売る数量
    void sell(int amount) {
        if (this.stock >= amount) {
            this.stock -= amount; // this.stock = this.stock - amount; と同じ
            System.out.println(this.name + " を " + amount + "個販売しました。残り在庫: " + this.stock);
        } else {
            System.out.println("エラー: " + this.name + " の在庫が足りません。(在庫: " + this.stock + ", 要求: " + amount + ")");
        }
    }

    // 在庫を補充するメソッド
    void restock(int amount) {
        this.stock += amount;
        System.out.println(this.name + " を " + amount + "個入荷しました。現在の在庫: " + this.stock);
    }
}

public class ShopInventory {
    public static void main(String[] args) {
        Product pencil = new Product();
        pencil.name = "鉛筆";
        pencil.price = 80;
        pencil.stock = 100;

        pencil.displayPrice(); // 鉛筆 の価格は 80円です。

        if (pencil.isInStock()) {
            System.out.println(pencil.name + " は在庫があります。");
        }

        pencil.sell(30); // 鉛筆 を 30個販売しました。残り在庫: 70
        pencil.sell(80); // エラー: 鉛筆 の在庫が足りません。(在庫: 70, 要求: 80)
        pencil.restock(50); // 鉛筆 を 50個入荷しました。現在の在庫: 120
        pencil.sell(80); // 鉛筆 を 80個販売しました。残り在庫: 40
    }
}
```

このように、フィールド（データ）とメソッド（操作）が一体となることで、「商品」オブジェクトが自身の情報に基づいて振る舞う、より現実に近いモデルをプログラムで表現できます。

## 4.4 コンストラクタ - オブジェクトの初期化

クラスから`new`を使ってオブジェクトを生成するとき、そのオブジェクトのフィールド（たとえば、商品の名前や価格）に初期値を設定したい場合がほとんどです。

毎回`apple.name = "りんご"; apple.price = 150;`のように手動で設定するのは手間ですし、設定し忘れる可能性もあります。

そこで登場するのが**コンストラクタ (Constructor)** です。

コンストラクタは、`new`でオブジェクトが生成される**直後に自動的に呼び出される**特別なメソッドです。主な目的は、オブジェクトの**フィールドを初期化**することで、オブジェクトが利用可能な状態（適切な初期状態）になることを保証することです。

### なぜ必要か？

* **初期値の保証**: オブジェクト生成時に、フィールドが必ず意味のある値で初期化されるように強制できます（例: 価格が未設定のまま商品が作られるのを防ぐ）。
* **必須情報の指定**: オブジェクトを作るために最低限必要な情報（例: 商品名と価格）を、生成時に引数として渡すように要求できます。
* **定型的な初期化処理**: オブジェクト生成時に毎回行う必要のあるセットアップ処理（例: IDの自動採番、関連オブジェクトの生成など）を記述できます。

### 書き方のルール

1. メソッド名は、**クラス名と完全に同じ**にする。
2. **戻り値の型（`void`など）を記述しない**。（戻り値を返せない）

### 特殊な**デフォルトコンストラクタ**

もしクラス内にコンストラクタを1つも定義しない場合、Javaコンパイラが「引数なし、中身が空のコンストラクタ」（デフォルトコンストラクタ）を自動的に生成します。

しかし、自分で1つでもコンストラクタを定義すると、このデフォルトコンストラクタは自動生成されなくなります。

### コンストラクタの例 (`Product`クラス)

```java
public class Product {
    String name;
    int price;
    int stock;

    // コンストラクタ (商品名と価格を引数で受け取り初期化)
    Product(String productName, int productPrice) {
        System.out.println("Productコンストラクタ(String, int) 呼び出し中...");
        // フィールド名と引数名が同じなので、this を使ってフィールドであることを明示
        this.name = productName;
        this.price = productPrice;
        this.stock = 0; // 在庫は初期状態で0にしておく
        System.out.println("商品「" + this.name + "」を価格" + this.price + "円で登録しました。");
    }

    // コンストラクタのオーバーロード (商品名、価格、初期在庫数を引数で受け取る)
    Product(String productName, int productPrice, int initialStock) {
        System.out.println("Productコンストラクタ(String, int, int) 呼び出し中...");
        this.name = productName;
        this.price = productPrice;
        this.stock = initialStock; // 引数で受け取った初期在庫を設定
        System.out.println("商品「" + this.name + "」を価格" + this.price + "円、初期在庫" + this.stock + "個で登録しました。");
    }

    // ... (他のメソッドは省略) ...
}

public class ShopSetup {
    public static void main(String[] args) {
        // コンストラクタを使ってオブジェクトを生成＆初期化
        // new Product(...) の時点でコンストラクタが呼ばれる
        Product orange = new Product("オレンジ", 120); // 1つ目のコンストラクタが呼ばれる
        Product banana = new Product("バナナ", 100, 50); // 2つ目のコンストラクタが呼ばれる

        System.out.println("--- 商品情報 ---");
        orange.displayInfo();
        banana.displayInfo();

        // Product grape = new Product(); // これはエラー！
        // 理由：引数ありのコンストラクタを定義したため、
        //      引数なしのデフォルトコンストラクタは自動生成されなくなった。
        //      もし引数なしでも生成したい場合は、引数なしのコンストラクタも自分で定義する必要がある。
    }
}
```

### 実行結果

```
Productコンストラクタ(String, int) 呼び出し中...
商品「オレンジ」を価格120円で登録しました。
Productコンストラクタ(String, int, int) 呼び出し中...
商品「バナナ」を価格100円、初期在庫50個で登録しました。
--- 商品情報 ---
商品名: オレンジ, 価格: 120円, 在庫: 0個
商品名: バナナ, 価格: 100円, 在庫: 50個
```

### コンストラクタのオーバーロード

上記の例のように、同じクラス内に**引数の型、数、または並び順が異なる**複数のコンストラクタを定義できます。

これを**オーバーロード (Overload)** と呼びます。これにより、オブジェクトの生成方法にバリエーションを持たせることができます（例: 初期在庫を指定する場合としない場合など、どちらにも対応可能）。

オーバーロードはカプセル化の際に重要な役割を持ちます。次回以降の解説になりますが、コンストラクタの他に、通常のメソッドもオーバーロードを実現できます。

## 4.5 mainメソッドとは

C言語の`main`関数と同様に、Javaでは「mainメソッド」がエントリーポイント（クラスを実行する際の入り口）となります。

### `main`メソッドの「おまじない」を解き明かす

```java
public static void main(String[] args) {
    // ここからプログラムが動く
}
```

この一行に含まれる各キーワードには、Javaプログラムを実行する上で重要な意味があります。

* **`public`**: アクセス修飾子で「公開されている」という意味
    - Javaプログラムを実行するJVM（Java Virtual Machine）は、OSなどプログラムの外部からこの`main`メソッドを探して呼び出す必要があります。そのため、どこからでもアクセスできるよう`public`になっている必要があります。もし`private`など他のアクセス修飾子だと、JVMが見つけられずプログラムを実行できません。
* **`static`**: 静的で「クラスに属する」という意味
    - JVMがプログラムの実行を開始するとき、最初に`main`メソッドを呼び出します。この時点では、まだそのクラスのオブジェクトが1つも生成されていないのが普通です。オブジェクトが存在しなくても呼び出せるように、`main`メソッドは`static`である必要があります。もし`static`でないと、JVMはどのオブジェクトの`main`メソッドを呼べばよいか分からなくなってしまいます。
* **`void`**: 戻り値の型で「何も返さない」という意味
    - `main`メソッドはプログラムの起点であり、一連の処理を実行した後、通常はプログラムを終了します。呼び出し元であるJVMに対して何か特別な値を返す必要がないため、戻り値の型は`void`となります。（C言語では`int main()`でOSに終了コードを返すのが一般的でしたが、Javaでは通常`System.exit(int status)`を使って明示的に終了コードを指定します）。
* **`main`**: メソッド名
    - JVMがプログラムの開始点として探すメソッドの名前が`main`である、というJavaの規約です。この名前でなければ、JVMは開始点を見つけられません。
* **`(String[] args)`**: 引数
    - プログラム実行時に外部から渡される情報（**コマンドライン引数**）を受け取るためのパラメータです。`String[]`は「`String`（文字列）の配列」であることを意味し、`args`はその配列の変数名です（慣習的に`args`が使われますが、他の名前でも構いません）。たとえば、`java MyProgram arg1 arg2`のように実行した場合、`args`配列には`{"arg1", "arg2"}`という内容が格納されます。

### mainメソッドのルール

Javaのmainメソッドは、以下の条件をすべて満たしているメソッドです。

1. アクセス修飾子はpublic
2. staticメソッド
3. メソッドの戻り値はvoid
4. メソッド名は"main"である（すべて小文字）
5. メソッドの引数の型はStringの配列`String[]`またはStringの可変長引数`String...`のみ（引数名はargsでなくても良い）

```java
class Main {
    public static void main(String[] args) {
        // 何かの処理
    }
}
```

```java
class Main {
    // これでもOK
    public static void main(String... arguments) {
        // 何かの処理
    }
}
```

### mainメソッドの条件はしっかりとチェックされる

mainメソッドの条件は、Javaの実行時にきっちりチェックされます。たとえば、以下のようなものはJavaのメソッドとしては文法どおりなのでコンパイルはできますが、mainメソッドとしては認識されません。

```java
// アクセス修飾子がpublicではない
static void main(String[] args) { }
// メソッドがstaticではない
public void main(String[] args) { }
// メソッドの戻り値がvoidではない
public static int main(String[] args) { }
// メソッド名が"main"ではない
public static void Main(String[] args) { }
// 引数がStringの配列または可変長引数ではない
public static void main(String args) { }
// 引数がStringの配列だけではない(intが邪魔)
public static void main(String[] args, int intValue) { }
```

### mainメソッドを終わらせかた

mainメソッドはプログラム中で一番最初に動くものだとは言え、普通のメソッドです。

mainメソッドの最後まで処理が進めば終わりますし、途中で`return;`すれば、そのタイミングで終わらせられます。

C言語のプログラムと違い、単純にreturnした場合は、プログラムからの戻り値を指定できません。returnで終了させてしまった場合のプログラムからの戻り値が設定される変数"ERRORLEVEL"の内容は0ですが、これはJavaの中で戻り値を指定せず、プログラム実行中にエラーが起きなかった場合に標準的な動作です。

プログラム中でエラーが起きた場合などは、戻り値をエラーの種類を表す何かの数字にしたい場合、`System.exit()`や`Runtime.exit()`を使い、引数に渡す数字でエラーを指定します。

## 4.6 nullとクラス型の変数

クラス型の変数の取り扱いについてと、nullについて理解することは、Javaでのプログラミングでは重要です。

### nullとは

**何もない**が**ある**状態を言います。

`null`は、「メモリ空間にそのオブジェクトの実体を指し示すアドレスがない状態」を指します。

Javaだけでなく、他の言語でもですが、バグの発生要因ダントツナンバーワンの憎めないやつです。

### クラス型のオブジェクト

- Javaの基本的な型であるプリミティブ型の変数は、初期化をしないとコンパイルエラー、もしくはクラスのフィールドの場合は勝手に初期値が代入されます。しかしクラス型のオブジェクトは、変数を宣言した状態では（つまりインスタンス化しない場合は）、初期値がnullとなります。
- クラス型の変数同士でコピーをすれば同じものとして扱われます。
- 変数が指し示すものは、**オブジェクトが格納されているメモリアドレス**となります。

### 変数の初期値について

クラスのフィールド、staticなフィールド（クラス変数）または配列の1つ1つの要素は生成されるときに初期値で初期化されます。

初期値は変数の型ごとに異なり、標準仕様では以下のようになっています。

| 型 | 初期値 |
|---|----------|
| byte | `0` |
| short | `0` |
| int | `0` |
| long | `0L` |
| float | `0.0f` |
| double | `0.0d` |
| char | `'\u0000'` |
| boolean | `false` |
| クラス型(String型も含む) | `null` |

### nullの発生

繰り返しますが、`null`はクラス型変数で使われる特別な値です。これは、**「その変数がどのオブジェクトも参照していない（指し示していない）状態」**を表します。

* 基本データ型（`int`など）の変数には`null`を代入することはできません。
* クラス型の変数は、初期状態や、意図的にオブジェクトとの関連を切った場合`null`になることがあります。
* クラス型の配列（`String[]`など）は、要素すべてが`null`として初期化されています。

例：

```java
String message; // この時点では、message は何も参照していない（未初期化）
message = null; // message に null を代入（どのオブジェクトも参照しない状態を明示）
String greeting = "こんにちは"; // greeting は "こんにちは" という文字列オブジェクトを参照

int number = 0; // 基本データ型は null にできない
// int count = null; // これはコンパイルエラーになる

String[] strArray = new String[5]; // strArray[0]〜strArray[4]まですべてnull
```

### `NullPointerException`とそれを防ぐ

`null`の状態の変数に対して、そのオブジェクトが持つはずのメソッド（機能）を呼び出そうとしたり、フィールド（データ）にアクセスしようとすると、プログラムは「参照先がないのに操作しようとしている！」とエラーを起こして停止してしまいます。このエラーが`NullPointerException`です。

`NullPointerException`はJavaプログラミングで非常によく遭遇するエラーの1つです。これを未然に防ぐため、クラス型変数を使用する前に、その変数が`null`でないかを確認（比較）することが非常に重要になる場合が想定されます。

```java
String text = null;

// textがnullなのに、length()メソッドを呼び出そうとすると…
// System.out.println(text.length()); // ここで NullPointerException が発生！

// ↓のように、事前にnullかどうかをチェックする
if (text != null) {
    // null でない場合のみ、メソッドを呼び出す
    System.out.println(text.length());
} else {
    System.out.println("text は null です。");
}
```

### `null`の比較方法

変数が`null`かどうかを比較するには、比較演算子`==`（等しい）または`!=`（等しくない）を使います。

* `変数 == null`: 変数が`null`である場合`true`になります。
* `変数 != null`: 変数が`null`でない（何らかのオブジェクトを参照している）場合`true`になります。

```java
String name = null;

if (name == null) {
    System.out.println("変数 name は null です。");
}

name = "山田太郎";

if (name != null) {
    System.out.println("変数 name は null ではありません。値: " + name);
}
```

### 配列と`null`

クラス型の配列を作成した場合、その配列の**各要素の初期値は自動的に`null`になります**。

これは、配列が確保された段階では、各要素がまだどのオブジェクトも参照していないからです。

```java
// String型の配列で見てみましょう
String[] words = new String[3]; // 要素数が3のString配列を生成

// 配列生成直後の各要素は null になっている
System.out.println("配列生成直後:");
for (int i = 0; i < words.length; i++) {
    // 要素が null かどうかチェック
    if (words[i] == null) {
        System.out.println("words[" + i + "] は null です。");
    } else {
        // この時点ではここは実行されない
        System.out.println("words[" + i + "] は " + words[i] + " です。");
    }
}

// 配列の要素にオブジェクト（文字列）を代入
words[0] = "Java";
words[2] = "Programming"; // words[1] は null のまま

System.out.println("\n一部の要素に代入後:");
for (int i = 0; i < words.length; i++) {
    // 配列要素を使用する前に null チェック！
    if (words[i] != null) {
        // null でない要素に対してのみ操作を行う
        System.out.println("words[" + i + "] の長さ: " + words[i].length());
    } else {
        System.out.println("words[" + i + "] は null なので処理をスキップします。");
    }
}
```

この例のように、クラス型の配列を扱う際は、**各要素へアクセスする前に`null`チェックを行う**ことが`NullPointerException`を避けるための定石です。とくに、ループ処理で配列の全要素を順に扱う場合には注意が必要です。

## まとめ

Javaのクラスは、「C言語の構造体に関数を内包できるようにしたもの」と覚えておくとよいでしょう。

クラス設計のポイントは、どのデータ（状態）とそれに対するメソッド（機能）をどうやってまとめて管理するか、をしっかりと考えることです。

設計から学ぶことはそれなりに難易度が高いので、プログラムの書き方をきちんと覚えつつ、どのように管理するかを継続的に考えましょう。

* **クラス型変数はオブジェクトの「参照」を保持します。**
* **`null`は、変数がどのオブジェクトも参照していない状態を表します。**
* **`null`の変数に対してメソッド呼び出しなどを行うと`NullPointerException`が発生します。**
* **`NullPointerException`を防ぐために、`== null`や`!= null`を使って、変数を使用する前に`null`チェックを行いましょう。**
* **クラス型の配列を作成すると、各要素の初期値は`null`になります。配列要素にアクセスする際も`null`チェックを忘れないようにしましょう。**

`null`チェックは、安全で堅牢なJavaプログラムを作成するための基本的ながら非常に重要なテクニックです。