## 第2章 Java基本文法 - Part C: メソッドと文字列処理

### 2.14 メソッド（関数）

**事前説明：**
メソッド（関数）は、特定の処理をまとめて名前を付け、必要な時に呼び出して使用するしくみです。コードの再利用性を高め、プログラムの構造を整理し、保守性を向上させる重要な概念です。Javaのメソッドは、C言語の関数の概念を発展させ、オブジェクト指向プログラミングの基礎となる機能を提供しています。

```java
public class Calculator {
    // メソッドの定義
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double divide(double a, double b) {
        if (b == 0) {
            System.out.println("ゼロ除算エラー");
            return 0;
        }
        return a / b;
    }
    
    public static void main(String[] args) {
        int result = add(10, 5);
        System.out.println("結果: " + result);
        
        double divResult = divide(10.0, 3.0);
        System.out.println("除算結果: " + divResult);
    }
}
```

**このコードで学習できる重要な概念：**

- **メソッドシグネチャの構成**：`public static int add(int a, int b)`の各要素（アクセス修飾子、static修飾子、戻り値の型、メソッド名、パラメータ）の意味と役割を理解できます。
- **型安全なパラメータ渡し**：引数の型が明確に定義されており、コンパイル時に型の不整合を検出できます。
- **戻り値の型宣言**：メソッドが返す値の型を明示することで、呼び出し側で適切な変数で結果を受け取れます。
- **エラーハンドリングの実装**：ゼロ除算チェックにより、実行時エラーを防ぐ防御的プログラミングの手法を学習できます。
- **静的メソッドの特徴**：`static`修飾子により、オブジェクトの生成なしにメソッドを呼び出せる便利性を理解できます。

**メソッド設計の重要な原則：**

- **単一責任の原則**：`add`メソッドは加算のみ、`divide`メソッドは除算のみを担当し、1つのメソッドが1つの明確な役割を持っています。
- **再利用性の実現**：一度定義したメソッドは、プログラム内の任意の場所から何度でも呼びだすことができます。
- **デバッグの容易性**：問題が発生した場合、特定のメソッド内に原因を特定しやすくなります。
- **可読性の向上**：メソッド名により処理内容が明確になり、プログラムの意図が理解しやすくなります。

**高度なメソッド活用例：**

```java
// メソッドオーバーロードの例
public static int add(int a, int b) {
    return a + b;
}

public static double add(double a, double b) {
    return a + b;
}

public static int add(int a, int b, int c) {
    return a + b + c;
}
```

**C言語との比較における学習ポイント：**

- **クラス内での定義**：Javaのメソッドは必ずクラス内に定義される必要があり、グローバル関数は存在しません。
- **アクセス制御**：`public`、`private`などの修飾子により、メソッドの可視性を細かく制御できます。
- **オーバーロード機能**：同じ名前で異なるパラメータを持つメソッドを複数定義でき、利便性が向上します。
- **例外処理システム**：エラー処理がより構造化され、安全なプログラムの作成を支援します。

### 2.15 文字列処理

Javaにおける文字列処理は、C言語のアプローチとは根本的に異なる設計思想にもとづいています。C言語では文字列を文字の配列として扱い、終端文字（\0）で管理していましたが、Javaでは文字列を第一級のオブジェクトとして扱います。この設計により、文字列の長さの管理、メモリの確保と解放、バッファオーバーフローの防止など、C言語で頻繁に問題となっていた課題が根本的に解決されています。さらに、豊富な文字列操作メソッドが標準で提供され、複雑な文字列処理も簡潔かつ安全に実装できるようになりました。

#### 文字列の基本

文字列オブジェクトの作成と基本操作は、Javaプログラミングにおいて最も頻繁に使用される機能の1つです。以下のコード例では、文字列の作成、連結、長さの取得、個別文字へのアクセスという基本的な操作を示します：

```java
// 文字列の作成
String str1 = "Hello";
String str2 = new String("World");

// 文字列の連結
String message = str1 + " " + str2;  // "Hello World"

// 文字列の長さ
int length = message.length();  // 11

// 文字の取得
char firstChar = message.charAt(0);  // 'H'
```

このコードで注目すべき重要な概念は、文字列リテラル（`"Hello"`）と`new`キーワードを使用した文字列作成の違いです。文字列リテラルはJVMが管理する文字列プールに格納され、同じ内容の文字列は共有されます。これは、メモリ効率とパフォーマンスの最適化のための重要なしくみです。一方、`new String()`は常に新しいオブジェクトを作成するため、通常は文字列リテラルの使用が推奨されます。

#### 文字列の比較

文字列の比較は、Javaプログラミングで最も誤解されやすい概念の1つです。C言語では`strcmp()`関数を使用していましたが、Javaではオブジェクトの比較という観点から、より慎重なアプローチが必要です。以下のコード例で、参照の比較と内容の比較の重要な違いを示します：

```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");

// == は参照の比較（推奨されない）
boolean ref1 = (s1 == s2);    // true（文字列プール）
boolean ref2 = (s1 == s3);    // false

// equals() は内容の比較（推奨）
boolean content1 = s1.equals(s2);  // true
boolean content2 = s1.equals(s3);  // true

// 大文字小文字を無視した比較
boolean ignore = s1.equalsIgnoreCase("java");  // true
```

このコードは、Javaの文字列比較における重要な教訓を示しています。`==`演算子はオブジェクトの参照（メモリアドレス）を比較するため、文字列の内容が同じでも異なるオブジェクトであれば`false`を返します。特に注意すべきは、文字列プールの存在により`s1 == s2`が`true`となる点です。これは偶然の一致であり、信頼すべきではありません。常に`equals()`メソッドを使用して文字列の内容を比較することが、バグのない堅牢なプログラムを作成する鍵となります。

#### 便利な文字列操作メソッド

Javaの`String`クラスは、テキスト処理に必要な豊富なメソッドを提供しています。これらのメソッドは、Web開発でのユーザー入力の処理、データベースから取得した文字列の整形、ファイルの読み書きなど、実際の開発で頻繁に使用されます。以下のコード例で、最も重要な文字列操作メソッドを実践的に学習します：

```java
String text = "  Java Programming  ";

// 空白の除去
String trimmed = text.trim();  // "Java Programming"

// 大文字・小文字変換
String upper = text.toUpperCase();  // "  JAVA PROGRAMMING  "
String lower = text.toLowerCase();  // "  java programming  "

// 部分文字列の取得
String sub = text.substring(2, 6);  // "Java"

// 文字列の置換
String replaced = text.replace("Java", "Python");  // "  Python Programming  "

// 文字列の分割
String csv = "apple,banana,orange";
String[] fruits = csv.split(",");  // ["apple", "banana", "orange"]

// 文字列の検索
int index = text.indexOf("Pro");  // 7
boolean contains = text.contains("Java");  // true
```

これらのメソッドは、単なる文字列操作の道具ではなく、実際のビジネスロジックを実装する上で不可欠な要素です。`trim()`メソッドはユーザー入力の前後の空白を除去してデータの一貫性を保ち、`split()`メソッドはCSVファイルの解析や構造化データの処理に使用されます。`indexOf()`と`contains()`は検索機能の実装に欠かせず、`replace()`はテンプレート処理やデータのサニタイゼーションで活用されます。重要なのは、これらすべてのメソッドが元の文字列を変更せず、新しい文字列を返すという点です。

#### 文字列の不変性（Immutability）

Javaの文字列設計における最も重要な特徴の1つが不変性（Immutability）です。この設計思想は、最初は直感に反するように感じるかもしれませんが、スレッドセーフティ、セキュリティ、パフォーマンスの観点から極めて重要な役割を果たしています。文字列が不変であることにより、複数のスレッドが同じ文字列オブジェクトを安全に共有でき、予期しない変更によるバグを防ぐことができます。以下のコード例で、この重要な概念を実際に確認してみましょう：

```java
String str = "Hello";
str.concat(" World");  // str自体は変更されない
System.out.println(str);  // "Hello"

// 新しい文字列を作成して代入する必要がある
str = str.concat(" World");
System.out.println(str);  // "Hello World"
```

このコードは、`concat()`メソッドを呼び出しても元の文字列オブジェクトが変更されないことを示しています。これは、C言語の`strcat()`関数とは根本的に異なる動作です。Javaでは、文字列操作メソッドは常に新しい文字列オブジェクトを返し、元のオブジェクトはそのまま保持されます。この設計により、文字列を辞書のキーやハッシュマップのキーとして安全に使用でき、文字列プールによる最適化も可能になっています。

#### StringBuilderによる効率的な文字列操作

文字列の不変性は多くの利点をもたらしますが、頻繁な文字列操作が必要な場合にはパフォーマンスの問題を引き起こす可能性があります。なぜなら、文字列を連結するたびに新しいオブジェクトが作成され、古いオブジェクトはガベージコレクションの対象となるからです。この問題を解決するために、Javaは`StringBuilder`クラスを提供しています。`StringBuilder`は内部にmuテーブルな（変更可能な）文字配列を持ち、効率的な文字列操作を可能にします：

```java
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(" ");
sb.append("World");
sb.insert(5, ",");  // "Hello, World"
sb.reverse();       // "dlroW ,olleH"

String result = sb.toString();
```

このコードは、`StringBuilder`の威力を示しています。`append()`メソッドは既存の内容に文字列を追加し、`insert()`は指定位置に文字列を挿入し、`reverse()`は文字列全体を反転させます。これらの操作はすべて同じオブジェクト上で行われるため、メモリ効率が大幅に向上します。

`StringBuilder`を使用すべき典型的な場面は、ループ内での文字列連結です。たとえば、1000個の要素を連結する場合、通常の文字列連結では約50万個の一時オブジェクトが作成される可能性がありますが、`StringBuilder`を使用すれば、最小限のオブジェクト作成で済みます。また、ログファイルの生成、SQLクエリの動的構築、HTMLやXMLの生成など、大量の文字列操作を伴う処理でも`StringBuilder`は不可欠です。ただし、単純な文字列連結や、変更頻度の低い場合は、可読性の観点から通常の文字列操作を使用することが推奨されます。

### Java基本文法の総合的な理解

本章で学習した各要素は、独立したテクニックではなく、現代のソフトウェア開発における包括的な設計哲学の一部です。出力メソッドから始まり、データ型、変数、演算子、制御構造、配列、メソッドまで、すべてがJavaの「安全性」「保守性」「可読性」という3つの核心原則にもとづいて設計されています。

**学習した内容の相互関係と実践への応用：**

- **型安全性の一貫した実装**：`System.out.println`による自動型変換、明示的な変数宣言、メソッドのシグネチャ、配列の境界チェックなど、すべての機能が型の整合性を保証しています。
- **オブジェクト指向への基盤構築**：staticメソッド、クラス内でのメソッド定義、String型の活用など、本章で学んだ要素はすべて次章以降のオブジェクト指向学習への準備となっています。
- **C言語からの進化の理解**：単なる機能追加ではなく、ソフトウェア開発の課題（メモリ管理、プラットフォーム依存性、保守性）を根本的に解決するための設計思想の変革を体験できました。

**現代的なプログラミング手法への接続：**

今回学習した基本文法は、フレームワーク開発、Webアプリケーション構築、マイクロサービスアーキテクチャ、クラウドネイティブ開発など、現代のあらゆるJava開発の基盤となります。型安全性、例外処理、適切なメソッド設計などの概念は、企業での実際の開発において直接活用される重要なスキルです。

---

次のパート：[Part D - クラスとオブジェクトの基礎](chapter02d-class-basics.md)
