# 第3章 クラス設計と継承

## 🎯総合演習プロジェクトへのステップ

本章で学ぶ「クラス」の概念は、**総合演習プロジェクト「ToDoリストアプリケーション」** の心臓部となる`Task`クラスを設計・実装するための基礎となります。

- **`Task`クラスの設計**: 1つのタスクが持つべき情報（タスクの内容、完了状態など）をフィールドとして定義します。
- **カプセル化**: タスクの状態を安全に管理するため、フィールドを`private`にし、メソッドを通じてのみ操作できるようにします。
- **コンストラクタ**: 新しいタスクが作成される際に、必要な初期設定（タスク内容の設定など）を行います。

本章を通じて、単なるデータの集まりではなく、責任と振る舞いを持った「オブジェクト」としてタスクをモデル化する手法を学びます。

## 📋 本章の学習目標

### 前提知識
- **第2章の完全な習得**：基本的なクラス設計と実装経験
- **オブジェクト指向の基本概念**：カプセル化、コンストラクタ、メソッドの理解
- **複数クラスを含むプログラム**：クラス間の基本的な関係の実装経験

### 到達目標

#### 知識理解目標
- 継承の概念と利点の深い理解
- is-a関係とhas-a関係の区別
- メソッドオーバーライドのしくみ
- 抽象クラスの役割と設計指針
- superキーワードの役割と使用場面

#### 技能習得目標
- 継承階層の設計と実装
- superキーワードの効果的な使用
- メソッドオーバーライドの適切な実装
- 抽象クラスの定義と活用
- 継承を使ったコードの再利用

#### 到達レベルの指標
- [ ] 3層以上の継承階層を持つシステムが設計・実装できる
- [ ] 抽象クラスを活用した拡張可能な設計ができる
- [ ] 継承とコンポジションの使い分けができる
- [ ] デザインパターン（Template Method、Factory Method）の基本的な実装ができる

---

## 始めに：継承によるコードの再利用と拡張性

前章では、オブジェクト指向プログラミングの思想的背景について学習しました。本章では、Javaプログラミングの実践的な基礎となる「継承」について詳細に学習します。

これらの概念は、単なる文法規則ではありません。プログラミング言語における「型システム」は、コンピュータサイエンスの長い歴史の中で発展してきた、プログラムの正確性と効率性を保証するための重要なしくみです。

### コンピュータにおけるデータ表現の歴史

コンピュータの歴史を振り返ると、データの表現方法は段階的に進化してきました。初期のコンピュータでは、すべてのデータは単純な0と1のビット列として扱われていました。プログラマは、このビット列が数値を表すのか、文字を表すのか、命令を表すのかを、自分で管理する必要がありました。

1940年代から1950年代の初期のコンピュータでは、「型」という概念は存在せず、プログラマは以下のような課題に直面していました：

**データの意味のあいまい性**：同じビット列が、文脈によって整数、浮動小数点数、文字、アドレスなど、さまざまな意味を持つことがありました。このあいまい性は、プログラムのバグの重要な原因となっていました。

**演算の不適切性**：たとえば、文字列データに対して数値演算を行ってしまったり、ポインタを数値として加算してしまったりするなど、論理的に不適切な操作が可能でした。

**メモリ管理の困難さ**：異なる種類のデータが混在するメモリ領域で、どの部分がどのような構造を持つかを追跡することが極めて困難でした。

**移植性の欠如**：異なるハードウェアアーキテクチャでは、同じデータでも異なるビット表現を持つことがあり、プログラムの移植が困難でした。

### 型システムの誕生と発展

これらの問題を解決するため、1950年代から1960年代にかけて、プログラミング言語に「型システム」という概念が導入されました。型システムは、データの意味と操作を明確に定義し、不適切な操作をコンパイル時または実行時に検出するしくみです。

**FORTRAN（1957年）**：科学技術計算向けに開発された言語で、INTEGER（整数）、REAL（実数）、LOGICAL（論理値）などの基本的な型を導入しました。これにより、数値計算の精度と信頼性が大幅に向上しました。

**COBOL（1959年）**：事務処理向けに開発された言語で、固定小数点数、文字列、日付などのビジネス処理に特化した型を提供しました。

**ALGOL 60（1960年）**：構造化プログラミングの基礎となった言語で、より厳密な型システムを導入し、現代の型システムの基盤を築きました。

**Pascal（1970年）**：ニクラウス・ヴィルト（Niklaus Wirth）によって開発された言語で、強い型付けという概念を確立しました。型の適合性がコンパイル時に厳密にチェックされ、型安全性の重要性が認識されるようになりました。

### 静的型付けと動的型付けの対比

プログラミング言語の型システムは、大きく「静的型付け」と「動的型付け」に分類されます。この違いを理解することは、Javaの型システムの特徴を理解する上で重要です。

**静的型付き言語**：変数の型がコンパイル時に決定され、実行前に型の整合性がチェックされます。Java、C、C++、C#などがこのカテゴリに属します。

静的型付けの利点：
- コンパイル時のエラー検出により、多くのバグを実行前に発見できる
- IDEによる強力なコード補完とリファクタリング支援
- 実行時の型チェックが不要なため、実行性能が高い
- 大規模開発における安全性と保守性の向上

**動的型付き言語**：変数の型が実行時に決定され、実行中に型が変更される可能性があります。Python、JavaScript、Ruby、PHPなどがこのカテゴリに属します。

動的型付けの利点：
- 型宣言が不要で、記述が簡潔
- 実行時の柔軟性が高い
- プロトタイピングや小規模スクリプトに適している
- より表現力豊かなプログラミングが可能

### Javaの型システムの革新性

Javaの型システムは、従来の静的型付き言語の利点を保ちながら、新しい革新的な特徴を導入しました：

**プリミティブ型と参照型の明確な分離**：性能を重視する場面では直接的なプリミティブ型を使用し、オブジェクト指向の恩恵を受けたい場面では参照型を使用するという、柔軟な選択が可能になりました。

**自動ボクシング・アンボクシング**：Java 5以降では、プリミティブ型とそのラッパクラス間の変換が自動化され、型システムの複雑性を隠蔽しながら利便性を向上させました。

**ジェネリクス**：型パラメータを使用することで、型安全性を保ちながらコードの再利用性を大幅に向上させました。

**強い型安全性**：C++のような型の抜け道（キャスト演算子による強制変換など）を制限し、より安全な型システムを実現しました。

### メモリ管理と型システムの関係

Javaの型システムのもう1つの重要な特徴は、自動メモリ管理（ガベージコレクション）との緊密な統合です。従来のC/C++では、プログラマがメモリの確保と解放を手動で管理する必要がありましたが、これは以下のような深刻な問題を引き起こしていました：

**メモリリーク**：確保したメモリを解放し忘れることで、利用可能メモリが徐々に減少し、最終的にシステムがクラッシュする問題です。

**ダングリングポインタ**：解放されたメモリ領域を指すポインタを使用することで、予期しない動作やセキュリティホールを引き起こす問題です。

**二重解放**：同じメモリ領域を複数回解放しようとすることで発生する、深刻なプログラムクラッシュです。

Javaでは、型システムとガベージコレクションの統合により、これらの問題が根本的に解決されています：

**参照の明確な管理**：すべてのオブジェクトへのアクセスは参照を通じて行われ、直接的なメモリアドレス操作は禁止されています。

**自動的な生存期間管理**：オブジェクトの生存期間は、参照の有無によって自動的に管理され、不要になったオブジェクトは自動的に回収されます。

**型安全な配列アクセス**：配列の境界チェックが実行時に行われ、バッファオーバーフローによるセキュリティ脆弱性を防ぎます。

### プリミティブ型の設計思想

Javaにおけるプリミティブ型の設計は、性能と安全性のバランスを取る巧妙なしくみです。オブジェクト指向言語でありながら、基本的なデータ型をオブジェクトとして扱わない理由は、以下の実用的な考慮によるものです：

**性能の最適化**：整数や浮動小数点数などの基本的な計算は、プログラムの実行において最も頻繁に行われる操作です。これらをオブジェクトとして扱うと、メモリ使用量と実行時間の大幅なオーバーヘッドが発生します。

**数値計算の精度保証**：IEEE 754浮動小数点標準に準拠した精密な数値表現により、科学技術計算や金融計算における信頼性を確保しています。

**プラットフォーム独立性**：プリミティブ型のサイズと表現を言語仕様で固定することで、異なるプラットフォーム間での完全な互換性を実現しています。

### 現代的なプログラミングパラダイムとの統合

現代のJava開発では、従来の型システムに加えて、新しいプログラミングパラダイムが統合されています：

**関数型プログラミング**：Java 8で導入されたラムダ式と関数型インターフェイスにより、型安全な関数型プログラミングが可能になりました。

**null安全性**：Java 8のOptionalクラスにより、null参照による実行時エラーを型システムレベルで防ぐしくみが導入されました。

**パターンマッチング**：Java 14以降で導入されたswitc式とパターンマッチングにより、より表現力豊かで安全な制御構造が利用できるようになりました。

**値型の導入**：Project Valhallaプロジェクトでは、オブジェクトの利便性とプリミティブ型の性能を両立する新しい型システムが研究されています。

### 本章で学習する内容の意義

本章では、これらの歴史的背景と技術的意義を踏まえて、Javaの基本構文とデータ型を体系的に学習していきます。単に文法を覚えるのではなく、以下の点を重視して学習を進めます：

**型安全性の実践**：なぜ型が重要なのか、どのような場面で型エラーが発生するのかを理解し、安全なプログラムを作成する能力を身につけます。

**適切な型の選択**：問題の性質に応じて最適なデータ型を選択する判断力を養い、性能と保守性を両立したプログラムを作成する能力を習得します。

**現代的な機能の活用**：自動ボクシング、ジェネリクス、関数型インターフェイスなど、現代的なJava機能を効果的に活用する技術を身につけます。

**将来への拡張性**：基本的な型システムを深く理解することで、より高度なライブラリやフレームワークの学習、新しい言語機能の習得の基盤を築きます。

型システムを深く理解することは、単にJavaプログラマとしての技術向上だけでなく、プログラミング全般における思考力の向上にもつながります。データの性質を正確に理解し、適切な抽象化を行い、安全で効率的なプログラムを設計する能力は、あらゆるプログラミング言語で活用できる普遍的なスキルです。

本章を通じて、Javaという言語の持つ型システムの力強さと精密さを理解し、現代のソフトウェア開発者として必要な基礎的な素養を身につけていきましょう。

ここから、Javaを使ったオブジェクト指向プログラミングを学びますが、そもそもそれ以前に、Javaというプログラミング言語の基本構文について学びましょう。

## 3.1 型とリテラル

### 型

型、またはデータ型とは、プログラミング言語における「データを保持する形式」という認識で（いまのところは）良いでしょう。  
Javaにおける基本的な型の種類は以下の表を参照してください。

| 型名 | サイズ | 用途 | 想定される値 | ラッパクラス |
|-----|-----------------|-----|------------|--------------|
| `boolean` | -  | 真偽値 | true または false | Boolean
| `char` | 2byte | 文字(一文字分) | \u0000 〜 \uffff | Character
| `byte` | 1byte | 整数 | -128 〜 127 | Byte
| `short` | 2byte | 整数 | -32768 〜 32767 | Short
| `int` | 4byte | 整数 | -2147483648 〜 2147483647 | Integer
| `long` | 8byte | 整数  | -9223372036854775808 〜 9223372036854775807 | Long
| `float` | 4byte | 単精度浮動小数点  | 1.4E-45 〜 3.4028235E38 | Float
| `double` | 8byte | 倍精度浮動小数点 | 4.9E-324 〜 1.7976931348623157E308 | Double

これらの型は`プリミティブ型（または基本型）`と呼ばれ、Java言語仕様では特殊な型となります。  
見分け方は、先頭が小文字で始まっている型はプリミティブ型、先頭が大文字で始まっている型はクラス型と呼ばれ、文字列型であるStringは後者になります。
（クラスを自分で作成する場合には、先頭を大文字で始めるように注意しましょう）

Javaでのプリミティブ型には、すべてラッパクラスと呼ばれるクラス型にてプリミティブ型をラッピングしたクラスが存在します。表のラッパクラスはそれぞれの型に対応したクラス型で、それぞれのプリミティブ型特有の処理などが含まれています（たとえば、文字列からそのプリミティブ型に変換する処理など）

また、プリミティブ型の変数にはプログラムの実行時に、変数が指し示すメモリアドレス上に値そのままで展開・配置されます。
値がない状態を許容しないため、その変数を実際に使用する前に必ず初期値の代入が必要です。

#### 数値の型の最大値最小値を見るサンプル

プログラミングにおいて、各データ型の限界を理解することは、安全で信頼性の高いプログラムを作成するための重要な基礎知識です。以下のプログラムは、Javaの数値型が持つ範囲を実際に確認し、ラッパクラスの機能を活用して型情報を取得する方法を示しています。

このプログラムは、プリミティブ型とラッパクラスの関係、そしてJavaの型システムがどのように設計されているかを理解するための重要な学習材料です：

ファイル名：MinMaxValues.java

```java
public class MinMaxValues {
    public static void main(String[] args){
        System.out.println("short: " + Short.MIN_VALUE + " 〜 " + Short.MAX_VALUE);
        System.out.println("int: " + Integer.MIN_VALUE + " 〜 " + Integer.MAX_VALUE);
        System.out.println("long: " + Long.MIN_VALUE + " 〜 " + Long.MAX_VALUE);
        System.out.println("float: " + Float.MIN_VALUE + " 〜 " + Float.MAX_VALUE);
        System.out.println("double: " + Double.MIN_VALUE + " 〜 " + Double.MAX_VALUE);
    }
}
```

**このプログラムから学ぶ重要な概念：**

1. **ラッパクラスの必要性**：プリミティブ型（short, int, longなど）は、性能を重視した簡素なデータ型であり、自身にメソッドや定数を持つことができません。ラッパクラス（Short, Integer, Longなど）は、これらのプリミティブ型に関連するユーティリティ機能を提供します。

2. **型安全性とオーバーフロー防止**：各型の`MIN_VALUE`と`MAX_VALUE`を知ることで、数値のオーバーフローやアンダーフローを防ぐための検証コードを書くことができます。たとえば、ユーザー入力や計算結果が有効範囲内であるかをチェックできます。

3. **適切な型選択の根拠**：各型の範囲を理解することで、アプリケーションの要件に応じて最適なデータ型を選択できます。たとえば、年齢を表すのにbyte型で十分ですが、人口数を表すのにはlong型が必要かもしれません。

4. **メモリ効率と性能のバランス**：小さな範囲の型（byte, short）はメモリ消費量が少ない一方、大きな範囲の型（long, double）はより幅広い値を扱えます。アプリケーションの要件に応じて適切なバランスを選択することが重要です。

5. **IEEE 754浮動小数点標準の理解**：floatとdoubleの`MIN_VALUE`は、「最小の正の値」を意味し、負の最大値ではないことに注意が必要です。これはIEEE 754浮動小数点標準の仕様であり、科学技術計算で重要な概念です。

**実用的な応用例：**

この知識は、データベースのスキーマ設計、APIのパラメータ検証、ファイルフォーマットの仕様、ネットワークプロトコルの実装など、実際のソフトウェア開発のさまざまな場面で直接的に活用されます。

**注意：プリミティブ型とラッパクラスの関係**

プリミティブ型の変数からは直接型情報を取得できませんが、各プリミティブ型に対応するラッパクラス（Boolean, Character, Byte, Short, Integer, Long, Float, Double）が、型の詳細情報、型変換機能、文字列解析機能などの豊富なAPIを提供しています。この二重構造は、Javaの型システムの重要な特徴であり、性能と機能性の両方を高いレベルで実現しています。

### 変数の宣言と利用

#### 変数を宣言する

変数は、プログラム中で繰り返し使用する値や、値を変化させ利用する場合にその値が入る場所（メモリアドレス）に名前を付けることをよいます。

変数は「今からこれを使用します」という宣言を行わないと使用できません。  
宣言は、以下のように行います。

```
型名 識別子;
```

たとえば、整数値の番号を表す変数の場合、

```java
int number;
```

のように宣言します。  
このとき、名前のつけ方に注意しましょう。その変数はどんな値が入るのかを後から読んでも分かりやすい名前を付けることが望ましいです。

また、以下のように、同時に複数の変数を同じ型で宣言することも可能です。

```java
double score, money, point;
```

ただし、後述していますが、Javaでは変数の宣言と同時に初期値の代入が可能なため、1行にまとめて宣言する書き方は個人的にとても読みづらく感じます。  
そのためこの書き方はお勧めしません。

#### Javaにおける変数宣言のポイント

Javaでは、「変数宣言はプログラムの先頭にすべて書きなさい」なんてことはありません。必要になる直前で、「今からこの型を使用します」という意味合いで使用することをお勧めします。

たとえば次のプログラムをみてください。

```java
public class Hoge {
    public static void main(String[] args) {

        //数値Aの計算
        int numA;
        numA = 10 + 20 + 30 + 40;
        System.out.println("数値A:" + numA);

        //数値Bの計算
        int numB;
        numB = 10 * 20 * 30 * 40 + numA;
        System.out.println("数値B:" + numB);
    }
}
```

数値Bで使用する変数は、使用する直前で宣言すると、ほかの人がこのプログラムのソースコードを見た時「今からnumBという変数が使用されるんだな」ということがわかりやすくなります。

※これは、あくまでこうすると良いというだけの話です。  
強制するつもりはありませんが、こちらで慣れておくことをお勧めしています。

#### モダンJavaの型推論： `var`キーワード

Java 10から、ローカル変数の宣言において`var`キーワードを使用できるようになりました。これにより、コンパイラが代入される値から型を自動的に推論してくれるため、コードをより簡潔に記述できます。

```java
// 従来の書き方
String message = "Hello, Modern Java!";
java.util.ArrayList<String> list = new java.util.ArrayList<String>();

// var を使った書き方
var inferredMessage = "Hello, Modern Java!"; // String型と推論される
var inferredList = new java.util.ArrayList<String>();    // ArrayList<String>型と推論される
```

**`var`のポイント:**

*   **ローカル変数のみ:** `var`はメソッド内のローカル変数にのみ使用できます。フィールド（インスタンス変数やクラス変数）には使用できません。
*   **宣言と同時に初期化が必須:** 型を推論するため、宣言と同時に値を代入する必要があります。`var x;`のような宣言はできません。
*   **可読性への配慮:** `var`を使うとコードは短くなりますが、常に良いとは限りません。右辺から型が自明な場合（`new`を使う場合など）に使うと効果的ですが、型が分かりにくい場合は、従来通り明示的に型を記述する方が可読性が高まります。

#### 宣言と同時に初期化する

変数を宣言して使用しない場合は、コンパイルエラーとなります。***初期化*** をしておくことで、そういったコンパイルエラーをなくせます。

```java
int number;
number = 0;
```

という書き方も初期化できますが、Javaでは以下の書き方が一般的です。

```java
int number = 0;
```

初期化時、右辺が0ではない値でも指定は可能です。計算式の結果を初期値として代入することもできます。

### リテラル

リテラルとは、プログラムのソースコード中に直接値を書いた場合をよいます。  
Javaでは、リテラルにも内部的な型が存在します。
以下各リテラルをまとめた表です。

| リテラル  | 記入例  | 内部的な型  |
|---------|---------|---------|
| 整数  | 30 | int
| 大きな整数  | 30000000L | long
| 小数点あり(精度が高い) | 30.5 または 30.5d | double
| 小数点あり(精度が低い) | 30.5f | float
| 真偽 |  true | boolean
| シングルクオートで囲われた文字 | 'あ' | char
| ダブルクオートで囲わられた文字列 | "あいうえお" | ***String***

Stringだけ、若干特殊ですが、文字列はString型と呼ばれるクラス型として扱われる点を覚えておきましょう。

#### 数値型のリテラルのポイント

ソースコード中に数値リテラルを記入する際、以下のように数値の途中に「`_`」アンダースコアを入れることもできます。

```java
long bignum = 1_000_000_000_000L;
```

コード中にリテラルで大きな数字を入力しなければならない時、たとえば金額だったら3桁ごとで区切るなどして、見やすくする工夫できると良いです。

#### 特殊な数値リテラル(2進数、8進数、16進数)

2進数、8進数、16進数をソースコード中に記入する事もできます。

| リテラル  | 例  | 10進数の値 |
|---------|---------|---------|
| 2進数  | 0b1001 | 9
| 8進数  | 014 | 12
| 16進数  | 0xFE | 254

※8進数についてのみ、意図せず8進数になる場合がある点に注意が必要です。  
先頭がゼロから始まる場合に、それ以降の数値は8進数として認識されてしまうため、意図しない数値が内部的に保持されます。

#### 文字列リテラル

文字列は、Javaプログラミングにおいて最も頻繁に使用されるデータ型の1つであり、特別な特性を持っています。Stringクラスは技術的には参照型（クラス型）でありながら、プリミティブ型のように簡単に使えるように設計されています。

以下のプログラムは、文字列の基本的な作成、操作、連結を示し、Stringクラスの特別な性質を理解するための基礎例です：

ファイル名： HelloWorld.java

```java
public class HelloWorld {
    public static void main(String[] args) {
        String s = "Hello,";
        String t = "World!!";
        System.out.println(s + t); //Hello,World!!と表示される
    }
}
```

**このシンプルなプログラムから学ぶ重要な概念：**

1. **Stringの特別な地位**：JavaではStringはクラス型でありながら、プリミティブ型のように直接リテラルで初期化できます（`String s = "Hello,"`）。通常のクラスでは`new String("Hello,")`のような記述が必要ですが、Stringのみ特別に簡潔な記法が許されています。

2. **文字列連結の簡便性**：`+`演算子を使用して文字列を連結できるのは、Javaが文字列操作のために特別に用意した構文的糖衣（syntactic sugar）です。内部的には、より複雑な処理（StringBuilderの使用など）が実行されます。

3. **不変性（Immutability）の原則**：このコードでは明示的ではありませんが、JavaのStringオブジェクトは一度作成されると内容を変更できません。`s + t`の操作では、既存の文字列を変更するのではなく、新しいStringオブジェクトが作成されています。

4. **Unicodeサポートと国際化**：Javaの文字列はUnicodeをネイティブサポートしており、日本語、中国語、絵文字など、世界中の文字を自然に扱うことができます。

5. **メモリ効率と文字列プール**：同じ文字列リテラルは、Javaの文字列プール機能によってメモリ上で共有される場合があり、メモリ使用量の最適化が行われます。

**実用的な応用：**

Stringのこの簡潔な記法と連結機能は、ユーザーインターフェイスのメッセージ作成、ログ出力、ファイルパスの構築、SQLクエリの組み立てなど、日常的なプログラミング作業で頻繁に使用されます。ただし、大量の文字列連結や頻繁な変更が予想される場合は、StringBuilderやStringBufferの使用を検討する必要があります。

#### モダンJavaのテキストブロック

Java 15から、複数行の文字列を簡単に記述するための「テキストブロック」が導入されました。三重のダブルクオート `"""` で囲むことで、改行やインデントをそのまま保持した文字列を作成できます。

**従来の複数行文字列:**
```java
String html = "<html>\n" +
              "    <body>\n" +
              "        <p>Hello, World!</p>\n" +
              "    </body>\n" +
              "</html>";
```

**テキストブロックを使った場合:**
```java
String htmlBlock = """
    <html>
        <body>
            <p>Hello, World!</p>
        </body>
    </html>
    """;
```

テキストブロックを使うと、HTML、JSON、SQLなど、複数行にわたるテキストをソースコード中に埋め込む際の可読性が劇的に向上します。エスケープシーケンス `\n` や文字列連結の `+` が不要になるため、コードがすっきりとします。

#### 文字リテラルのエスケープシーケンス


文字リテラルに特殊な文字を入れたい場合は、エスケープシーケンスを使用します。
※環境によって、「\\」は「¥」で表示される場合があります。Windows日本語環境下の場合は¥です。

| エスケープシーケンス  | 文字  |
|----|----|
| `\t`  | タブ 
| `\n ` | 改行
| `\r ` | 復帰 
| `\' ` | '(シングルクオート)
| `\"`  | "(ダブルクオート)
| `\oxxxx` | 文字の実体参照形式8進数表記 (xxxxには0〜7の数値が入ります。)
| `\uxxxx` | 文字の実体参照形式16進数表記	(xxxxには0〜9,A〜Fの数値が入ります。)

文字の実体参照形式については、Unicodeと呼ばれる文字コードの表を参照して、該当の数値を入れることでキーボードから入力時変換できないような文字（英語以外の外国語など）を出力できたりします。

## 3.2 演算子

数値の計算や、文字列の連結など、さまざまな場所で演算子を使った処理を行います。  
すべての演算子が今すぐ使うものではありません。
いつ使うのか分からない演算子も、こういった書き方もできるということを覚えておきましょう。

### 代入演算子

変数へ値を代入するには、 `=` を使用します。

例：変数に代入を行う場合（aという変数に5を代入する）

```java
a = 5;
```

左辺に対して、右辺を代入します。逆はできません。

次は文法上可能ですが、あまり好ましくない例です。

```java
a = b = 5;
```

とすると、aには「b=5」が代入されるのですが、このとき「b=5」の処理結果は、5を返すため、a,bどちらにも5が代入されます。  
この書き方をたまにすることがありますが、本来ならコードを見た時に認識しづらい書き方だと思われるので極力使わないようにしましょう。

### 算術演算子

算術演算子には、以下のものがあります。

| 演算子記号 | 役割 | 算出時の優先順位
|----------|------|----|
| `+` | 足し算(加法演算子) | 後
| `-` | 引き算(加法演算子) | 後
| `*` | 掛け算(乗法演算子) | 先
| `/` | 割り算(乗法演算子) | 先
| `%` | 余り(乗法演算子) | 先

#### 算術演算子サンプルプログラム

算術演算子は、プログラミングの基本中の基本であり、数学的な計算、データ解析、アルゴリズムの実装など、あらゆるプログラムで使用されます。以下のプログラムは、Javaの基本的な算術演算子の動作を確認し、整数型の演算がどのように実行されるかを理解するための重要な学習材料です：

ファイル名： ArithmeticSample.java
```java
class ArithmeticSample {
  public static void main(String[] args) {
    int num1 = 10;
    int num2 = 5;

    System.out.println("num1とnum2にいろいろな演算を行います。");
    System.out.println("num1 + num2は" + (num1 + num2) + "です。");
    System.out.println("num1 - num2は" + (num1 - num2) + "です。");
    System.out.println("num1 * num2は" + (num1 * num2) + "です。");
    System.out.println("num1 / num2は" + (num1 / num2) + "です。");
    System.out.println("num1 % num2は" + (num1 % num2) + "です。");
  }
}
```

**このプログラムから学ぶ重要な数学的概念と演算特性：**

1. **整数除算の特性**：`num1 / num2`（10 / 5）の結果は2となりますが、これは整数どうしの除算では小数点以下が切り捨てられるためです。たとえば、num1を3、num2を2に変更すると、3 / 2 = 1（数学的には1.5）となります。

2. **剰余演算の重要性**：`%`演算子（モジュロ演算）は、プログラミングで非常に有用で、偶数・奇数の判定、循環処理の制御、ハッシュテーブルのインデックス計算などで頻繁に使用されます。

3. **演算子優先度の実践**：コード内の`(num1 + num2)`のような括弧は、文字列連結よりも先に算術演算を実行させるために必要です。括弧がないと、文字列連結が優先されて意図しない結果になります。

4. **型安全性とオーバーフロー**：int型の範囲内での演算である限り、このプログラムは安全に実行されます。しかし、很大きな数値を使用する場合は、オーバーフローの可能性を考慮する必要があります。

5. **コードの可読性とデバッグ**：各演算を個別のSytem.out.println文で出力することで、各演算の結果を個別に確認でき、デバッグや動作確認が容易になっています。

**学習のための発展的な実験：**

このプログラムを実行して基本動作を確認した後、以下のような値で実験してみることをお勧めします：

- **整数除算の特性理解**：num1=7, num2=3（7/3=2, 7%3=1）
- **負の数での演算**：num1=-10, num2=3（負の数の剰余演算の理解）
- **ゼロ除算のエラー**：num2=0に設定して、ArithmeticExceptionの発生を確認
- **大きな数値でのオーバーフロー**：num1=Integer.MAX_VALUE, num2=1での加算

これらの実験を通じて、Javaの数値演算の特性と限界を深く理解し、実際のプログラム開発で注意すべきポイントを学ぶことができます。

### 算術演算を伴う代入演算子（再帰代入演算子）

左辺に対して、右辺との算術演算を行った後に、左辺に代入する処理を省略して書くことができます。

| 演算子記号 | 役割 | 同じ処理で違う書き方
|----------|------|----|
| `+=` | 左辺に右辺を足し算した後に左辺へ代入 | `x += 5;`, `x = x + 5;`
| `-=` | 左辺に右辺を引き算した後に左辺へ代入 | `x -= 5;`, `x = x - 5;`
| `*=` | 左辺に右辺を掛け算した後に左辺へ代入 | `x *= 5;`, `x = x * 5;`
| `/=` | 左辺に右辺を割り算した後に左辺へ代入 | `x /= 5;`, `x = x / 5;`
| `%=` | 左辺に右辺の値で余りを算出した後に左辺へ代入 | `x %= 5;`, `x = x % 5;`

### 比較演算子

※両辺を比較する場合に使用し、演算子の結果はboolean型で戻ってきます。

| 演算子 | 例 | 説明
|----------|------|------|
| `==` | `a == b` | aとbが等しいときtrue
| `!=` | `a != b` | aとbが等しくないときtrue
| `>` | `a > b` | aがbより大きいときtrue
| `<` | `a < b` | aがbより小さいきとtrue
| `>=` | `a >= b` | aがb以上のときtrue
| `<=` | `a <= b` | aがb以下のときtrue

### 論理演算子(ショートサーキット演算子)

※両辺ともbooleanの場合に使用します。

| 演算子 | 例 | 説明
|----------|------|------|
| `&&` | `a && b` | aとbの両方がtrueのときtrue
| `||` | `a || b` | aとbのどちらかがtrueのときtrue
| `!` | `!a` | aがfalseのときtrue。逆になる

### インクリメント・デクリメント

インクリメント・デクリメントの演算子は、それぞれ2種類ずつあります。
この演算子を式中で使う場合、この違いがとても大きく、間違えやすい点ですので、注意が必要です。

#### インクリメント

| 演算子(位置に注意) | 式中で行われるものと同義のステートメント | 式中での評価、更新順序
|------|------|------|
| `y++` | `y = y + 1;` | y を評価してから式を演算し、 y + 1 に更新
| `++y` | `y = y + 1;` | y + 1 に更新してから式の評価、演算

#### デクリメント

| 演算子(位置に注意) | 式中で行われるものと同義のステートメント | 式中での評価、更新順序
|------|------|------|
| `y--` | `y = y - 1;` | y を評価してから式を演算し、 y - 1 に更新
| `--y` | `y = y - 1;` | y - 1 に更新してから式の評価、演算

### データ型による演算の制約

演算時の注意点として、データ型による丸めの発生があります。

- 整数型どうしの除算は、小数点以下切り捨て
    + 10 / 4 = 2
- どちらかに浮動小数点型の数値がある場合は、小数点以下も計算されます。
    + 10.0 / 4 = 2.5
    + この場合、計算結果は浮動小数点型となります。

### キャスト演算子

整数型の変数に、浮動小数点型の数値を代入しようとするとエラーとなります。

浮動小数点数を整数に***強制的に変換***し、代入をすればエラーとなりません。  
ただし、整数型に型の強制変換を行ったタイミングで、小数点以下の値は切り捨てられてしまうので注意が必要です。

```java
float s = 1234.567f;
int num = (int)s; // ← numには、1234 が代入される
```

### 文字列との連結

`+` を使います。

```
"Hello, " + "World!!" → "Hello, World!!"
```

次のプログラムはどのような結果を出力するでしょう？

```java
int a = 3;
int b = 5;
System.out.println("文字列と数値を結合すると..." + a + b);
```

出力結果：

```bash
文字列と数値を結合すると...35
```

基本的には、式中に文字列がある場合、その式が返す値はすべて文字列になります（ただし、括弧などにより、数値の演算のみを優先的に行うことは可能です）。
数値は暗黙的に文字列へ変換されてしまいます。
表示結果をコントロールしたい場合は、この暗黙的な型変換に注意してください。

## 3.3 制御構造

プログラミングにおいて、最も重要で最もバグを出しやすい部分です。

### if文による条件分岐

#### if – 基本的な書き方

括弧内の条件（*boolean型*）に合致する（値が`true`）の場合に、波括弧`{ }`内のブロックの処理を行います。

```java
if ( 条件 ) {
    ここは条件に合致した場合にのみ実行される
}
```

波括弧のブロックは、実行する処理が1行の場合のみ省略が可能ですが、波括弧は省略しない方が良いです。

もし、条件に合致した場合実行する処理が1行だけのとき、次の書き方のように改行を挟まず1行で書くようにすると分かりやすいです。

```java
if ( 条件 ) ここは条件に合致した場合にのみ実行される
```

波括弧を省略してほしくない理由は、次のようなパターンが考えられるからです。

```java
if ( 条件 )
    最初にif文を書いた人が書いた条件内のコード
```

これは正常に動きます。  
次に、このコードを改修する際、以下のようなコードの修正を行ってしまいやすい点が波括弧を省略した際に起こりやすいです。

```java
if ( 条件 )
    最初にif文を書いた人が書いた条件内のコード
    追加された条件内コードのつもりで書かれたコード
```

このとき、追加されたコードは、ifの条件にまったく関係なく処理が実行されてしまい、これが意図しない処理としてバグにつながります。
すぐに気付けるようだったら良いのですが、追加されたコードの影響が、かなり後の方（たとえばリリース後など）で気付く状況も少なからずあります。
そもそも波括弧を省略していなければ防げているバグを発生させないためにも、必ず波括弧を書きましょう。

少し逸れますがバグの混入を防ぐ話として、インデントをそろえることも重要です。  
インデントはタブでもスペースでもかまいませんが、コードブロックが分かりやすくなるように適切な字下げをしましょう。  
また、インデントに関していえば、IDEに搭載されているコードフォーマッタを使うのもよいです。自動的にコードの整形を行ってくれるため、先ほどの追加コードのような不具合もコードの整形によって気付きやすくなります。

#### if-else – どちらかを実行

ifの条件に合致しなかった場合のみ実行される処理を書ける

```java
if ( 条件 ) {
    ここは条件に合致した場合にのみ実行される
} else {
    条件に合致しなかった場合にのみ実行される
}
```

#### if-elseif-else – 複数の条件

条件に合致しなかった場合、再度評価を行うこともできる

```java
if ( 条件1 ) {
    条件1に合致した場合にのみ実行される
} else if ( 条件2 ) {
    条件1に合致せず、条件2に合致した場合
} else {
    上記すべての条件に合致しなかった場合
}
```

#### 比較演算子と論理演算子を組み合わせた複数条件指定

if文の条件は、条件1かつ条件2と言ったように、1つのif文で複数の条件を入れることが可能です。

##### AND（〜かつ〜）

```java
if ( 条件１ && 条件２ ) {
    条件１と条件２どちらにも合致した場合にのみ実行される
}
```

##### OR（〜または〜）

```java
if ( 条件１ || 条件２ ) {
    条件１か条件２のどちらかに合致した場合にのみ実行される
}
```

#### 条件分岐の実践例

論理演算子を使った複雑な条件分岐は、実際のビジネスロジックを実装する際に頻繁に使用されます。以下のプログラムは、会員システムの割り引き判定という実用的な例を通じて、論理演算子の効果的な使用方法を学習するための材料です：

ファイル名： MembershipDiscount.java

```java
public class MembershipDiscount {
    public static void main(String[] args) {
        // 顧客情報の設定
        int age = 25;
        boolean isPremiumMember = true;
        int purchaseAmount = 5000;
        int membershipYears = 3;
        
        System.out.println("=== 顧客情報 ===");
        System.out.println("年齢: " + age + "歳");
        System.out.println("プレミアム会員: " + (isPremiumMember ? "はい" : "いいえ"));
        System.out.println("購入金額: " + purchaseAmount + "円");
        System.out.println("会員歴: " + membershipYears + "年");
        System.out.println();
        
        // 複数の割引条件を論理演算子で組み合わせた判定
        System.out.println("=== 割引判定結果 ===");
        
        // 条件1: シニア割引（65歳以上）
        if (age >= 65) {
            System.out.println("シニア割引が適用されます（20%オフ）");
        }
        
        // 条件2: プレミアム会員かつ高額購入
        if (isPremiumMember && purchaseAmount >= 3000) {
            System.out.println("プレミアム会員高額購入割引が適用されます（15%オフ）");
        }
        
        // 条件3: 若年層または長期会員
        if (age <= 25 || membershipYears >= 5) {
            System.out.println("若年層・長期会員割引が適用されます（10%オフ）");
        }
        
        // 条件4: 複雑な組み合わせ条件
        if ((isPremiumMember && purchaseAmount >= 5000) || 
            (age >= 60 && membershipYears >= 3)) {
            System.out.println("特別VIP割引が適用されます（25%オフ）");
        }
        
        // 条件5: 除外条件を含む複雑な判定
        if (purchaseAmount >= 10000 && age >= 20 && age <= 60 && !isPremiumMember) {
            System.out.println("一般会員高額購入割引が適用されます（5%オフ）");
        }
    }
}
```

**このプログラムから学ぶ重要な概念：**

1. **論理AND演算子（&&）の実用性**：「プレミアム会員かつ高額購入」のように、複数の条件を同時に満たす場合の判定に使用します。ビジネスルールでは「すべての条件を満たす」ケースが頻繁にあります。

2. **論理OR演算子（||）の柔軟性**：「若年層または長期会員」のように、いずれかの条件を満たせば良い場合に使用します。顧客の多様なニーズに対応するための重要なしくみです。

3. **複雑な条件の構築**：括弧を使用することで、より複雑なビジネスロジックを表現できます。例：「（プレミアム会員で高額購入）または（シニアで長期会員）」

4. **論理NOT演算子（!）の活用**：`!isPremiumMember`のように、特定の条件を除外する際に使用します。「プレミアム会員ではない一般会員に対する特別オファー」などの実装に有用です。

5. **短絡評価（Short-circuit evaluation）の重要性**：`&&`演算子では、左の条件がfalseの場合、右の条件は評価されません。`||`演算子では、左の条件がtrueの場合、右の条件は評価されません。これにより、効率的で安全な条件判定が可能になります。

**実用的な応用場面：**

- **ECサイトの価格計算システム**：顧客属性にもとづいた動的割り引き計算
- **アクセス制御システム**：ユーザーの権限や属性にもとづいた機能制限
- **ゲームの進行条件**：プレイヤーのレベル、アイテム所持状況にもとづいた分岐
- **在庫管理システム**：商品の種類、在庫量、季節性を考慮した発注判定

**論理演算子使用時の注意点：**

1. **可読性の確保**：複雑な条件は適切に括弧でグループ化し、意図を明確にする
2. **ド・モルガンの法則**：`!(A && B)` = `!A || !B`、`!(A || B)` = `!A && !B`の理解
3. **null安全性**：オブジェクトの参照がnullでないことを最初に確認する習慣

#### 三項演算子

三項演算子は、`if...else...`を式として扱えます。

```java
System.out.println(条件 ? "true" : "false");
//条件に合致していればtrueと表示されます。合致していなければfalseと表示されます。

//↑の処理と同じように書く場合↓
if ( 条件 ) {
    System.out.println("true");
} else {
    System.out.println("false");
}
```

式の中で条件分岐を実現でき、結果を切り替えることができるためたいへん便利です。

### switch文による条件分岐

#### 一つの値に対する条件分岐

1つの式（変数でも演算子を用いた式でもよい）に対して、それぞれの値と等しいかを条件分岐したい場合には、以下のようにも書けます。

```java
switch ( 式 ) {
    case 値1:
        式の結果が値1と等しい時に処理を実行
        break;
    case 値2:
        式の結果が値2と等しい時に処理を実行
        break;
    default:
        上記のどの値とも等しくない時に処理を実行
        break;
}
```

上記のコードは、以下のif…else if…elseと同義です。

```java
if ( 式 == 値1 ) {
    式の結果が値1と等しい時に処理を実行
} else if ( 式 == 値2 ) {
    式の結果が値2と等しい時に処理を実行
} else {
    上記のどの値とも等しくない時に処理を実行
}
```

#### switch文の注意点

条件分岐後の処理を書いたら、break;でswitch文を抜けるようにしないといけない。

以下の書き方を行った場合、`case 値1`で処理するべき以降の条件が意図したものと違ってしまいます。

```java
switch ( 式 ) {
    case 値1:
        式の結果が値1と等しい時に処理を実行
    case 値2:
        式の結果が値1と等しい時と値2と等しい時に処理を実行
        //↑本来は、「式の結果が値2と等しい時に処理を実行」のつもりで書いたが、
        // break;を忘れたことで意図しない条件が追加されてしまっている。
        break;
    default:
        上記のどの値とも等しくない時に処理を実行
        break;
}
```

この特性を利用して、以下のように応用することも可能です。

複数の値で式を評価する
```java
switch ( 式 ) {
    case 値1:
    case 値2:
        式の結果が値1か値2と等しい時に処理を実行
        break;
    default:
        上記のどの値とも等しくない時に処理を実行
        break;
}
```

#### モダンJavaのswitch式

Java 14から、`switch`は文だけでなく、値を返す「式」としても使えるようになりました。これにより、より簡潔で安全なコードを書くことができます。

**従来のswitch文:**
```java
int day = 3;
String dayType;
switch (day) {
    case 1: case 2: case 3: case 4: case 5:
        dayType = "平日";
        break;
    case 6: case 7:
        dayType = "休日";
        break;
    default:
        dayType = "無効な曜日";
        break;
}
```

**新しいswitch式:**
```java
int day = 3;
String dayType = switch (day) {
    case 1, 2, 3, 4, 5 -> "平日";
    case 6, 7 -> "休日";
    default -> "無効な曜日";
};
```

**switch式のポイント:**

*   **`->`（アロー）ラベル:** `case`の後にコロン`:`の代わりにアロー`->`を使い、右側に値を書きます。
*   **`break`不要:** アローの右側は単一の式か文ですので、`break`は不要です。これにより、`break`の書き忘れによるバグ（フォールスルー）を完全に防ぐことができます。
*   **値を返す:** `switch`式全体が値を返すため、結果を直接変数に代入できます。
*   **網羅性のチェック:** `default`節がない場合など、すべての可能性を網羅していないとコンパイルエラーになります。これにより、条件漏れを防ぐことができます。

#### switch文の実践例

switch文は、特定の値にもとづいた分岐処理に優れており、特に列挙型のような限定された値セットを扱う場合に威力を発揮します。以下のプログラムは、成績管理システムという実用的な例を通じて、switch文の効果的な使用方法を学習するための材料です：

ファイル名： GradeCalculator.java

```java
public class GradeCalculator {
    public static void main(String[] args) {
        // テストケースとして複数の成績を評価
        char[] grades = {'A', 'B', 'C', 'D', 'F', 'B'};
        int totalGradePoints = 0;
        int courseCount = grades.length;
        
        System.out.println("=== 成績評価システム ===");
        System.out.println("履修科目数: " + courseCount + "科目");
        System.out.println();
        
        for (int i = 0; i < grades.length; i++) {
            char grade = grades[i];
            int gradePoint;
            String evaluation;
            
            // switch文による成績の詳細評価
            switch (grade) {
                case 'A':
                    gradePoint = 4;
                    evaluation = "優秀（Excellent）";
                    break;
                case 'B':
                    gradePoint = 3;
                    evaluation = "良好（Good）";
                    break;
                case 'C':
                    gradePoint = 2;
                    evaluation = "普通（Average）";
                    break;
                case 'D':
                    gradePoint = 1;
                    evaluation = "要努力（Below Average）";
                    break;
                case 'F':
                    gradePoint = 0;
                    evaluation = "不合格（Fail）";
                    break;
                default:
                    gradePoint = 0;
                    evaluation = "無効な成績";
                    System.out.println("警告: 無効な成績 '" + grade + "' が検出されました");
                    break;
            }
            
            totalGradePoints += gradePoint;
            System.out.println("科目" + (i + 1) + ": " + grade + "(" + gradePoint + "点) - " + evaluation);
        }
        
        System.out.println();
        
        // GPA計算と総合評価
        double gpa = (double) totalGradePoints / courseCount;
        System.out.println("総ポイント: " + totalGradePoints + "点");
        System.out.printf("GPA: %.2f\n", gpa);
        
        // GPAにもとづく総合評価（switch文の応用）
        int gpaCategory = (int) gpa; // 小数点以下切り捨て
        
        System.out.print("総合評価: ");
        switch (gpaCategory) {
            case 4:
                System.out.println("最優秀（Summa Cum Laude）- 学長表彰対象");
                break;
            case 3:
                System.out.println("優秀（Magna Cum Laude）- 学部長表彰対象");
                break;
            case 2:
                System.out.println("良好（Cum Laude）- 追加指導不要");
                break;
            case 1:
                System.out.println("要注意（Academic Warning）- 学習指導が必要");
                break;
            case 0:
                System.out.println("要改善（Academic Probation）- 緊急学習支援が必要");
                break;
            default:
                System.out.println("計算エラー");
                break;
        }
        
        // 複数caseラベルの活用例（奨学金適用条件）
        System.out.print("奨学金適用: ");
        switch (gpaCategory) {
            case 4:
            case 3:
                System.out.println("特待生奨学金適用対象");
                break;
            case 2:
                System.out.println("一般奨学金適用対象");
                break;
            default:
                System.out.println("奨学金適用対象外");
                break;
        }
    }
}
```

**このプログラムから学ぶ重要な概念：**

1. **switch文の適用場面**：文字や整数などの離散的な値による分岐において、if-else文よりも読みやすく、効率的な処理が可能です。特に「成績」「曜日」「月」「状態」などの列挙可能な値に最適です。

2. **break文の重要性**：各caseの最後にbreak文を配置することで、意図しないfall-through動作を防ぎます。break文を忘れると、次のcaseも実行されてしまう重大なバグの原因となります。

3. **default句の活用**：予期しない値に対する安全な処理を提供します。入力検証やエラーハンドリングの重要な要素として機能します。

4. **複数caseラベルの実用性**：同じ処理を複数の値で実行したい場合、case文を連続して記述することで、コードの重複を避けられます。

5. **型安全性とパフォーマンス**：switch文は、コンパイル時に値のチェックが行われ、実行時は効率的なジャンプテーブルとして最適化される場合があります。

**実用的な応用場面：**

- **状態管理システム**：注文状態（待機中、処理中、発送済み等）の処理分岐
- **ゲーム開発**：プレイヤーの行動（移動、攻撃、防御等）による処理分岐
- **ユーザーインターフェイス**：メニュー選択やボタンクリックにもとづいた機能実行
- **データ変換処理**：ファイル形式やデータ型による変換処理の分岐

**switch文使用時のベストプラクティス：**

1. **必ずdefault句を含める**：予期しない値に対する適切な処理を提供
2. **各caseにbreak文を配置**：意図しないfall-throughを防ぐ
3. **複雑な処理はメソッドに分割**：各caseの処理が長くなる場合は、別メソッドに委譲
4. **列挙型（enum）との組み合わせ**：型安全性をさらに向上させるため、可能な限りenum型を使用

### String型の内容評価について

JavaのString型は、プログラミング初心者が遇遇する最も細かい罠の一つであり、同時にJavaのメモリ管理とオブジェクト指向の本質を理解するための絶好の教材でもあります。以下のプログラムは、String型の特別な性質と、参照比較と値比較の違いを具体的に示しています。

このサンプルを通じて、Javaの文字列プール機能、オブジェクトの同一性、メモリ管理の仕組みを理解しましょう：

```java
public class StringEval {
  public static void main(String[] args) {

    String a = "Hello";
    String b = "Hello";

    if (a == b) {
      System.out.println("同じだよ！");  // こっち
    } else {
      System.out.println("違うよ！");
    }

    // a,b両方に処理を加えて値を変化させる
    a += 1;
    b += 1;
    System.out.println("a:" + System.identityHashCode(a));
    System.out.println("b:" + System.identityHashCode(b));

    if (a == b) {
      System.out.println("同じだよ！");
    } else {
      System.out.println("違うよ！");   // こっち
    }
  }
}
```

**この予期しない動作の背後にあるJavaの深いしくみ：**

実行結果を見ると、最初の比較では「同じだよ！」が表示されますが、文字列の変更後は「違うよ！」が表示されます。変数aとbはどちらも「Hello1」という同じ値を持っているにもかかわらず、このような結果になるのはなぜでしょうか？

1. **文字列プール機能の影響**：最初の`String a = "Hello"; String b = "Hello";`では、Javaの文字列プール機能により、同じ文字列リテラル「Hello」はメモリ上の同じオブジェクトを指しています。そのため、`a == b`の参照比較が`true`になります。

2. **Stringの不変性と新しいオブジェクトの作成**：`a += 1`や`b += 1`の操作は、既存のStringオブジェクトを変更するのではなく、新しいStringオブジェクトを作成しています。これはStringの不変性（immutability）という重要な特性によるものです。

3. **参照比較と値比較の違い**：`==`演算子は、プリミティブ型では値を比較しますが、参照型（オブジェクト）では参照（メモリアドレス）を比較します。新しく作成されたStringオブジェクトは異なるメモリ位置に存在するため、内容が同じであっても`==`では`false`になります。

**Javaのメモリ管理とオブジェクトライフサイクル：**

この動作を理解するためには、Javaのオブジェクト管理のしくみを知る必要があります：

1. **変数の初期化**：参照型変数は、初期化時に`null`（「何も指していない」を意味する特別な値）が設定されます。

2. **オブジェクトの作成**：`new`演算子や文字列リテラルによって、メモリ上にオブジェクトが作成されます。

3. **参照の保存**：変数には、オブジェクト自体ではなく、オブジェクトが保存されているメモリアドレス（参照）が保存されます。

このしくみを理解することで、Stringの比較だけでなく、Javaのオブジェクト指向プログラミング全般における重要な概念を理解できます。

#### Stringなどのクラス型の比較方法

前節で見た問題を解決するためには、適切な比較メソッドを使用する必要があります。Javaでは、オブジェクトの内容を比較するために`equals()`メソッドが用意されています。このメソッドは、Javaのオブジェクト指向プログラミングの核心的な概念であり、正しい使い方を理解することは、安全で信頼性の高いプログラムを作成するために不可欠です。

**equals()メソッドの基本理解：**

Javaのすべてのクラスは、最上位クラスであるObjectクラスを継承しており、Objectクラスにはオブジェクトの内容を比較するための`equals(Object obj)`メソッドが定義されています。このメソッドは、現在のオブジェクトと引数で渡されたオブジェクトの「内容が等しいか」を判定し、等しければ`true`、そうでなければ`false`を返します。

以下のプログラムは、前節の問題を`equals()`メソッドで解決し、同時にオブジェクトの同一性を調べる`System.identityHashCode()`メソッドを使用して、メモリ上のオブジェクトの実態を理解できるようにしています：

```java
public class StringEquals {
  public static void main(String[] args) {

    String a = "Hello";
    String b = "Hello";

    System.out.println("a:" + System.identityHashCode(a));
    System.out.println("b:" + System.identityHashCode(b));

    if (a.equals(b)) {
      System.out.println("同じだよ！");  // こっち
    } else {
      System.out.println("違うよ！");
    }

    a += 1;
    b += 1;
    System.out.println("a:" + System.identityHashCode(a));
    System.out.println("b:" + System.identityHashCode(b));

    if (a.equals(b)) {
      System.out.println("同じだよ！");  // こっち
    } else {
      System.out.println("違うよ！");
    }
  }
}
```

**このプログラムから学ぶ重要な概念：**

1. **値比較と参照比較の違い**：`equals()`メソッドはオブジェクトの内容（値）を比較し、`==`演算子は参照（メモリアドレス）を比較します。この違いを理解することが、Javaプログラミングの基礎です。

2. **文字列プールの可視化**：`System.identityHashCode()`の出力を確認することで、最初の「Hello」は同じオブジェクトを指していること（同じハッシュコード）、変更後の「Hello1」は異なるオブジェクトであること（異なるハッシュコード）が確認できます。

3. **NullPointerExceptionの防止**：`equals()`メソッドは、呼び出し元のオブジェクトが`null`でないことを確認してから使用する必要があります。`null`のオブジェクトに対してメソッドを呼びだすとNullPointerExceptionが発生します。

4. **Stringクラスのequals()の最適化**：Stringクラスは、equals()メソッドをオーバーライドして、文字列の内容を効率的に比較するように最適化されています。

5. **一貫性のある結果**：このプログラムを実行すると、文字列の変更前後どちらでも「同じだよ！」が表示され、プログラマの意図通りの結果が得られます。

**実用的な比較パターン：**

- **正の比較**：`a.equals(b)`
- **負の比較**：`!a.equals(b)`
- **null安全な比較**：`Objects.equals(a, b)`（Java 7以降）

**重要なルール：**

Javaでのオブジェクト比較では、以下の原則を必ず守りましょう：
- **プリミティブ型の比較**：`==`演算子を使用
- **参照型（オブジェクト）の比較**：`equals()`メソッドを使用

この区別を正しく理解して使い分けることで、予期しないバグや論理エラーを防ぐことができ、安全で信頼性の高いプログラムを作成できます。

## 3.4 繰り返し処理

同じ処理や、似たような処理を何度も繰り返したい場合には、コピー&ペーストではなくwhileやforを使う工夫をしましょう。

### 単純な繰り返し

#### while

while文の括弧内で指定された条件に、合致している間は処理を繰り返します。

```java
while ( 条件 ) {
    条件が真値(true)の間、繰り返す処理
}
```

##### 10回繰り返す

while文では、繰り返しの条件となるものが必要となります。

```java
int count = 1;
while ( count <= 10 ) {
    繰り返す処理をここに書きます。
    count += 1;
}
```

#### do…while

while文なんだけど、条件の検査が波括弧を閉じるタイミングで行われるため、波括弧内の処理は、条件にかかわらず一度は実行され繰り返し処理です。

```java
do {
    処理を実行後、条件が真値の場合には何度も繰り返す
} while ( 条件 ); //セミコロンを忘れずに付けましょう！
```

存在を忘れがちですので、覚えておきましょう。

##### 10回繰り返す

```java
int count = 1;
do {
    繰り返す処理 (countの初期値が11だった場合でも処理は実行されます)
    count += 1;
} while ( count <= 10 );
```

#### for

whileループの繰り返し条件用の数値型変数を簡略化して書けるループ処理です。

初期化された変数が、波括弧内の処理を繰り返す都度、指定された変化ルールに従って変化します。  
変化した値が繰り返し条件に合致しなくなった場合、繰り返しから抜けられます。

```java
for (変数の初期化; 繰り返し条件; 繰り返し時の変化) {
    繰り返す処理
}
```

##### 10回繰り返す

```java
for (int count = 1; count <= 10; count++) {
    繰り返す処理
}
```

### 繰り返し処理中に例外的な処理を行う

#### 繰り返し中に別の条件でループを抜けたい - break

ループ処理に限らず、ブロックから抜け出すことができる命令としてbreakがあります。

for文を例にした場合：

```java
for (変数の初期化; 繰り返し条件; 繰り返し時の変化) {
    繰り返す処理
    if ( 別の条件 ) break;
}
```

#### 一度だけ処理を飛ばして、次の繰り返しを行う - continue

ループ処理中に、continueが実行されると、それ以降の処理は1回の繰り返し処理時のみ飛ばして次の繰り返し処理が実行されます。

```java
for (変数の初期化; 繰り返し条件; 繰り返し時の変化) {
    繰り返す処理
    if ( 別の条件 ) continue;
    別の条件に合致する場合、実行されない処理
}
```

## 3.5 static修飾子：インスタンス不要の共有メンバー

これまでに見てきたクラスのフィールドやメソッドは、すべて`new`キーワードによってオブジェクト（インスタンス）を生成してからでないと利用できませんでした。これらを「**インスタンスメンバー**」と呼びます。

しかし、Javaにはインスタンスを生成しなくても利用できる特別なメンバーが存在します。それが`static`修飾子を付けた「**クラスメンバー**」または「**静的メンバー**」です。

### インスタンスメンバー vs クラスメンバー

この2つの違いを理解することは、オブジェクト指向プログラミングにおいて非常に重要です。

*   **インスタンスメンバー（`static`なし）**
    *   **所有者**: 個々のインスタンス
    *   **メモリ**: インスタンスが生成されるたびに、そのインスタンス専用の領域が確保される。
    *   **アクセス**: `インスタンス変数名.メンバー名`
    *   **比喩**:「**住宅の各戸が持つ家具**」。Aさんの家のテーブルとBさんの家のテーブルは別物です。

*   **クラスメンバー（`static`あり）**
    *   **所有者**: クラスそのもの
    *   **メモリ**: クラスがロードされる時に一度だけ、クラス共有の領域が確保される。
    *   **アクセス**: `クラス名.メンバー名`
    *   **比喩**:「**マンションの共有掲示板**」。どの部屋の住人が見ても、掲示板は1つであり、そこに書かれた情報は全住人で共有されます。

### メモリ上のイメージ

```
【メモリ空間】
+-----------------------------------------------------------------+
| **クラス領域（共有）**                                          |
| +-------------------------------------------------------------+ |
| | **Toolクラス**                                              | |
| |   `static String sharedInfo = "共有情報";`  <-- 1つだけ存在 | |
| |   `static void showSharedInfo()`                           | |
| +-------------------------------------------------------------+ |
+-----------------------------------------------------------------+
| **ヒープ領域（インスタンスごと）**                              |
| +---------------------------+ +---------------------------+     |
| | **tool1インスタンス**     | | **tool2インスタンス**     |     |
| | `String instanceName;`    | | `String instanceName;`    |     |
| | `void showInstanceName()` | | `void showInstanceName()` |     |
| +---------------------------+ +---------------------------+     |
+-----------------------------------------------------------------+
```

### `static`メンバーの実践例

`static`フィールドと`static`メソッドの具体的な使い方を見てみましょう。

```java
// StaticMemberExample.java
class Tool {
    // インスタンスメンバー（各Toolインスタンスが個別に持つ）
    String name;

    // クラスメンバー（Toolクラス全体で共有される）
    static int toolCount = 0;

    // コンストラクタ
    public Tool(String name) {
        this.name = name;
        toolCount++; // インスタンスが作られるたびに、共有カウンタを増やす
        System.out.println(this.name + " が作成されました。現在のツール総数: " + toolCount);
    }

    // インスタンスメソッド
    public void showName() {
        System.out.println("このツールの名前は " + this.name + " です。");
    }

    // クラスメソッド
    public static void showToolCount() {
        // System.out.println(this.name); // エラー！ staticメソッド内ではインスタンスメンバー(name)は使えない
        System.out.println("作成されたツールの総数は " + toolCount + " です。");
    }
}

public class StaticMemberExample {
    public static void main(String[] args) {
        System.out.println("--- ツール作成前 ---");
        // インスタンスがなくてもクラスメソッドは呼び出せる
        Tool.showToolCount();

        System.out.println("\n--- ツール作成 ---");
        Tool hammer = new Tool("ハンマー");
        Tool wrench = new Tool("レンチ");

        System.out.println("\n--- 各ツールの情報表示 ---");
        hammer.showName(); // インスタンスメソッドの呼び出し
        wrench.showName();

        System.out.println("\n--- ツール総数の再確認 ---");
        // クラス名経由でのアクセスが推奨
        Tool.showToolCount();
    }
}
```

**実行結果:**
```
--- ツール作成前 ---
作成されたツールの総数は 0 です。

--- ツール作成 ---
ハンマー が作成されました。現在のツール総数: 1
レンチ が作成されました。現在のツール総数: 2

--- 各ツールの情報表示 ---
このツールの名前は ハンマー です。
このツールの名前は レンチ です。

--- ツール総数の再確認 ---
作成されたツールの総数は 2 です。
```

### なぜ`main`メソッドは`static`なのか？

これまでおまじないのように書いてきた`public static void main(String[] args)`の`static`の意味が、ここで明らかになります。

Javaアプリケーションを実行する際、Java仮想マシン（JVM）はプログラムの起点として`main`メソッドを呼び出します。この時点では、まだ**アプリケーションのクラスのインスタンスは一つも生成されていません**。

もし`main`メソッドが`static`でなければ、JVMは`main`メソッドを呼びだすために、まずそのクラスのインスタンスを`new`する必要があります。しかし、「どのコンストラクタを、どのような引数で呼べばよいか」をJVMは知ることができません。

この問題を解決するため、`main`メソッドは「**インスタンスがなくても呼び出せる**」クラスメソッド、すなわち`static`メソッドとして定義されているのです。


## 3.6 配列


### 同じ型の複数データを１つの変数にまとめる

配列とは、データをまとめて管理する方法の1つです。
変数1つに同じ型の複数の値を入れられるようにします。

#### 単一次元の配列（1次元配列）

配列は、同じ型の複数のデータを1つの変数名で管理するための重要なデータ構造です。これにより、大量のデータを効率的に管理し、ループ処理やアルゴリズムの実装が可能になります。Javaの配列は、型安全性、自動的な境界チェック、ガベージコレクションとの統合など、数多くの安全性機能を提供しています。

##### 配列の宣言：型安全性の基礎

配列の宣言は、「この変数は特定の型の要素を複数保持する」ということをコンパイラに伝える重要なステップです。これにより、コンパイル時に型の整合性がチェックされ、実行時エラーを防ぐことができます：

```java
int[] a;
int a[];
```

**宣言構文の選択とコードスタイル：**

Javaでは上記の両方の宣言方法が有効ですが、一般的には`int[] a`の形式（型名に続けて`[]`）が推奨されます。これは、「この変数はintの配列型である」ということを型名部分で明確に表現し、コードの可読性を向上させるためです。

##### 領域の確保：メモリ管理と初期化

配列の宣言だけでは、まだ実際のデータを保存するためのメモリ領域が確保されていません。明示的にメモリ領域を確保し、配列のサイズを決定する必要があります。このプロセスでは、Javaの型安全性とメモリ管理機能が連携して動作します：

```java
int[] scores;		      // 宣言
scores = new int[5];	// 領域を5つ確保する
```

**この操作で起こる重要なプロセス：**

1. **メモリの確保**：Javaのランタイムが、int型を5個分の連続したメモリ領域をヒープ領域に確保します。
2. **インデックスの設定**：`scores[0]`から`scores[4]`までの5つの要素へのアクセスポイントが確立されます。
3. **初期値の設定**：すべての要素が自動的にデフォルト値（intの場合は0）で初期化されます。
4. **境界チェックの準備**：実行時に配列の範囲を超えたアクセスを検出する機能が有効になります。

**0ベースインデックシングの重要性：**

Javaを含む多くの現代プログラミング言語では、0ベースのインデックシングが採用されています。これは、アドレス計算の効率性、アルゴリズムの統一性、数学的な操作の簡素化など、数多くの技術的メリットがあるためです。

**new演算子の機能と意義：**

`new`演算子は、Javaのオブジェクト系プログラミングにおける最も重要な機能の1つです。配列の場合、new演算子は単にメモリを確保するだけでなく、型安全性の保証、ガベージコレクションとの統合、境界チェック機能の有効化など、安全で効率的なメモリ管理を実現しています。

##### 配列の各要素へのアクセス：安全で効率的なデータ操作

配列の要素アクセスは、角括弧`[]`と整数インデックスを使用して行います。このシンプルな構文の背後には、高度な安全性機能とパフォーマンス最適化が組み込まれています：

```java
//各要素へ代入
scores[0] = 74;
scores[1] = 88;
scores[2] = 98;
scores[3] = 53;
scores[4] = 25;

// 指定したインデックスの要素を取り出し
System.out.println(scores[3]); // 上から4つめの要素を表示しているので、53と表示される
```

**このシンプルな操作から学ぶ重要な概念：**

1. **O(1)アクセス時間**：配列のインデックスアクセスは、配列のサイズに関係なく一定時間で実行されます。これは、メモリアドレスの直接計算によるもので、大量のデータを扱うアプリケーションで重要な特性です。

2. **自動境界チェック**：Javaの実行時系は、配列アクセス時に自動的に境界チェックを行い、無効なインデックス（負の値や配列サイズ以上の値）でのArrayIndexOutOfBoundsExceptionを発生させます。

3. **型安全性**：配列の各要素は、宣言時に指定した型と一致する値のみを保存でき、コンパイル時に型の整合性がチェックされます。

4. **メモリの効率性**：同じ型のデータが連続したメモリ領域に配置されることで、CPUキャッシュの効率やメモリアクセスパターンの最適化が実現されます。

5. **アルゴリズムの基礎**：このシンプルなアクセスパターンは、ソート、検索、フィルタリングなど、あらゆるアルゴリズムの基礎となります。

このように、配列の基本操作を理解することは、単にデータを保存する方法を学ぶだけでなく、コンピュータサイエンスの基礎的な概念を理解し、効率的で安全なプログラムを作成するための重要な基礎を築くことにつながります。

##### まとめて初期化

配列の宣言と領域の確保を同時に行う場合は以下のように書けます。

```java
int[] scores;		      // 宣言
scores = new int[5];	// 領域を5つ確保する
// ↓ 宣言と同時に領域確保
int[] scores = new int[5];
```

配列の宣言と、領域の確保、値の代入をまとめて行う場合は、`{ }`を使い、リテラルをカンマ区切りで必要数分記入します。

```java
int[] scores = {74, 88, 98, 53, 25};
```

##### 配列の領域数（要素数）を取得

確保された領域の数を取得するには、配列の変数の`length`を参照します。

```java
int[] scores = {74, 88, 98, 53, 25};
System.out.println(scores.length);    // 5と表示
```

for文の条件や、配列の要素の最後にアクセスする場合などに使用できます。

```java
int[] scores = {74, 88, 98, 53, 25};

// 要素の最後にアクセス
System.out.println(scores[scores.length - 1]); //25と表示される

// 各要素を順に表示
for (int i = 0; i < scores.length; i++) {
  System.out.print(scores[i] + ", "); // 74, 88, 98, 53, 25と表示される。
}
```

#### 複数次元の配列(多次元配列)

先ほどまでのは、1次元配列と呼ばれるものです。要素は単一のインデックス（整数値による連番：ゼロからスタート）でアクセスできます。
それに対して、複数の次元を持たせた配列を使うこともできます。

```java
// 教科ごとの点数(1次元)を生徒ごと(2次元)で管理したい
int[][] scoresOfStudents = new int[3][5];
```

必要な次元の数だけ`[]`をつなげます。

##### 多次元配列における各要素へのアクセス

基本は1次元配列と同じです。

```java
// 一人目の点数を代入
scoresOfStudents[0][0] = 100;
scoresOfStudents[0][1] = 70;
scoresOfStudents[0][2] = 50;
scoresOfStudents[0][3] = 98;
scoresOfStudents[0][4] = 45;
// 二人目
scoresOfStudents[1][0] = 70;
scoresOfStudents[1][1] = 70;
scoresOfStudents[1][2] = 45;
scoresOfStudents[1][3] = 68;
scoresOfStudents[1][4] = 70;

// ...以下省略
```

##### 多次元配列もまとめて初期化可能

配列内部の`{}`をカンマで区切ることで、多次元の配列を同時に宣言、初期化、代入ができます。

```java
int[][] scoresOfStudents = {
    {70, 60, 80, 90, 50},
    {81, 45, 32, 78, 100},
    {32, 44, 34, 55, 70},
};
```

##### 多次元配列の領域数を取得

先ほどの多次元配列にて

```java
System.out.println(scoresOfStudents.length);    //3と表示
```

次元ごとの領域数を取得するには、

```java
System.out.println(scoresOfStudents[0].length);    //5と表示
```