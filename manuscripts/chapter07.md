# 第7章 抽象クラスとインターフェイス：契約による設計

## 🎯総合演習プロジェクトへのステップ

本章で学ぶ「インターフェイス」は、**総合演習プロジェクト「ToDoリストアプリケーション」** のデータ保存機能を、より柔軟で交換可能なものにするための重要な設計技術です。

- **データ保存処理の抽象化**: タスクリストを保存する処理を考えるとき、保存先はテキストファイルかもしれませんし、将来的にはデータベースやクラウドストレージになるかもしれません。
- **`TaskRepository`インターフェイス**: `save(List<Task> tasks)`や`load()`といった「振る舞いの契約」だけを定義した`TaskRepository`インターフェイスを作成します。
- **具体的な実装クラス**: そして、「テキストファイルに保存する`FileTaskRepository`」や「データベースに保存する`DatabaseTaskRepository`」のように、インターフェイスを実装した具体的なクラスを、必要に応じて作成します。

アプリケーションのほかの部分は、具体的な保存方法を意識することなく、常��`TaskRepository`インターフェイスを通じて処理を依頼します。これにより、将来データ保存先を変更したくなった場合でも、アプリケーションの大部分を修正することなく、新しい実装クラスに差し替えるだけで対応できます。

## 📋 本章の学習目標

### 前提知識
- **第5章、第6章の知識**: 継承とポリモーフィズムの基本を理解している。

### 到達目標

#### 知識理解目標
- 「契約による設計」という考え方の重要性を理解する。
- 抽象クラスとインターフェイスの役割と、それぞれの違いを明確に説明できる。
- `abstract`キーワードと`implements`キーワードの使い方を理解する。
- インターフェイスがJavaにおける多重継承の代替手段として機能することを理解する。

#### 技能習得目標
- `abstract`メソッドを持つ抽象クラスを定義し、それを継承してサブクラスで実装できる。
- `interface`を定義し、複数のクラスに実装させることができる。
- 抽象クラスとインターフェイスを、それぞれの特性に応じて適切に使い分けることができる。

---

## 7.1 契約による設計と抽象化

前章で学んだポリモーフィズムは、スーパークラスの型でさまざまなサブクラスを統一的に扱うことで、コードの柔軟性を高める強力なしくみでした。しかし、スーパークラスの設計によっては、いくつかの課題が残ります。

- スーパークラスのメソッドに具体的な処理が不要な場合（例：`Animal`クラスの`makeSound()`）でも、何らかの処理を書く必要がある。
- サブクラスの開発者が、オーバーライドすべき重要なメソッドを実装し忘れる可能性がある。

これらの課題を解決し、より安全で拡張性の高い設計を可能にするのが「**抽象クラス**」と「**インターフェイス**」です。これらは、「**契約による設計（Design by Contract）**」という思想をJavaで実現するための重要なツールです。

「契約による設計」とは、クラスやメソッドが満たすべき「責務」や「仕様」を明確に定義し、その契約を守ることをコンパイラレベルで強制するアプローチです。

## 7.2 抽象クラス (Abstract Class)

**抽象クラス**とは、その名の通り「抽象的」なクラスであり、**インスタンスを直接生成できない**という特徴を持ちます。抽象クラスは、いくつかの具体的なメソッドと、**`abstract`** キーワードが付いた**抽象メソッド**を持つことができます。

**抽象メソッド**とは、メソッド名、引数、戻り値の型だけが定義され、具体的な処理内容（メソッドボディ `{}`）を持たないメソッドのことです。

```java
public abstract void makeSound(); // メソッドボディがなく、セミコロンで終わる
```

抽象クラスを継承したサブクラスは、**スーパークラスが持つすべての抽象メソッドを、必ずオーバーライドして実装しなければならない**というルールがコンパイラによって強制されます。

### 抽象クラスの実践例：`Animal`クラスの改良

前章の`Animal`クラスを抽象クラスとして再設計してみましょう。

```java
// Animal.java (抽象クラス)
public abstract class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    // 具象メソッド（具体的な実装を持つ）
    public void sleep() {
        System.out.println(this.name + " は眠っています。");
    }

    // 抽象メソッド（実装はサブクラスに強制される）
    public abstract void makeSound();
}

// Lion.java
public class Lion extends Animal {
    public Lion(String name) { super(name); }

    // 抽象メソッドの実装が必須
    @Override
    public void makeSound() {
        System.out.println(this.name + " が「ガオー」と吠えます。");
    }
}

// Dog.java
public class Dog extends Animal {
    public Dog(String name) { super(name); }

    // こちらも実装が必須
    @Override
    public void makeSound() {
        System.out.println(this.name + " が「ワン」と鳴きます。");
    }
}

// Main.java
public class Main {
    public static void main(String[] args) {
        // Animal animal = new Animal("謎の動物"); // コンパイルエラー！抽象クラスはインスタンス化できない

        Animal lion = new Lion("レオ");
        Animal dog = new Dog("ポチ");

        lion.makeSound(); // ガオー
        dog.makeSound();  // ワン
    }
}
```

抽象クラスを使うことで、「動物なら必ず鳴き声を持つべきだが、その鳴き方は動物の種類による」という、より現実に即した、安全なモデルを構築できます。

## 7.3 インターフェイス (Interface)

**インターフェイス**は、クラスが持つべき**メソッドの仕様（契約）** だけを定義した、完全な「設計図」です。抽象クラスよりもさらに抽象度が高く、以下の特徴を持ちま��。

-   すべてのメソッドは、デフォルトで`public abstract`（実装を持たない抽象メソッド）となる。
-   フィールドを持つことはできず、定数（`public static final`な変数）のみ定義できる。
-   クラスは、`implements`キーワードを使ってインターフェイスを**実装**する。
-   クラスは、**複数のインターフェイスを同時に実装できる**（多重継承の代替）。

インターフェイスは、「**〜ができる**」という能力（振る舞い）を表現するのに適しています。

### インターフェイスの実践例：`Flyable`と`Swimmable`

「飛べる」「泳げる」といった能力をインターフェイスとして定義してみましょう。

```java
// Flyable.java (インターフェイス)
public interface Flyable {
    void fly(); // public abstract が自動的に付与される
}

// Swimmable.java (インターフェイス)
public interface Swimmable {
    void swim();
}

// Duck.java (両方のインターフェイスを実装)
public class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("アヒルが羽ばたいて飛びます。");
    }

    @Override
    public void swim() {
        System.out.println("アヒルが水面を���雅に泳ぎます。");
    }
}

// Fish.java (Swimmableのみを実装)
public class Fish implements Swimmable {
    @Override
    public void swim() {
        System.out.println("魚がヒレを使って泳ぎます。");
    }
}

// Main.java
public class Main {
    public static void main(String[] args) {
        Flyable duckAsFlyer = new Duck();
        duckAsFlyer.fly();

        Swimmable duckAsSwimmer = new Duck();
        Swimmable fish = new Fish();
        duckAsSwimmer.swim();
        fish.swim();
    }
}
```

このように、インターフェイスを使うことで、継承関係にないクラス（`Duck`と`Fish`）に対しても、「泳げる」という共通の型（`Swimmable`）を与え、統一的に扱うことが可能になります。

## 7.4 抽象クラス vs インターフェイス

どちらも「実装の強制」と「ポリモーフィズム」を実現する手段ですが、明確な使い分けがあります。

| 特徴 | 抽象クラス (Abstract Class) | インターフェイス (Interface) |
| :--- | :--- | :--- |
| **目的** | **is-a** 関係。モノの「本質」を定義。 | **can-do** 関係。モノの「能力」を定義。 |
| **継承/実装** | `extends` (単一継承のみ) | `implements` (複数実装が可能) |
| **メンバー** | 抽象メソッド + **具象メソッド** + **フィールド** | **定数** + **抽象メソッド** (Java 8以降はdefault/staticメソッドも可) |
| **使い分け** | 関連性の強いクラス間で、共通の実装やフィールドを共有したい場合。 | クラスの種類にかかわらず、共通の振る舞いを強制したい場合。 |

**経験則:**
- まずはインターフェイスで設計できないか検討する。
- 継承階層の中で、共通のコードや状態をサブクラス間で共有したい場合に、抽象クラスの利用を検討する。

## まとめ

本章では、より安全で柔軟なオブジェクト指向設計を実現するための「抽象クラス」と「インターフェイス」について学びました。

-   **抽象クラス**は、一部の実装を共有しつつ、サブクラスに特定メソッドの実装を強制する「半完成の設計図」です。
-   **インターフェイス**は、クラスが実装すべきメソッドの仕様（契約）のみを定義した「完全な設計図」です。
-   これらは「**契約による設計**」を実現し、プログラムの安全性と拡張性を高めます。
-   **is-a**の関係性には**抽象クラス**、**can-do**の能力には**インターフェイス**、という使い分けが基本です。

���れらの概念をマスタすることで、単に動くだけでなく、将来の変更に強く、再利用性の高い、プロフェッショナルなソフトウェア設計が可能になります。